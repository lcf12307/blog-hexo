{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/wechat.jpg","path":"img/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1579490947495},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1579490947495},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1579490947495},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1579490947496},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1579490947496},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1579490947510},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1579490877016},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1579490947496},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1579490947496},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1579490947496},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1579490947496},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1579490947496},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1579490947497},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1579490947497},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1579490947497},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1579490947497},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1579490947497},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1579490947497},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1579490947497},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1579490947507},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1579490947508},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1579490947508},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1579490947508},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1579490947509},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1579490947509},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1579490947509},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1579490947510},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1579490947497},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1579490947497},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1579490947498},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1579490947498},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1579490947498},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1579490947498},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1579490947498},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1579490947498},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1579490947499},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1579490947499},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1579490947500},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1579490947500},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1579490947505},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1579490947506},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1579490947506},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1579490947507},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1579490947511},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1579490947514},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1579490947520},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1579490947520},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1579490947520},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1579490947521},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1579490947521},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1579490947521},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1579490947521},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1579490947523},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1579490947522},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1579490947523},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1579490947524},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1579490947499},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1579490947499},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1579490947499},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1579490947499},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1579490947499},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1579490947500},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1579490947511},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1579490947512},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1579490947512},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1579490947512},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1579490947512},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1579490947512},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1579490947513},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1579490947513},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1579490947513},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1579490947513},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1579490947513},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1579490947514},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1579490947515},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1579490947515},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1579490947518},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1579490947521},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1579490947522},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1579490947522},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1579490947522},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1579490947522},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1579490947522},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1579490947518},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1579490947516},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1579490947520},{"_id":"public/2020/01/20/hello-world/index.html","hash":"0145a4714ae9674b886ae9c7bb5d6b652fc31e59","modified":1579500534999},{"_id":"public/index.html","hash":"b1285c8a08e5c194da4f72252c03fa1250e28e60","modified":1623246736540},{"_id":"public/archives/index.html","hash":"d01d119d7aecc889fa39a84aacb60784019caa63","modified":1623246736540},{"_id":"public/archives/2020/index.html","hash":"408569d05c0639fc62fc8b67a5ccc4e1a335e76d","modified":1623246736540},{"_id":"public/archives/2020/01/index.html","hash":"817cf29a04414d05d23dafd8aa370439d032997e","modified":1623246736540},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1579491067399},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1579491067399},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1579491067399},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1579491067399},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1579491067399},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1579491067399},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1579491067399},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1579491067399},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1579491067399},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1579491067399},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1579491067399},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1579491067399},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1579491067399},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1579491067399},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1579491067399},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1579491067399},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1579491067399},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1579491067399},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1579491067399},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1579491067399},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1579491067399},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1579491067399},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1579491067399},{"_id":"source/_posts/README.md","hash":"6c8277dab2461a6608157f9404edca8ca867c90f","modified":1579506388525},{"_id":"public/2020/01/20/README/index.html","hash":"dd7950d935efc35178e62b5bd6396eeb9180366d","modified":1579509674308},{"_id":"themes/indigo/.editorconfig","hash":"9b0445427777519defe360ea38c61729d847b3d3","modified":1579504997072},{"_id":"themes/indigo/LICENSE","hash":"24944bf7920108f5a4790e6071c32e9102760c37","modified":1579504997072},{"_id":"themes/indigo/README.md","hash":"4bf26d9b43bf24b8e0a1a0d058437a347972f5e6","modified":1579504997072},{"_id":"themes/indigo/package.json","hash":"1dda330182e09e65613efa35db72621dcf08ce67","modified":1579505327394},{"_id":"themes/indigo/_config.yml","hash":"a4b3fe35852a65784005e117c472a18595586b6a","modified":1579596759402},{"_id":"themes/indigo/languages/en.yml","hash":"1957d2bfc3a4cef299f4f169b431e9b1128ba162","modified":1579504997072},{"_id":"themes/indigo/languages/ja.yml","hash":"74fd480874bf5e773ba7f9d2a94697cda979091f","modified":1579504997073},{"_id":"themes/indigo/languages/nl-NL","hash":"9085c04491f93066f2369911cc2175b59ae596ad","modified":1579504997073},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"7dc6ae434dde390b6768d244132e23cc78c33817","modified":1579504997073},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"6a9e820be66eb12ae746f2527e0dc1adf927c685","modified":1579504997073},{"_id":"themes/indigo/scripts/plugins.js","hash":"e439d717513616bedeed37ba9b05117470809b21","modified":1579504997079},{"_id":"themes/indigo/layout/archive.ejs","hash":"d039719e21f6a6fa2925b00aaa623a180a78c818","modified":1579504997078},{"_id":"themes/indigo/layout/categories.ejs","hash":"41783d2069d5080566a99e6312aa2113105f8b41","modified":1579504997078},{"_id":"themes/indigo/layout/category.ejs","hash":"7ea26a8a935886963eda82f41c7bd5270cf780d9","modified":1579504997078},{"_id":"themes/indigo/layout/index.ejs","hash":"39477807b98b2d2df78f3b82498a11e90be8222c","modified":1579504997078},{"_id":"themes/indigo/layout/layout.ejs","hash":"d52f43fa9572d70cae834e4887c8897b43744805","modified":1579504997078},{"_id":"themes/indigo/layout/page.ejs","hash":"afb98face24d39a21ebbbde6592a9afc98572aa4","modified":1579504997078},{"_id":"themes/indigo/layout/post.ejs","hash":"afbf8532dc8d148ca4dff2ca127a3382907cf2f5","modified":1579504997078},{"_id":"themes/indigo/layout/tag.ejs","hash":"36786a3de7f6cad58209603f7d84ba23addea174","modified":1579504997078},{"_id":"themes/indigo/layout/tags.ejs","hash":"20466446c41409d14a3d42ccaec24a65a045efef","modified":1579504997079},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"9ac30b9439fab69973cf4722dbf2945a18fd3804","modified":1579504997073},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"55cd81ef9183426d6d99fd91550fce0a9cc92aa0","modified":1579504997073},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"e1a71a30a1c7a664ddf3ba3e7eb3a5b90bc4b33c","modified":1579504997073},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"02a95a88774cc50dbcc32242b6c8ac7e9d9028bb","modified":1579504997074},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"6156bf20791e46fc1c5872113276c1c1f5c13773","modified":1579504997074},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"ec7b3ec79bbbead9c7e43e2e6c6b5c8bef509410","modified":1579504997074},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1579504997074},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"d39afaad6b0dd2a3ae27e6db3e9a6cd6014622fa","modified":1579504997074},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"dc27242927890f130a64400596b9b7ad5fca8972","modified":1579504997074},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"a87d9b0485b3bf4cdfdad890e5974c43dbaa8240","modified":1579504997076},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"7e06d1c3ecf964a0a31e811d2c4935e084c6ad5c","modified":1579504997077},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"c2091c621b5480ef1e69d72027028cec8e929892","modified":1579504997077},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"19eff4876d31080a427644f7a43fe172d0c008c6","modified":1579504997077},{"_id":"themes/indigo/source/css/style.less","hash":"f22d4146e0bdb4485d33f20080c67ba05724afea","modified":1579504997101},{"_id":"themes/indigo/source/img/alipay.jpg","hash":"6054d9ed2ca7cd1f645b729e05632134467d4daa","modified":1579504997102},{"_id":"themes/indigo/source/img/avatar.jpg","hash":"5be44b89831fdea8deec01601c2da3278741fcfa","modified":1579507936810},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1579504997102},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1579504997103},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1579504997103},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1579504997103},{"_id":"themes/indigo/source/img/wechat.jpg","hash":"ef069cc9e80c7553fd60589b0727bbbf8c6de372","modified":1579504997103},{"_id":"themes/indigo/source/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1579504997103},{"_id":"themes/indigo/source/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1579504997104},{"_id":"themes/indigo/source/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1579504997104},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1579504997104},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"e44d526029f122e9c2c74f3a647c35002c818cbe","modified":1579504997074},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"4a0c01e4195f685f9825fcd016d01249dbdd52ca","modified":1579504997074},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"23c101d45911eb0846533aaa2d409c43aa5e899a","modified":1579504997074},{"_id":"themes/indigo/layout/_partial/plugins/gitalk.ejs","hash":"bcf792a5633151fd999319fd91cf477e6860ae9c","modified":1579504997075},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"5723d507eca4390e8e5d18c0770e7953b8c22f5a","modified":1579504997075},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"a947f4076b54b48d4df5baf2d5b3c39b632c7576","modified":1579504997075},{"_id":"themes/indigo/layout/_partial/plugins/hyper-comments.ejs","hash":"e5a83acc7c2e385b0c9abf428e86e8fdfd3a5202","modified":1579504997075},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"ea603a057196de53bd6afab1fddb93d11f27eb81","modified":1579504997075},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"2decb77bf3c1a064ea6ce1d4e78892c434d9c884","modified":1579504997075},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"8fbd0910828f1ab6eba728bdecc9811d623baae2","modified":1579504997075},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"97b48fe10be1c71d4ff25ccec3bd92d97466c9c5","modified":1579504997075},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"e370bd04ea5cf1c83e0c20516aff7ba3ca8b2d0b","modified":1579504997076},{"_id":"themes/indigo/layout/_partial/plugins/valine.ejs","hash":"a976ca36bd09aeb2902bf94fcc7a59975ea25148","modified":1579504997076},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1579504997076},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"21530a1bc362d286d08dbce0baf37d09d7c58c92","modified":1579504997076},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"5305ed30ee35cf50f87656737d0ffe85f5bfc16b","modified":1579504997076},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"6b101fda5d4d1d13bff97b3eb579a87d04e8366e","modified":1579767085522},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1579504997076},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"11e7d504f7c7a3c4c052da13cfa8ea4862c9383e","modified":1579504997076},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"41c242fe3159dc68cec8dd00ab6d2663f5a51179","modified":1579504997076},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"23719e09689b3afbb19214c6603eb02f896cb9ba","modified":1579504997077},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"93482ad7d1e01b966f5ee1c5d12b88564e02b349","modified":1579504997077},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"8df0d7bf6f8e106cdbdac2dd10a97367aa0695f8","modified":1579504997077},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"b3dc38652c4a018a37418136478dcd522fc49f79","modified":1579504997077},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1579504997077},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"ad287a70724eb7cd8cd2a03a45b68032ee99973d","modified":1579504997077},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"5caa71745aa340ce57938a930f3b898ee7518d74","modified":1579504997077},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"7d2a6886265386c640e94ffca3f042675f701a35","modified":1579504997079},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"d476cd3537bcd8a02d055cc223f5c805b8638cc2","modified":1579504997079},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1579504997080},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"90f0948a9182c14b1dac1e9dbed3c883543266f9","modified":1579504997080},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"58492b7cdb45fe09b026b2f34e8ae69c2ddb8228","modified":1579504997080},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"4390ed22abad59c8b28ed1a479a52f15b5f9cf4a","modified":1579504997080},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"9b961eb1d70e7658f42cf2ca895fa5e35a6b6541","modified":1579504997080},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"f9d06a1e24fb4857fd18d7a0bfbb3a0ab2d1c742","modified":1579504997080},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"e92ccb53e6ac73a51498c6a9672db9d0d2bc7f1a","modified":1579504997081},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"1c041bf91106808e5480c60d9ece45431bb503b3","modified":1579504997081},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"4857f90bb57fc22ca3f942d8934d86d5e9e82c1e","modified":1579504997081},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1579504997081},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"1d6641ae7568a0153d24beba9fd9704d2b155f6c","modified":1579504997081},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"27d80bcc96a53dd1e7eaa9a7d746e4b212357302","modified":1579504997081},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"959f4373fda6e45f6a4041a995ed3ea8a05a5170","modified":1579504997081},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"082896b966ed25b39c74e7b007b4f54c235685a4","modified":1579504997081},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"77bfd0b373b0469eb0176167fb076ccda4edf2a7","modified":1579504997081},{"_id":"themes/indigo/source/css/_plugin/valine.less","hash":"ddbb7647d83f732f9b0d5d817d40a748006949cc","modified":1579504997082},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"ca30b732d2efbb0cd55a272ecdabc97f895aee78","modified":1579504997080},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1579504997091},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1579504997093},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1579504997093},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1579504997095},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1579504997095},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1579504997097},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1579504997097},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1579504997099},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1579504997099},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1579504997099},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1579504997101},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1579504997101},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1579504997090},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1579504997090},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1579504997092},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1579504997092},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1579504997094},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1579504997094},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1579504997096},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1579504997096},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1579504997098},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1579504997083},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1579504997085},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1579504997089},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1579504997100},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1579504997088},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1579505265970},{"_id":"public/img/avatar.jpg","hash":"5be44b89831fdea8deec01601c2da3278741fcfa","modified":1579508139867},{"_id":"public/css/style.less","hash":"f22d4146e0bdb4485d33f20080c67ba05724afea","modified":1579505265970},{"_id":"public/img/alipay.jpg","hash":"6054d9ed2ca7cd1f645b729e05632134467d4daa","modified":1579505265970},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1579505265970},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1579505265970},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1579505265970},{"_id":"public/img/wechat.jpg","hash":"ef069cc9e80c7553fd60589b0727bbbf8c6de372","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1579505265970},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1579505265970},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1579505265970},{"_id":"public/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1579505265970},{"_id":"public/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1579505265970},{"_id":"public/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1579505265970},{"_id":"public/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1579505265970},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1579505265970},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1579505265970},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1579505265970},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1579505265970},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1579505265970},{"_id":"themes/indigo/package-lock.json","hash":"6407d8888250dc1b62b975053137787d6a5ea03d","modified":1579505327422},{"_id":"source/categories/index.md","hash":"935fd0bd141017215172c189bbe93622dd9600dd","modified":1579505941704},{"_id":"source/tags/index.md","hash":"4c4e76cb73a4dec3c2eeed040fdfaa783ce782d4","modified":1579505903127},{"_id":"public/atom.xml","hash":"b79d825b9fbdf8fdbbc27ddaaa291e30e1e4a279","modified":1623246736540},{"_id":"public/content.json","hash":"a6d4efac2f1d3e4ce433185877805424a1595b99","modified":1623246736540},{"_id":"public/categories/index.html","hash":"f96256b0fd03978fff2643b826b8244719e5c31b","modified":1623246736540},{"_id":"public/tags/index.html","hash":"1fafcf473a5286eefa9929a7c885f26c2c07de76","modified":1623246736540},{"_id":"themes/indigo/layout/_partial/post/.date.ejs.swp","hash":"05ee3b88b34cd570db612f70b8acd7708e70de5a","modified":1579509667744},{"_id":"source/_posts/五花八门的安装/hexo.md","hash":"7f0bb51ced06090304f66c946b3c537e3fedc806","modified":1579573544704},{"_id":"public/2020/01/20/五花八门的安装/hexo/index.html","hash":"f88a063b686a5e5655e77d8af28f035266431dff","modified":1579576295689},{"_id":"public/tags/node/index.html","hash":"442784524799b73f4f55a69eb616e4d1c922a7bd","modified":1623246736540},{"_id":"public/tags/hero/index.html","hash":"3efd14ef7d879391bb41e5bcced7eb676b793f87","modified":1579529644346},{"_id":"source/_posts/花里胡哨的操作/python一行创建http服务器.md","hash":"3524fba7b0e35f7afa064f28c6193e67a9688373","modified":1579576293156},{"_id":"public/tags/hexo/index.html","hash":"c1bbef952844fdb0f6ac6df18a2b016410bc128d","modified":1623246736540},{"_id":"public/categories/花里胡哨的操作/index.html","hash":"8f8c31864a2d2d2d975ca68ab6d45c2d62e6dbad","modified":1579576295689},{"_id":"public/tags/python/index.html","hash":"61be0104e459c6509fea7eace8143f8d4a6b01a9","modified":1623246736540},{"_id":"public/2020/01/20/花里胡哨的操作/python一行创建http服务器/index.html","hash":"ba68cea8e6519c3c1d3891aa875ff04fb43e0995","modified":1579576295689},{"_id":"source/_posts/应用安装&破解/hexo.md","hash":"3d9a4731f508a4488577a7460ca2ba21fd786cb8","modified":1579599546610},{"_id":"source/_posts/极客操作/python一行创建http服务器.md","hash":"490594cff6bd0734b8e2ea2977e83fac099393e4","modified":1579599337504},{"_id":"source/_posts/常见问题/问题 No input file specified.md","hash":"8f8fa220e705709c964ec4042892cfb2010e8aaf","modified":1579576912978},{"_id":"public/tags/服务器/index.html","hash":"2c2cd9681dfdf75c62f3da3238735d1a2520356a","modified":1623246736540},{"_id":"public/categories/极客操作/index.html","hash":"a25951533be8cea0e93cc2f0e6f41e94b6314009","modified":1623246736540},{"_id":"public/categories/应用安装-破解/index.html","hash":"a2f42c47b9260b441458ae118ae793f12e8f67d9","modified":1623246736540},{"_id":"public/tags/php/index.html","hash":"321926508cae34e907379b83d29ad1766aeb1de0","modified":1623246736540},{"_id":"public/categories/常见问题/index.html","hash":"6a7a640f8d145e6ba0c55ca02b5e44eb9b82eaed","modified":1623246736540},{"_id":"public/2020/01/21/常见问题/问题 No input file specified/index.html","hash":"51e10b9858ef6155e131932f82473bf6541845b9","modified":1579586496170},{"_id":"public/2020/01/20/极客操作/python一行创建http服务器/index.html","hash":"b98852030254c9330a713301d4216995dae99f4b","modified":1579778005756},{"_id":"public/2020/01/20/应用安装&破解/hexo/index.html","hash":"59df6a8a866821b486e690b04942f42f2a681440","modified":1583303045446},{"_id":"source/_posts/面试/缓存.md","hash":"56181f2fcc5cadaee4a8e63c82ba2ec09e22969f","modified":1579590343800},{"_id":"source/_posts/面试/网络.md","hash":"85006d063678649fc9cd2b729ed626860cd3aca5","modified":1579593110545},{"_id":"source/_posts/面试/高并发.md","hash":"ef439de5d24bcea7861bd3da0eb1ba0108257154","modified":1579594169004},{"_id":"public/archives/2019/index.html","hash":"61d47eb3cc324c414e70899066ba12b1e6670142","modified":1623246736540},{"_id":"public/archives/2019/11/index.html","hash":"27064a9a3ea04b8e317f673da2d6b819e63fc17f","modified":1623246736540},{"_id":"public/categories/面试/index.html","hash":"b5e29738a8448cc30625f873128ac97a7c19d94d","modified":1623246736540},{"_id":"public/tags/高并发/index.html","hash":"6f2a3fba3b1a8a8af39c151ad6a9fad6ac508513","modified":1583303045446},{"_id":"public/tags/go/index.html","hash":"490c382fdfaf07aa2b487e120c9be781928b9053","modified":1623246736540},{"_id":"public/tags/http/index.html","hash":"369cbdc3ed351d0586cb28584d0c33adc56b10f3","modified":1623246736540},{"_id":"public/tags/memcache/index.html","hash":"f54555366b5e75d217c010bca7af6a27252fb316","modified":1623246736540},{"_id":"public/tags/网络/index.html","hash":"3d01a5b33af108d533b3fc8df98eb8c9615faf94","modified":1623246736540},{"_id":"public/tags/redis/index.html","hash":"a55581d0fbea45018046eb3254314b7cb6312155","modified":1623246736540},{"_id":"public/tags/缓存/index.html","hash":"e11df47d6d0cf1e4d7be62cf9b9650c799ee0d57","modified":1623246736540},{"_id":"public/2019/11/07/面试/高并发/index.html","hash":"ad3e5c0f1848fae1eb7d24bb96a28e04b247d82b","modified":1579594175676},{"_id":"public/2019/11/05/面试/缓存/index.html","hash":"afe611aa844e3beb5b37c597b3a89dc2555b4824","modified":1579594175676},{"_id":"public/2019/11/06/面试/网络/index.html","hash":"29da111c464f48a19ece028eaab2dedd76690301","modified":1579594175676},{"_id":"source/_posts/面试/大而泛/linux.md","hash":"170346f14f3e278c65a63653b49513859f0dfe19","modified":1579599659744},{"_id":"source/_posts/面试/大而泛/操作系统.md","hash":"13f7eb6b9620cc986439cb31e519b68d52ab4525","modified":1579599680283},{"_id":"source/_posts/面试/大而泛/数据库.md","hash":"2352779645728afa2def01773c6f81270b97d997","modified":1579599636168},{"_id":"source/_posts/面试/大而泛/缓存.md","hash":"4c2bbb30de3e897f44a915b661b043a160e019fa","modified":1579599622563},{"_id":"source/_posts/面试/大而泛/网络.md","hash":"7c9cc72cf8a9ef67b922919c168d5a1b26e27adf","modified":1579599646651},{"_id":"source/_posts/面试/大而泛/设计模式.md","hash":"8636834acff7ab8cbc2a40ba5f721f3a99760253","modified":1579599695396},{"_id":"source/_posts/面试/大而泛/高并发.md","hash":"2b3303dc73865d7f7357960b25896872cf7dcc2f","modified":1579599598406},{"_id":"public/tags/linux/index.html","hash":"fe9edd6ee2551b2b7106756b8b8544331618941c","modified":1623246736540},{"_id":"public/tags/数据库/index.html","hash":"d34373169fe8481ca3c32d04b2db0654e7ecfc6b","modified":1623246736540},{"_id":"public/tags/MYSQL/index.html","hash":"54025afabfbcfa603b38dfd8974191aabfcabd25","modified":1623246736540},{"_id":"public/tags/设计模式/index.html","hash":"0f693da108de54ab7c2be972aa9bcccccf953b9f","modified":1623246736540},{"_id":"public/2019/11/14/面试/大而泛/设计模式/index.html","hash":"2224950f199f1a45f632baaa4345600865d8ca7b","modified":1582630064417},{"_id":"public/2019/11/13/面试/大而泛/操作系统/index.html","hash":"ecec4b2bb8b59a92329b2992be6abaea58cf269e","modified":1579778005756},{"_id":"public/2019/11/12/面试/大而泛/linux/index.html","hash":"816164386db37a5a93a92aff495d28c60a0dd373","modified":1579778005756},{"_id":"public/2019/11/08/面试/大而泛/数据库/index.html","hash":"a577e767840cc189d432595cc2bea2a58321df81","modified":1579778005756},{"_id":"public/2019/11/07/面试/大而泛/高并发/index.html","hash":"7854d76ef7c56e4dc796c4ddc05f3ab5add47180","modified":1579778005756},{"_id":"public/2019/11/06/面试/大而泛/网络/index.html","hash":"0a54f449794c556c29434693ee35bd96829473df","modified":1579778005756},{"_id":"public/2019/11/05/面试/大而泛/缓存/index.html","hash":"67bf72ace2e3026c1dc5b5dbbfcf79b329454be4","modified":1579778005756},{"_id":"source/_posts/常见问题/No input file specified.md","hash":"7a3c8c7a1b51d0ee72ca9837134928fdb46994be","modified":1579599402204},{"_id":"source/_posts/常见问题/wine应用无法输入中文.md","hash":"dd1413e21bf2d3588bdd072d66683dc1171e1de9","modified":1579599408644},{"_id":"public/archives/2019/07/index.html","hash":"51516db2dc106aa1672d1f7dae9055ea08b53e1d","modified":1623246736540},{"_id":"public/archives/page/2/index.html","hash":"d2fb0967466350880b61dff9dc3b5192484a2e86","modified":1623246736540},{"_id":"public/page/2/index.html","hash":"3185f716cf3777719e7dd51f9cd3189cf12858c5","modified":1623246736540},{"_id":"public/2020/01/21/常见问题/No input file specified/index.html","hash":"2dccfe480af6f5027504d773ba1e209003b777fa","modified":1623246736540},{"_id":"public/2019/07/21/常见问题/wine应用无法输入中文/index.html","hash":"010a20e097e828ab34b2e42ebfeebd78e29a2fd8","modified":1623246736540},{"_id":"source/_posts/常见问题/hexo常见问题.md","hash":"fce1ae0ffcbf0ad5937cc0e9bfc62691a900c4b9","modified":1579599990250},{"_id":"source/_posts/常见问题/ubuntu安装navicat.md","hash":"9f34c0096977a25ef1ec3a18cca3c3d5e7138bab","modified":1579770211021},{"_id":"source/_posts/常见问题/ubuntu安装wine应用.md","hash":"d4ae37f7369471b64344a2e0fdaa7299977a99b7","modified":1579772215563},{"_id":"source/_posts/常见问题/ubuntu安装vscode.md","hash":"518f52f1c2add551850ba99f2ae5b46502b6d9ef","modified":1579770620874},{"_id":"source/_posts/常见问题/云服务器/bash快捷键.md","hash":"6da85d30faa7df20168f00746eef864f3d3311e5","modified":1579772490351},{"_id":"source/_posts/常见问题/云服务器/git常见命令.md","hash":"b53ae9f4a227338bb1bbd482466a576e5b079cc1","modified":1579771730994},{"_id":"source/_posts/常见问题/云服务器/linux命令-scp.md","hash":"c01a19f83cd3cd3e7d8092321246aa91d951d326","modified":1579771740334},{"_id":"source/_posts/常见问题/云服务器/linux多命令连接.md","hash":"905fdae262fc4e6960683516497a0250a44dd388","modified":1579771735897},{"_id":"source/_posts/常见问题/云服务器/linux搜索命令.md","hash":"ca7c9c31b529c8b10f1c3dc16e678c99da3b3051","modified":1579771747265},{"_id":"source/_posts/常见问题/云服务器/mysql忘记密码.md","hash":"cbb90aecd527a20fc1365b6578f05123a97c99a2","modified":1579772053315},{"_id":"source/_posts/常见问题/云服务器/nginx403.md","hash":"256d15da943abf27c08ddaba6853bf24110989f1","modified":1579771755309},{"_id":"source/_posts/常见问题/云服务器/vim快捷键.md","hash":"afc5e6fb6d1e63c56a659741fc6a663a04452fcf","modified":1579772445901},{"_id":"source/_posts/常见问题/云服务器/访问php直接下载.md","hash":"eb972e7ef97345803d222ea96d5a3b1bccae9fc1","modified":1579771724283},{"_id":"source/_posts/常见问题/云服务器/配置mysql远程访问权限.md","hash":"12c80e90dd4ea4e479aacbe802fc772ab801022d","modified":1579772077632},{"_id":"source/_posts/面试/Go基础/Go代码规范.md","hash":"bb2e691752e5820636b8b37c07e2508afc5831f1","modified":1579768904164},{"_id":"source/_posts/面试/Go基础/go语言规范.md","hash":"58a71e7800ed1a34dbe41eb3401bbdcdd2a3dbf4","modified":1579768908228},{"_id":"source/_posts/面试/Go基础/使用protocbuf.md","hash":"44ffb0a7b9df4e9dfa0b82c5e4a8aa1bde69b37b","modified":1579769007834},{"_id":"source/_posts/面试/Go基础/精选面试题.md","hash":"cc108a52ac8c81085bac2faca3d6c88cacd521d8","modified":1579768912714},{"_id":"source/_posts/面试/定点/HTTP，TCP， socket，RPC 与gRPC都是啥？.md","hash":"4aab8028dee8c3d16e0206c2f314a69b8fbfe8f9","modified":1579600800438},{"_id":"public/tags/mysql/index.html","hash":"a2307d2361ede94ee1bd9d83804b77592457e171","modified":1623246736540},{"_id":"public/archives/2018/05/index.html","hash":"3f558d7e4548b5ad1eb429335a928e737e1542e2","modified":1623246736540},{"_id":"public/archives/2018/07/index.html","hash":"0ad89b76a676298f38f83cdae87d11581baae81c","modified":1623246736540},{"_id":"public/archives/2018/08/index.html","hash":"3b56a3de74f12d0645f42368939c5dc245abfc01","modified":1623246736540},{"_id":"public/archives/2018/09/index.html","hash":"0b5deb16cdcd49c457e7abbfc5027af5eddfa395","modified":1623246736540},{"_id":"public/archives/2019/page/2/index.html","hash":"ac95131d62064e914b8f439fbf73d6eeaed7cb95","modified":1623246736540},{"_id":"public/archives/2019/02/index.html","hash":"d9b4a40df823368fd0b0a9b1758fbe707a4decdf","modified":1623246736540},{"_id":"public/categories/面试/page/2/index.html","hash":"9b67841e6477dee3474d94dd1fbde2ab2ef90011","modified":1623246736540},{"_id":"public/archives/2019/04/index.html","hash":"fe71b7250f3f385f61a84d45fc5000fcd8e228c3","modified":1623246736540},{"_id":"public/tags/wine/index.html","hash":"68e698e43ff364ba4686b5a76957f82f07f1746f","modified":1623246736540},{"_id":"public/tags/git/index.html","hash":"52d83137832c31f57b323b320862864a3951ecf1","modified":1623246736540},{"_id":"public/tags/thrift/index.html","hash":"f5129b8a6e88666f731706b4cb79a9c3c09f0f78","modified":1623246736540},{"_id":"public/tags/rpc/index.html","hash":"6803e45718df44cc78571df121b013c88488e490","modified":1623246736540},{"_id":"public/2019/04/24/常见问题/云服务器/vim快捷键/index.html","hash":"0d4da4d9395b567915e70941aff09ff295d6c0a1","modified":1623246736540},{"_id":"public/2019/04/24/常见问题/云服务器/bash快捷键/index.html","hash":"e247f65aeeadf4abfda148ab1e28c966c3d04f6c","modified":1623246736540},{"_id":"public/2019/02/20/面试/Go基础/Go代码规范/index.html","hash":"abfa5a79e4edd2fe81b7bdf402e572a373098990","modified":1579778005756},{"_id":"public/2019/02/20/面试/Go基础/go语言规范/index.html","hash":"eb86ba05c79cf154b31a4a4749c74d0db381a55e","modified":1579778005756},{"_id":"public/2019/02/20/面试/Go基础/精选面试题/index.html","hash":"3635bda3e034762da273fc44b714bc1dd4d288d7","modified":1579778005756},{"_id":"public/2019/02/18/面试/Go基础/使用protocbuf/index.html","hash":"2e25a4b973f0095697c34f083aa271e14471471e","modified":1579778005756},{"_id":"public/2019/02/18/常见问题/云服务器/git常见命令/index.html","hash":"be030041bfba1586672a0023b49f2e2c974511b8","modified":1623246736540},{"_id":"public/2020/01/21/常见问题/hexo常见问题/index.html","hash":"77586cc6515cb3ea0a1efc6fece114de7c1f8b99","modified":1623246736540},{"_id":"public/2020/01/21/面试/定点/HTTP，TCP， socket，RPC 与gRPC都是啥？/index.html","hash":"532f32e9d48075774d53c72b533af44deebdc6da","modified":1579778005756},{"_id":"public/2018/09/06/常见问题/云服务器/配置mysql远程访问权限/index.html","hash":"573f6ddbad798e0adbddf7e4d8a459e68fcb91f9","modified":1623246736540},{"_id":"public/2018/08/23/常见问题/云服务器/nginx403/index.html","hash":"cd609ec0c0db8dc4b2be8415900b64d94fc33c49","modified":1623246736540},{"_id":"public/2018/08/23/常见问题/云服务器/访问php直接下载/index.html","hash":"2f36f728c836500e92f61e4c872c788685d5e023","modified":1623246736540},{"_id":"public/2018/07/19/常见问题/ubuntu安装vscode/index.html","hash":"c512a8d55c3fc3fa2806b7bfbd348a746420ca59","modified":1623246736540},{"_id":"public/2018/07/18/常见问题/ubuntu安装navicat/index.html","hash":"46a1741b3e2ee0442a61da363f48581ba8f15214","modified":1623246736540},{"_id":"public/2018/07/06/常见问题/云服务器/linux多命令连接/index.html","hash":"39224b28e6864acec18f5121188eaf374c39e052","modified":1623246736540},{"_id":"public/2018/07/06/常见问题/云服务器/linux搜索命令/index.html","hash":"6ab911c24c71f9de59b34f1b93d1895657aa9351","modified":1623246736540},{"_id":"public/2018/07/12/常见问题/ubuntu安装wine应用/index.html","hash":"11983d7572b354480419fdced57057ef7e8359f3","modified":1623246736540},{"_id":"public/2018/05/23/常见问题/云服务器/mysql忘记密码/index.html","hash":"ed4fe9100c055a1f1f3ce601ad441efe0d98b2a2","modified":1623246736540},{"_id":"public/categories/常见问题/page/2/index.html","hash":"0140e48c2a8b41d9c68c14904d88131a2a3e8b08","modified":1623246736540},{"_id":"public/archives/2018/index.html","hash":"993ac095c7741ab904fc40da710ba5c8ac278d37","modified":1623246736540},{"_id":"public/2018/08/17/常见问题/云服务器/linux命令-scp/index.html","hash":"b0e511506a670dccefb8e5c54071195b90994c4d","modified":1623246736540},{"_id":"public/archives/page/3/index.html","hash":"3eb8cd27422438bd005be8fe0072798e76660466","modified":1623246736540},{"_id":"public/page/3/index.html","hash":"ae0a24dad1743a33f73ee845b98dab70689dde10","modified":1623246736540},{"_id":"public/tags/应用安装/index.html","hash":"42d7e95b5b6d712ca9f7f801f69fb33ce9f347c9","modified":1623246736540},{"_id":"public/tags/云服务器/index.html","hash":"2bb317caaf68be216b97bd1e2338eda77535cc49","modified":1623246736540},{"_id":"public/tags/快捷键/index.html","hash":"dd9372464ad90e70c12dbe4c8d0e04268e2748a9","modified":1623246736540},{"_id":"public/tags/nginx/index.html","hash":"e4edd642c7ff2d2c9bafed3575da9314a93331f4","modified":1623246736540},{"_id":"public/tags/linux/page/2/index.html","hash":"d6140aa1144375dcc09bc75fedfe4a33728fac32","modified":1623246736540},{"_id":"source/_posts/刷题心得/栈和队列/合法括号.md","hash":"b8e1ab9d1084070790dc10bd136a603a6ee6ff23","modified":1580868740225},{"_id":"source/_posts/刷题心得/链表和数组/K个一组反转链表.md","hash":"31456a749da2c4a96d965c17cbb22cd16a5c4087","modified":1580790112143},{"_id":"source/_posts/刷题心得/链表和数组/两两交换链表中的节点.md","hash":"aa6dec04c0d2581a0c3df3e66d6233270a2e1fcc","modified":1580785741760},{"_id":"source/_posts/刷题心得/链表和数组/反转链表.md","hash":"ff7da8f77617fd40909b353473706e0668aec93b","modified":1580785701682},{"_id":"source/_posts/刷题心得/链表和数组/环形链表.md","hash":"e07b861c409e279654c8dd1535d0a3da681b5734","modified":1580787042247},{"_id":"source/_posts/刷题心得/链表和数组/环形链表2.md","hash":"3f0a40f421900fc6d9dc1a609bbf68ebd2ecd775","modified":1580789200027},{"_id":"public/2020/02/05/刷题心得/栈和队列/合法括号/index.html","hash":"ac53298049c62667eed080e746ed9163947e7528","modified":1623246736540},{"_id":"public/2020/02/04/刷题心得/链表和数组/K个一组反转链表/index.html","hash":"7e77d2dbbab13e7a0bdd793170f9b577e11733a0","modified":1623246736540},{"_id":"public/2020/02/04/刷题心得/链表和数组/反转链表/index.html","hash":"557c322c1e8e92a24bfa232290c3afb40ae1ee50","modified":1623246736540},{"_id":"public/2020/02/04/刷题心得/链表和数组/环形链表/index.html","hash":"aecf44fccac11630387519cff847b6214e9ae098","modified":1623246736540},{"_id":"public/2020/02/04/刷题心得/链表和数组/环形链表2/index.html","hash":"8a00201cc6e63159afb232d5143915a24ecc3819","modified":1623246736540},{"_id":"public/2020/02/04/刷题心得/链表和数组/两两交换链表中的节点/index.html","hash":"2808455f4b95b04181c87969610a5f8787d734c4","modified":1623246736540},{"_id":"public/archives/2020/page/2/index.html","hash":"21f6a7c142ae48b9aefd9e0ec7f0ad9bc86d52ab","modified":1623246736540},{"_id":"public/tags/栈/index.html","hash":"0f166e656aebf386941c69ff03817750cac8088e","modified":1623246736540},{"_id":"public/categories/刷题心得/index.html","hash":"94978b344f437e27f4cabcc5dc4b217d13380302","modified":1623246736540},{"_id":"public/archives/page/4/index.html","hash":"2bbc60d9437ed8640307b73a9508f1a3a216e2e4","modified":1623246736540},{"_id":"public/archives/2020/02/index.html","hash":"4cfcceaa7bfb1e273b07d938b8aa60a0378d94f5","modified":1623246736540},{"_id":"public/page/4/index.html","hash":"13ced9f112c6bd3cbdedb950138f528c93621b1d","modified":1623246736540},{"_id":"public/tags/算法/index.html","hash":"234072f0d49b8bfcffb7ba6acca5b8022d366e0e","modified":1623246736540},{"_id":"public/tags/链表/index.html","hash":"d0856656c7513f03e4a2eb182ee9981a9a02d3f1","modified":1623246736540},{"_id":"source/_posts/.DS_Store","hash":"89829ca48737da427fb4455068cee408481c8be1","modified":1582471732194},{"_id":"source/_posts/面试/.DS_Store","hash":"20ba4ed25e81df32df606249dfe028adb4f68627","modified":1584426336105},{"_id":"source/_posts/应用安装&破解/python一行创建http服务器.md","hash":"490594cff6bd0734b8e2ea2977e83fac099393e4","modified":1579599337504},{"_id":"source/_posts/面试/复盘/1.16脉脉面试.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1582468328915},{"_id":"source/_posts/刷题心得/二分法/求平方根.md","hash":"a226b240e134ee52403e909a9b7e8f4e47c99030","modified":1581475112025},{"_id":"source/_posts/刷题心得/位运算/比特位计数.md","hash":"2bd42d3b775a6df4ecab2bcf5c5aedec5fef9408","modified":1581478898701},{"_id":"source/_posts/刷题心得/位运算/位一的个数.md","hash":"63427848934486bea24acbf0d848547b636528ba","modified":1581477311738},{"_id":"source/_posts/刷题心得/位运算/2的幂.md","hash":"0b536cca9bb6ca0bd869d35f516343d1c0aba9e7","modified":1581477790878},{"_id":"source/_posts/刷题心得/哈希表/异位词.md","hash":"0a9a135ec6161d1f80b7e3714f2d005da4860152","modified":1581042469649},{"_id":"source/_posts/刷题心得/剪枝/n皇后.md","hash":"dd28d5d9bf3273d7b45f75def129df773b48755e","modified":1581473686750},{"_id":"source/_posts/刷题心得/剪枝/n皇后2.md","hash":"22616e557157fa57a1c56e8591395da9f1a0aeb8","modified":1581479075328},{"_id":"source/_posts/刷题心得/栈和队列/滑动窗口最大值.md","hash":"41d308047068222e4e2650a24e4c1ba6809045d1","modified":1580961685817},{"_id":"source/_posts/刷题心得/栈和队列/用栈实现队列.md","hash":"d5a81b476de19d9ceab2e0ef1814c214ad56c6c5","modified":1580871513723},{"_id":"source/_posts/刷题心得/栈和队列/第k大元素.md","hash":"832c84d69e6ffa9d08076138506fee1ab8bc6854","modified":1580958173598},{"_id":"source/_posts/刷题心得/树/二叉树的层次遍历.md","hash":"ecb3962ecae1dab79bcccb7a65d24ef9af6f119d","modified":1582697553192},{"_id":"source/_posts/刷题心得/树/二叉树的最大深度.md","hash":"701f6f699bb2c9188fd4778d9051fe9a00ecf96b","modified":1581305430218},{"_id":"source/_posts/刷题心得/树/二叉搜索树的最近公共祖先.md","hash":"cab2cb5dabbfa8de02f364e59ea5395d40275d1f","modified":1581135847845},{"_id":"source/_posts/刷题心得/树/验证二叉搜索树.md","hash":"aefff0938a976a36bb6df85636bed79085168617","modified":1581135852558},{"_id":"source/_posts/刷题心得/贪心算法/买卖股票的最佳时机.md","hash":"23df4809471e9c25f5dfe52a6ead978825e4c587","modified":1581473695369},{"_id":"source/_posts/刷题心得/树/二叉树的最近公共祖先.md","hash":"6f6eb4e5c4f23c60dbf7fa802be2c3b3e1229518","modified":1581140200164},{"_id":"source/_posts/刷题心得/字符串/最长无重复子串.md","hash":"0c18c5bcb8ecbbe1c8d23629c954dcba9e4f4254","modified":1582182977275},{"_id":"source/_posts/刷题心得/递归分治/括号生成.md","hash":"0c5350d57dc89b87a922805c37cccf3be9651f98","modified":1581473705423},{"_id":"source/_posts/刷题心得/递归分治/求众数.md","hash":"82a20a3e14d1b5dd9f0f2564b2d6c32a4db34ed3","modified":1581235217179},{"_id":"source/_posts/刷题心得/递归分治/求指数.md","hash":"20e9a3bc3bbf3a2b23c7d51bca721dfdb55b2772","modified":1581473700498},{"_id":"source/_posts/面试/复盘/2.13头条面试.md","hash":"b173ddb43e7a6fdfd013d48cea714d00115c7456","modified":1585193018143},{"_id":"source/_posts/面试/复盘/2.24伴鱼面试.md","hash":"d5c3be1866c14b4856dbdf2f6f3eab5825f7bd10","modified":1582628208816},{"_id":"source/_posts/面试/复盘/2.24映客面试.md","hash":"12fb2a9899b1d94c6fe441bd986a1fd2c1f5b70a","modified":1582530703135},{"_id":"source/_posts/面试/复盘/2.24知乎面试.md","hash":"f1f61194bcccf170cae4abe0a01f0cc353e5061a","modified":1582595150580},{"_id":"source/_posts/面试/复盘/2.25作业帮面试.md","hash":"c85b1fc959bf5f30af2ff87ffa83901f103791a7","modified":1583380374967},{"_id":"source/_posts/面试/复盘/2.25来也面试.md","hash":"76480999f2b18593cb5bfe75d71160ef006ef109","modified":1582632010757},{"_id":"source/_posts/面试/大而泛/HTTP，TCP， socket，RPC 与gRPC都是啥？.md","hash":"4aab8028dee8c3d16e0206c2f314a69b8fbfe8f9","modified":1579600800438},{"_id":"public/2020/02/25/面试/复盘/2.25来也面试/index.html","hash":"d39c52251fcbee83caff5de43de85f5d9dcdc1b6","modified":1623246736540},{"_id":"public/2020/02/23/面试/复盘/1.16脉脉面试/index.html","hash":"299d4602330600ce7cfc05c4945fd8dbf00da500","modified":1582630064417},{"_id":"public/archives/page/7/index.html","hash":"e1bf3ee02237a2a66605f00ff415ef1956dce916","modified":1623246736540},{"_id":"public/archives/2020/02/page/4/index.html","hash":"326a7de55a8c39b2fedc8d4910dc7542439e20ea","modified":1623246736540},{"_id":"public/page/7/index.html","hash":"3321367dcefd8b631ba46cf88a40073ddf667abb","modified":1623246736540},{"_id":"public/2020/02/25/面试/复盘/2.25作业帮面试/index.html","hash":"c51defbfdf57c7e9b5144badd6b669cae453a7a1","modified":1623246736540},{"_id":"public/2020/02/24/面试/复盘/2.24知乎面试/index.html","hash":"c3dca2235793d6ef5eb38ca7f70ea5a6c3d0ad21","modified":1623246736540},{"_id":"public/2020/02/24/面试/复盘/2.24映客面试/index.html","hash":"76cec9bcedf883fe0fd664dc1196d39560a3bb96","modified":1623246736540},{"_id":"public/2020/02/24/面试/复盘/2.24伴鱼面试/index.html","hash":"d57747c9df5ec128b989456f524a6cc08f9b1788","modified":1623246736540},{"_id":"public/2020/02/11/刷题心得/位运算/位一的个数/index.html","hash":"53423cf95fd9f5d230262c65d92567ecf5e5eeb4","modified":1623246736540},{"_id":"public/2020/02/11/刷题心得/位运算/比特位计数/index.html","hash":"8cf7031734a8269a38f5e337742695fc03373fca","modified":1623246736540},{"_id":"public/2020/02/11/刷题心得/二分法/求平方根/index.html","hash":"74f0d71e67d8890eaf0ce249e99249e657502f20","modified":1623246736540},{"_id":"public/2020/02/11/刷题心得/位运算/2的幂/index.html","hash":"c7f122baeed07c7083becc776c0aa50104826b4d","modified":1623246736540},{"_id":"public/2020/02/10/刷题心得/剪枝/n皇后/index.html","hash":"ceaa0621e7d999d05b1a1853fa61a10fd76fe9d5","modified":1623246736540},{"_id":"public/2020/02/10/刷题心得/剪枝/n皇后2/index.html","hash":"991c0ed8212867b42fc1203102f6736322c42d3a","modified":1623246736540},{"_id":"public/2020/02/10/刷题心得/树/二叉树的层次遍历/index.html","hash":"f324d57d50b72c553fb25010a215da835ca4a9d1","modified":1623246736540},{"_id":"public/2020/02/10/刷题心得/树/二叉树的最大深度/index.html","hash":"41eb03fa9e76384774e99f915c0bed8a17c09740","modified":1623246736540},{"_id":"public/2020/02/10/刷题心得/递归分治/括号生成/index.html","hash":"a296f415719e9f7575d5c94514ad19fd32acdb5d","modified":1623246736540},{"_id":"public/2020/02/10/刷题心得/贪心算法/买卖股票的最佳时机/index.html","hash":"0b50761b25d627e1db37e00889b4f50007eca0da","modified":1623246736540},{"_id":"public/2020/02/09/刷题心得/递归分治/求众数/index.html","hash":"e95ae827f8947146131b73f3e33e42ac151c89f1","modified":1623246736540},{"_id":"public/2020/02/09/刷题心得/递归分治/求指数/index.html","hash":"0f4e9696c68818c16d55dfa17a7d5e2d9238ffe3","modified":1623246736540},{"_id":"public/2020/02/08/刷题心得/树/验证二叉搜索树/index.html","hash":"55f2f56f7c7bf631b68540f84536220535dab080","modified":1623246736540},{"_id":"public/2020/02/08/刷题心得/树/二叉树的最近公共祖先/index.html","hash":"bf4c265311e34eb8a16e2dfaa6fc493f4a0132f6","modified":1623246736540},{"_id":"public/2020/02/08/刷题心得/树/二叉搜索树的最近公共祖先/index.html","hash":"bae8901345897f72f74eacbef2a84594b1e42bbd","modified":1623246736540},{"_id":"public/2020/02/07/刷题心得/哈希表/异位词/index.html","hash":"281ddc44eae9aa7c6742c58460fd718d14d06316","modified":1623246736540},{"_id":"public/2020/02/05/刷题心得/栈和队列/滑动窗口最大值/index.html","hash":"86eeaa2c0ecb08544e7a4858b065030ba7f1559b","modified":1623246736540},{"_id":"public/2020/02/05/刷题心得/栈和队列/第k大元素/index.html","hash":"df2189f1fa9a98161c16de45b0fdffea35de525a","modified":1623246736540},{"_id":"public/2020/02/05/刷题心得/字符串/最长无重复子串/index.html","hash":"2978866299dc73d4d73f066e737b563462cb0faf","modified":1623246736540},{"_id":"public/2020/02/05/刷题心得/栈和队列/用栈实现队列/index.html","hash":"209e1df152c7b4b49ad107bf23b8d3910413e076","modified":1623246736540},{"_id":"public/2020/02/04/面试/复盘/2.13头条面试/index.html","hash":"5a2f11166f60f15c1649f6812e26618d16cda18b","modified":1623246736540},{"_id":"public/2020/01/21/面试/大而泛/HTTP，TCP， socket，RPC 与gRPC都是啥？/index.html","hash":"1c49e8f84aea62a5660f7e5fd992d397ac65e037","modified":1582630064417},{"_id":"public/2020/01/20/应用安装&破解/python一行创建http服务器/index.html","hash":"4e11927f1ccee568b69c23906b25c02e2a7e67b8","modified":1583303045446},{"_id":"public/archives/page/5/index.html","hash":"465772ea879384622ca92249e0bbb75cd8a410bf","modified":1623246736540},{"_id":"public/archives/page/6/index.html","hash":"54c6b888250dca524c5b3dbd331b46879f4fb2b1","modified":1623246736540},{"_id":"public/archives/2020/page/3/index.html","hash":"0049398e0720b16e17dfd9e8743ec8926b63a6b9","modified":1623246736540},{"_id":"public/archives/2020/page/4/index.html","hash":"73697caf72debaab824715385cd8da3df3667506","modified":1623246736540},{"_id":"public/archives/2020/02/page/3/index.html","hash":"fa3e0bba4613e83ad1b391bf02433bbf719dc14b","modified":1623246736540},{"_id":"public/archives/2020/02/page/2/index.html","hash":"3b73666c2cdf269a0c31503a7724223855a046df","modified":1623246736540},{"_id":"public/categories/刷题心得/page/2/index.html","hash":"4d94075310cdcfde8526f8ec7fcea11617c0358e","modified":1623246736540},{"_id":"public/categories/刷题心得/page/3/index.html","hash":"d3904023c6e5eec70e230de4219f4ed27eabf4f8","modified":1623246736540},{"_id":"public/tags/算法/page/3/index.html","hash":"8ccefe72daa6e89144e0b73796b138370c285fec","modified":1623246736540},{"_id":"public/tags/算法/page/2/index.html","hash":"3d20e743db3fb3a2153493dfdd04cf362831cae9","modified":1623246736540},{"_id":"public/tags/位运算/index.html","hash":"5f5bbdf5036600e48cb440fb52949a08ccfac65f","modified":1623246736540},{"_id":"public/tags/剪枝/index.html","hash":"802c689cd8ddd3ea4a07fda338dd6f5bb4788b2c","modified":1623246736540},{"_id":"public/tags/哈希表/index.html","hash":"17edcbfcabbc1015c0f97a956812428218eba17b","modified":1623246736540},{"_id":"public/tags/树/index.html","hash":"ef52c4855c01677ab09a785060454873061be61c","modified":1623246736540},{"_id":"public/tags/二分法/index.html","hash":"733c78825e29673272aaf5669d58eec520684738","modified":1623246736540},{"_id":"public/tags/队列/index.html","hash":"45e97bd8ae05427fee9012a03c90d5d91f7a8216","modified":1623246736540},{"_id":"public/tags/递归/index.html","hash":"685da33c82808edbe2de23b8314337a2f60125d6","modified":1623246736540},{"_id":"public/tags/字符串/index.html","hash":"03dd3a26155db1b35fa6637ef103c557edc6c9a0","modified":1623246736540},{"_id":"public/tags/贪心/index.html","hash":"de685815ed4d887d88a870e95e6f18c9fa7df938","modified":1623246736540},{"_id":"public/tags/分治/index.html","hash":"22ce28bb62751876b95741eafa6ecb2452f75bd7","modified":1623246736540},{"_id":"public/tags/复盘/index.html","hash":"07f6d2ec67c387d45da8be51c36c6b2a3ade8fdc","modified":1623246736540},{"_id":"public/page/5/index.html","hash":"18ab7786821541070eb1425046a66100c0868ebf","modified":1623246736540},{"_id":"public/page/6/index.html","hash":"13108b58b15f3bb1938f039be7558f39636de496","modified":1623246736540},{"_id":"source/_posts/面试/复盘/2.27映客面试.md","hash":"5c228c9d33782d686a9e56b8d27e02cf95448b77","modified":1583204310836},{"_id":"source/_posts/面试/复盘/2.27滴滴面试.md","hash":"df312731bf90365669f5203c83c9dd6853677afc","modified":1582972277818},{"_id":"source/_posts/面试/复盘/2.28滴滴面试.md","hash":"4a79c12e9ddb26e9d06ac4f8f6d02d1c6ee7d5b6","modified":1582961305296},{"_id":"source/_posts/面试/复盘/2.26滴滴面试.md","hash":"f37ef36dfd8d880c8b5ef5bf4da4a79e91624cc6","modified":1583030985777},{"_id":"source/_posts/面试/复盘/2.29腾讯面试.md","hash":"394e6eef04eac714ddcaa8465e758bb34faedf63","modified":1583306708732},{"_id":"source/_posts/面试/复盘/2.26好未来面试.md","hash":"2e6de061c646ddf3748dde2e42f56757771c98d2","modified":1583380794942},{"_id":"source/_posts/面试/复盘/3.1头条面试.md","hash":"d89a553f2cfc9c80eace6e17eb8eb5cc43a87228","modified":1583307601005},{"_id":"source/_posts/面试/复盘/2.27知乎面试.md","hash":"b9655952adb242404a9a986deec37bb5ddc5c815","modified":1582972949530},{"_id":"source/_posts/面试/复盘/2.28百度面试.md","hash":"06bc99bb13c8f4569a19a3ac3fff4d82b02c7258","modified":1583398702351},{"_id":"source/_posts/面试/复盘/main.go","hash":"81e44ae8200f5b382e93822073bfc878327b0e31","modified":1582775287004},{"_id":"source/_posts/面试/要点整理/HTTP，TCP， socket，RPC 与gRPC都是啥？.md","hash":"4aab8028dee8c3d16e0206c2f314a69b8fbfe8f9","modified":1579600800438},{"_id":"source/_posts/面试/要点整理/linux.md","hash":"b5e1639a51b7f3843470fcbb592b387bd7656601","modified":1584948145819},{"_id":"source/_posts/面试/要点整理/数据库.md","hash":"59c21e6a3a22a5b6ea0fef588151d5d2a8c9a00a","modified":1584947855609},{"_id":"source/_posts/面试/要点整理/缓存.md","hash":"b797b1d92d851655ccdd209f5d0c5fe033bcd74f","modified":1584964037659},{"_id":"source/_posts/面试/要点整理/操作系统.md","hash":"13f7eb6b9620cc986439cb31e519b68d52ab4525","modified":1579599680283},{"_id":"source/_posts/面试/要点整理/设计模式.md","hash":"8636834acff7ab8cbc2a40ba5f721f3a99760253","modified":1579599695396},{"_id":"source/_posts/面试/要点整理/高频面试点.md","hash":"f600bbcf36f9d74deda0fe469f91f4fb2181f74e","modified":1583033791456},{"_id":"source/_posts/面试/要点整理/网络.md","hash":"7c9cc72cf8a9ef67b922919c168d5a1b26e27adf","modified":1579599646651},{"_id":"source/_posts/面试/要点整理/高并发.md","hash":"2b3303dc73865d7f7357960b25896872cf7dcc2f","modified":1579599598406},{"_id":"public/archives/page/8/index.html","hash":"2dff60240d8c7d10b034e0c80f19c747849b3011","modified":1623246736540},{"_id":"public/archives/2020/03/index.html","hash":"45463925098d5b1b544a1ad9591ad9357d769fd4","modified":1623246736540},{"_id":"public/page/8/index.html","hash":"5c62e4abce05625c92fbe6fa6c04bd0941caf7a1","modified":1623246736540},{"_id":"public/2020/03/01/面试/复盘/3.1头条面试/index.html","hash":"6026d0f2fba5f6b0a321a42923406003b6354783","modified":1623246736540},{"_id":"public/2020/03/01/面试/要点整理/高频面试点/index.html","hash":"9f7d19329c415516c62d1f1960a63c387644096c","modified":1623246736540},{"_id":"public/2020/02/28/面试/复盘/2.28百度面试/index.html","hash":"2531f121c883f60d1f753fbb94d6861c5f6b7528","modified":1623246736540},{"_id":"public/2020/02/27/面试/复盘/2.27映客面试/index.html","hash":"dfba06ea90c8b13cc80c3d6403af114b9becd3b8","modified":1623246736540},{"_id":"public/2020/02/27/面试/复盘/2.27滴滴面试/index.html","hash":"25b854eb183da7c840cc6531592f5d869995ce63","modified":1623246736540},{"_id":"public/2020/02/27/面试/复盘/2.27知乎面试/index.html","hash":"8c3064ae95a408ace9d2cd3bffff0289c94fc56a","modified":1623246736540},{"_id":"public/2020/02/29/面试/复盘/2.29腾讯面试/index.html","hash":"9c00d8903c3c8285132e9ace9974fe6f96bb742c","modified":1623246736540},{"_id":"public/2020/02/28/面试/复盘/2.28滴滴面试/index.html","hash":"8977dce5fdd59c8a71693f998166ffffe6cbdb9d","modified":1623246736540},{"_id":"public/2020/02/25/面试/复盘/2.26滴滴面试/index.html","hash":"b1271264aefc7608b29bd079d6d867b223c6ee31","modified":1623246736540},{"_id":"public/2020/02/25/面试/复盘/2.26好未来面试/index.html","hash":"d70b482b464954021c959d36bf4918c2868f48bc","modified":1623246736540},{"_id":"public/2019/11/14/面试/要点整理/设计模式/index.html","hash":"a5ab055678b84ef03efe97920244377c51d27246","modified":1623246736540},{"_id":"public/2019/11/13/面试/要点整理/操作系统/index.html","hash":"88b3808d8f15d51a12fed20144150126dc60ddfc","modified":1623246736540},{"_id":"public/2019/11/12/面试/要点整理/linux/index.html","hash":"6c25ef5e9e218e2e14eba4eb1d2d64726bc89eb7","modified":1623246736540},{"_id":"public/2019/11/08/面试/要点整理/数据库/index.html","hash":"ac6e0fdcde0bc12acae9ab8129f6c23c274672f1","modified":1623246736540},{"_id":"public/2019/11/07/面试/要点整理/高并发/index.html","hash":"bbfcec832467f3a9c87537a81c052466d9708766","modified":1583303045446},{"_id":"public/2019/11/06/面试/要点整理/网络/index.html","hash":"514896af28af67910929020e4ae49ddd2f737517","modified":1623246736540},{"_id":"public/2019/11/05/面试/要点整理/缓存/index.html","hash":"de894cccdffa704918f986c922f9e0f100486806","modified":1623246736540},{"_id":"public/2020/01/21/面试/要点整理/HTTP，TCP， socket，RPC 与gRPC都是啥？/index.html","hash":"e62ceb4fbf9119df19f3b47c129a36338fbcfc53","modified":1623246736540},{"_id":"public/categories/面试/page/3/index.html","hash":"33d91e533152c698aee153901f671bb3ba1aff84","modified":1623246736540},{"_id":"public/archives/2020/page/5/index.html","hash":"3d1597c52a6cdc226c95cd7e0a0f8d81ac3164c0","modified":1623246736540},{"_id":"public/tags/复盘/page/2/index.html","hash":"e1225a0c53a558f9bad0687ec7fb97a16839b56a","modified":1623246736540},{"_id":"source/_posts/面试/复盘/3.14腾讯面试.md","hash":"250f07f0d228c18ef1ec14f0ffd8795960755c62","modified":1584427586763},{"_id":"source/_posts/面试/复盘/3.18百度面试.md","hash":"dc107ac17f2f1ff43bbd8c691c80f878202a4df7","modified":1584509125196},{"_id":"source/_posts/面试/复盘/3.19搜狐面试.md","hash":"d060888a7fd3e0dff7a6c4d2e6d714ce48e77d4f","modified":1584931272674},{"_id":"source/_posts/面试/复盘/3.13腾讯面试.md","hash":"415016bcb4a2db809c4a779ce622bb27f59a0be6","modified":1584512408754},{"_id":"source/_posts/面试/要点整理/etcd&zookeeper.md","hash":"243329c7a7a8ccdd36daf8d4a131ce822ec7119c","modified":1584945854808},{"_id":"source/_posts/面试/要点整理/go.md","hash":"1f48ffcef60a8dcf238a1a480101081f7b2153fa","modified":1584957772467},{"_id":"source/_posts/面试/复盘/3.10腾讯面试.md","hash":"4d5c8e3262a60e2d75fd355b7c6a8a38592909d6","modified":1585047483116},{"_id":"source/_posts/面试/复盘/3.12头条面试.md","hash":"396bb30576032ca9b1ea2737e3efb7cdbfacb2ac","modified":1584427261423},{"_id":"source/_posts/面试/复盘/3.2跟谁学面试.md","hash":"69adbfac10c22868fdd36ef79bb7aa63d50f130d","modified":1583312233006},{"_id":"source/_posts/面试/要点整理/系统设计题.md","hash":"ab1091850ceb74fc6ae922d8ff79498381633559","modified":1584513936054},{"_id":"source/_posts/面试/要点整理/消息队列.md","hash":"4deb86738379b7cd21804f5f00b7ac15f62b3c9d","modified":1584510935744},{"_id":"source/_posts/面试/要点整理/精选面试题.md","hash":"cc108a52ac8c81085bac2faca3d6c88cacd521d8","modified":1579768912714},{"_id":"public/2020/03/19/面试/要点整理/go/index.html","hash":"a8766df277e7b375616c5a84ed324c7cb47d907d","modified":1623246736540},{"_id":"public/2020/03/17/面试/要点整理/消息队列/index.html","hash":"0422a12f75a89fac90671a3ee558465e37f11a61","modified":1623246736540},{"_id":"public/2020/03/23/面试/要点整理/etcd&zookeeper/index.html","hash":"dffc4bd03d85fa01746ecc9d68d22604362daa28","modified":1623246736540},{"_id":"public/2020/03/13/面试/复盘/3.13腾讯面试/index.html","hash":"821a7d6a51f167a3337de75740bb053fd51d498d","modified":1623246736540},{"_id":"public/2020/03/10/面试/复盘/3.10腾讯面试/index.html","hash":"ce833d86de5c64b546825e77853c63340736b285","modified":1623246736540},{"_id":"public/2020/03/14/面试/复盘/3.14腾讯面试/index.html","hash":"fadab7d93f6a67e5802786fa8d1c5850f6233296","modified":1623246736540},{"_id":"public/2020/03/12/面试/复盘/3.12头条面试/index.html","hash":"a7711fc6a0392856490ff0f134378afcfd235ea6","modified":1623246736540},{"_id":"public/2020/03/02/面试/复盘/3.2跟谁学面试/index.html","hash":"47d2aa7ddb11dfe108c75c4dbf9c671852eb842e","modified":1623246736540},{"_id":"public/2020/03/01/面试/复盘/3.18百度面试/index.html","hash":"f059cc139612d3931eb7f3df2417d2aef1b478aa","modified":1623246736540},{"_id":"public/2020/03/01/面试/复盘/3.19搜狐面试/index.html","hash":"cbd5918213aa94d5d8bb778ff1fd909e0997c505","modified":1623246736540},{"_id":"public/archives/2020/03/page/2/index.html","hash":"21289e62dcbfb34034be1b179a5d2ed20b1c4365","modified":1623246736540},{"_id":"public/2019/11/13/面试/要点整理/系统设计题/index.html","hash":"1ffb396fc41bcf68caabc6e542af90e37b639afb","modified":1623246736540},{"_id":"public/2019/02/20/面试/要点整理/精选面试题/index.html","hash":"c1f55e352bd868e13003e2f5a43c1c43a0ab6482","modified":1623246736540},{"_id":"public/archives/2020/page/6/index.html","hash":"4b267b9dad78fc91072e290439727ba4b68f8ace","modified":1623246736540},{"_id":"public/tags/复盘/page/3/index.html","hash":"8c41cf182f1a2ebfe88abfe9172272a1bbef59bc","modified":1623246736540},{"_id":"public/tags/golang/index.html","hash":"5d8bd3c7aa275168759503b237d6ef679844a39f","modified":1623246736540},{"_id":"public/categories/面试/page/4/index.html","hash":"53990fec40f152fbd6622d743dcb35ff28a4c93d","modified":1623246736540},{"_id":"source/_posts/商业/行业调研步骤.md","hash":"807741e2719cd479630f268a3564a2305d57c602","modified":1605985299677},{"_id":"source/_posts/股票/股票初级.md","hash":"27c0084ae729621c172837b060c82624c23c4dd3","modified":1594839885341},{"_id":"source/_posts/黑科技/hexo.md","hash":"3d9a4731f508a4488577a7460ca2ba21fd786cb8","modified":1594839885532},{"_id":"source/_posts/黑科技/python一行创建http服务器.md","hash":"490594cff6bd0734b8e2ea2977e83fac099393e4","modified":1594839885530},{"_id":"source/_posts/面试/复盘/4.27其他面试.md","hash":"c241380c4604bae389ce8a0fcb6e189faf461fcb","modified":1587721753576},{"_id":"public/archives/page/9/index.html","hash":"04aa3170e7725d19007ff10f72873cfaaf8b52a6","modified":1623246736540},{"_id":"public/archives/2020/04/index.html","hash":"5a762ea8b16b91cfaeb28ff2d308b1912a79ef35","modified":1623246736540},{"_id":"public/archives/2020/07/index.html","hash":"70ac91f0c995c7e591e3a9e98b3e50b84092b3de","modified":1623246736540},{"_id":"public/archives/2020/11/index.html","hash":"bfa3d560d13935fd6125b8b8d9f46f0198924c25","modified":1623246736540},{"_id":"public/page/9/index.html","hash":"39213657552bf5e96189f37542b3ce4ea2599ccc","modified":1623246736540},{"_id":"public/2020/11/22/商业/行业调研步骤/index.html","hash":"3850bc1181bd2ff11aaf4fe615d03fce27fe2fd1","modified":1623246736540},{"_id":"public/2020/07/16/股票/股票初级/index.html","hash":"1618abac33bc5b83d784fc859e1de06df79ce46c","modified":1623246736540},{"_id":"public/2020/04/24/面试/复盘/4.27其他面试/index.html","hash":"ed8b3b590a25846b75086a350ce86412f6ff5eec","modified":1623246736540},{"_id":"public/2020/01/20/黑科技/hexo/index.html","hash":"350d53c898410546f0f86d20a6526052b7846689","modified":1623246736540},{"_id":"public/2020/01/20/黑科技/python一行创建http服务器/index.html","hash":"6c12337099e7d87004f0bc278c5e0694f689413e","modified":1623246736540}],"Category":[{"name":"花里胡哨的操作","_id":"ck5naxyet0001fn8n41lb7izl"},{"name":"应用安装&破解","_id":"ck5nh0lh30001lm8n9249aid1"},{"name":"极客操作","_id":"ck5nh0lh80007lm8nbr7s579v"},{"name":"常见问题","_id":"ck5nh0lh9000alm8n07qi8iik"},{"name":"面试","_id":"ck5nll6p60002yr8nfnh3c7i5"},{"name":"刷题心得","_id":"ck68nkriy0001ou8ne42pe2sm"}],"Data":[],"Page":[{"title":"categories","date":"2020-01-20T07:38:34.000Z","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-01-20 15:38:34\nlayout: categories\ncomments: false\n---\n","updated":"2020-01-20T07:39:01.704Z","path":"categories/index.html","_id":"ck5m5sa2f0000a98nadia6422","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-01-20T07:37:53.000Z","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-01-20 15:37:53\nlayout: tags\ncomments: false\n---\n","updated":"2020-01-20T07:38:23.127Z","path":"tags/index.html","_id":"ck5m5sa2j0001a98n47186pl1","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"【常见问题】nginx搭建的服务器 报No input file specified错","date":"2020-01-21T06:51:25.000Z","_content":"\n\n\n>  nginx搭建的服务器 报No input file specified错\n\n<!-- more -->\n\n我把php-fpm重启下就能访问了  然后没过多久又抱No input file specified错\n\nphp-fpm在重启下又可以正常访问了 \n\n您的服务器不支持 PATH_INFO;\n\n在php.ini文件里面修改：\n\n  1、增加一行（这个最重要）\n\n​    fastcgi.impersonate = 1\n\n  2、修改两项（解开注释就可以了）\n\n​    cgi.fix_pathinfo=1\n​    cgi.force_redirect = 0","source":"_posts/常见问题/No input file specified.md","raw":"---\ntitle: 【常见问题】nginx搭建的服务器 报No input file specified错\ndate: 2020-01-21 14:51:25\ntags:\n- php\n- 服务器\ncategories:\n- 常见问题\n---\n\n\n\n>  nginx搭建的服务器 报No input file specified错\n\n<!-- more -->\n\n我把php-fpm重启下就能访问了  然后没过多久又抱No input file specified错\n\nphp-fpm在重启下又可以正常访问了 \n\n您的服务器不支持 PATH_INFO;\n\n在php.ini文件里面修改：\n\n  1、增加一行（这个最重要）\n\n​    fastcgi.impersonate = 1\n\n  2、修改两项（解开注释就可以了）\n\n​    cgi.fix_pathinfo=1\n​    cgi.force_redirect = 0","slug":"常见问题/No input file specified","published":1,"updated":"2020-01-21T09:36:42.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5novm9l00006d8n7mli58r2","content":"<blockquote>\n<p> nginx搭建的服务器 报No input file specified错</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p>我把php-fpm重启下就能访问了  然后没过多久又抱No input file specified错</p>\n<p>php-fpm在重启下又可以正常访问了 </p>\n<p>您的服务器不支持 PATH_INFO;</p>\n<p>在php.ini文件里面修改：</p>\n<p>  1、增加一行（这个最重要）</p>\n<p>​    fastcgi.impersonate = 1</p>\n<p>  2、修改两项（解开注释就可以了）</p>\n<p>​    cgi.fix_pathinfo=1<br>​    cgi.force_redirect = 0</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p> nginx搭建的服务器 报No input file specified错</p>\n</blockquote>","more":"<p>我把php-fpm重启下就能访问了  然后没过多久又抱No input file specified错</p>\n<p>php-fpm在重启下又可以正常访问了 </p>\n<p>您的服务器不支持 PATH_INFO;</p>\n<p>在php.ini文件里面修改：</p>\n<p>  1、增加一行（这个最重要）</p>\n<p>​    fastcgi.impersonate = 1</p>\n<p>  2、修改两项（解开注释就可以了）</p>\n<p>​    cgi.fix_pathinfo=1<br>​    cgi.force_redirect = 0</p>"},{"title":"【常见问题】wine下的应用无法输入中文，解决办法","date":"2019-07-21T06:51:25.000Z","_content":"\n> 因为工作环境是linux，免不了用wine装微信等工具，但是支持不了中文，因此进行一下调研\n\n<!-- more -->\n\n我用的搜狗输入法，属于fcitx框架。桌面是gnome3。\n\n解决方法：\n\n1、尝试设置环境变量\n\nexport GTK_IM_MODULE=fcitx \nexport QT_IM_MODULE=fcitx \nexport XMODIFIERS=\"@im=fcitx\" \n设置完后，尝试在当前终端下，用wine启动程序试试，如果可以就是环境变量的问题\n\n2、尝试以下命令\n\ngsettings set org.gnome.settings-daemon.plugins.keyboard active false \n3、以上都不好使的情况下，放大招（偶然发现，我就是这么搞定的）\n\n 用wine打开程序后，发现不能正确切换到输入法，此时请重启fcitx服务，重启后，意外发现wine打开的程序中可以使用输入法了。而且执行一次后，后续用wine启动其他应用，都可以正常输入，好神奇。","source":"_posts/常见问题/wine应用无法输入中文.md","raw":"---\ntitle: 【常见问题】wine下的应用无法输入中文，解决办法\ndate: 2019-07-21 14:51:25\ntags:\n- php\n- 服务器\ncategories:\n- 常见问题\n---\n\n> 因为工作环境是linux，免不了用wine装微信等工具，但是支持不了中文，因此进行一下调研\n\n<!-- more -->\n\n我用的搜狗输入法，属于fcitx框架。桌面是gnome3。\n\n解决方法：\n\n1、尝试设置环境变量\n\nexport GTK_IM_MODULE=fcitx \nexport QT_IM_MODULE=fcitx \nexport XMODIFIERS=\"@im=fcitx\" \n设置完后，尝试在当前终端下，用wine启动程序试试，如果可以就是环境变量的问题\n\n2、尝试以下命令\n\ngsettings set org.gnome.settings-daemon.plugins.keyboard active false \n3、以上都不好使的情况下，放大招（偶然发现，我就是这么搞定的）\n\n 用wine打开程序后，发现不能正确切换到输入法，此时请重启fcitx服务，重启后，意外发现wine打开的程序中可以使用输入法了。而且执行一次后，后续用wine启动其他应用，都可以正常输入，好神奇。","slug":"常见问题/wine应用无法输入中文","published":1,"updated":"2020-01-21T09:36:48.644Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5novm9o00016d8nb3vafdn9","content":"<blockquote>\n<p>因为工作环境是linux，免不了用wine装微信等工具，但是支持不了中文，因此进行一下调研</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p>我用的搜狗输入法，属于fcitx框架。桌面是gnome3。</p>\n<p>解决方法：</p>\n<p>1、尝试设置环境变量</p>\n<p>export GTK_IM_MODULE=fcitx<br>export QT_IM_MODULE=fcitx<br>export XMODIFIERS=”@im=fcitx”<br>设置完后，尝试在当前终端下，用wine启动程序试试，如果可以就是环境变量的问题</p>\n<p>2、尝试以下命令</p>\n<p>gsettings set org.gnome.settings-daemon.plugins.keyboard active false<br>3、以上都不好使的情况下，放大招（偶然发现，我就是这么搞定的）</p>\n<p> 用wine打开程序后，发现不能正确切换到输入法，此时请重启fcitx服务，重启后，意外发现wine打开的程序中可以使用输入法了。而且执行一次后，后续用wine启动其他应用，都可以正常输入，好神奇。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>因为工作环境是linux，免不了用wine装微信等工具，但是支持不了中文，因此进行一下调研</p>\n</blockquote>","more":"<p>我用的搜狗输入法，属于fcitx框架。桌面是gnome3。</p>\n<p>解决方法：</p>\n<p>1、尝试设置环境变量</p>\n<p>export GTK_IM_MODULE=fcitx<br>export QT_IM_MODULE=fcitx<br>export XMODIFIERS=”@im=fcitx”<br>设置完后，尝试在当前终端下，用wine启动程序试试，如果可以就是环境变量的问题</p>\n<p>2、尝试以下命令</p>\n<p>gsettings set org.gnome.settings-daemon.plugins.keyboard active false<br>3、以上都不好使的情况下，放大招（偶然发现，我就是这么搞定的）</p>\n<p> 用wine打开程序后，发现不能正确切换到输入法，此时请重启fcitx服务，重启后，意外发现wine打开的程序中可以使用输入法了。而且执行一次后，后续用wine启动其他应用，都可以正常输入，好神奇。</p>"},{"title":"Ubuntu Navicat for MySQL安装以及破解方案","date":"2018-07-17T16:00:00.000Z","_content":"\n\n\n今天安装了Navicat for MySQL有LINUX版本了哈， 开心的说，\n\n<!-- more -->\n\n首先上官网上下载LINUX版本： [http://www.navicat.com/download/navicat-for-mysql](http://www.navicat.com/download)\n\n1. 下载 navicat110_mysql_en.tar.gz 文件 \n\n2. 下载后解压tar文件\n\n``` bash\ntar -zxvf /home/rain/download/navicat8_mysql_en.tar.gz \n```\n\n\n\n3. 解压后 进入解压后的目录运行命令：\n\n```bash\n./start_navicat  \n```\n\n\n\nOK，这样就完啦\n\n连接上[数据库](http://lib.csdn.net/base/mysql)后里面的中文数据是乱码,把Ubuntu的字符集修改为zh_CN.utf8就行了,修改方法:\n\n1.查看系统支持的字符集: locale -a \n\n2,修改字符集: export LANG=zh_CN.utf8 \n\n**破解方案：**\n\n第一次执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。\n\ncd /home/rain/.navicat/ \n\n此文件夹下有一个system.reg文件\n\nrm system.reg\n\n把此文件删除后，下次启动navicat 会重新生成此文件，30天试用期会按新的时间开始计算。\n\n\n\n**问题：** \n**[Linux](http://lib.csdn.net/base/linux)下MySQL workbench连接[数据库](http://lib.csdn.net/base/mysql)，表中数据不乱码，但是我下载安装类Navicat for mysql 64位 英文版，其中显示的中文数据乱码**\n\n解决步骤： \n1、下载好navicat112_mysql_en_x64.tar.gz压缩文件，解压出文件，我用的命令是 tar xvf navicat112_mysql_en_x64.tar.gz \n2、我连接上mysql数据库，其中表中字段有中文全部乱码，打开navicat112_mysql_en_x64.tar.gz解压的目录，用文本编辑器方式打开start_navicat会看到 export LANG=”en_US.UTF-8”，改为export LANG=”zh_CN.UTF-8”，然后保存。 \n3、打开navicat，新建连接，对连接进行 Edit Connection ，Advanced 其中到Encoding  我选择的是Auto\n\n4、保存之后，打开数据库表中数据中文数据显示正常。","source":"_posts/常见问题/ubuntu安装navicat.md","raw":"---\ntitle: Ubuntu Navicat for MySQL安装以及破解方案\ndate: 2018-7-18\ntags:\n- mysql\n- 应用安装\ncategories:\n- 常见问题\n---\n\n\n\n今天安装了Navicat for MySQL有LINUX版本了哈， 开心的说，\n\n<!-- more -->\n\n首先上官网上下载LINUX版本： [http://www.navicat.com/download/navicat-for-mysql](http://www.navicat.com/download)\n\n1. 下载 navicat110_mysql_en.tar.gz 文件 \n\n2. 下载后解压tar文件\n\n``` bash\ntar -zxvf /home/rain/download/navicat8_mysql_en.tar.gz \n```\n\n\n\n3. 解压后 进入解压后的目录运行命令：\n\n```bash\n./start_navicat  \n```\n\n\n\nOK，这样就完啦\n\n连接上[数据库](http://lib.csdn.net/base/mysql)后里面的中文数据是乱码,把Ubuntu的字符集修改为zh_CN.utf8就行了,修改方法:\n\n1.查看系统支持的字符集: locale -a \n\n2,修改字符集: export LANG=zh_CN.utf8 \n\n**破解方案：**\n\n第一次执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。\n\ncd /home/rain/.navicat/ \n\n此文件夹下有一个system.reg文件\n\nrm system.reg\n\n把此文件删除后，下次启动navicat 会重新生成此文件，30天试用期会按新的时间开始计算。\n\n\n\n**问题：** \n**[Linux](http://lib.csdn.net/base/linux)下MySQL workbench连接[数据库](http://lib.csdn.net/base/mysql)，表中数据不乱码，但是我下载安装类Navicat for mysql 64位 英文版，其中显示的中文数据乱码**\n\n解决步骤： \n1、下载好navicat112_mysql_en_x64.tar.gz压缩文件，解压出文件，我用的命令是 tar xvf navicat112_mysql_en_x64.tar.gz \n2、我连接上mysql数据库，其中表中字段有中文全部乱码，打开navicat112_mysql_en_x64.tar.gz解压的目录，用文本编辑器方式打开start_navicat会看到 export LANG=”en_US.UTF-8”，改为export LANG=”zh_CN.UTF-8”，然后保存。 \n3、打开navicat，新建连接，对连接进行 Edit Connection ，Advanced 其中到Encoding  我选择的是Auto\n\n4、保存之后，打开数据库表中数据中文数据显示正常。","slug":"常见问题/ubuntu安装navicat","published":1,"updated":"2020-01-23T09:03:31.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b7h00003v8n3gbo3kdj","content":"<p>今天安装了Navicat for MySQL有LINUX版本了哈， 开心的说，</p>\n<a id=\"more\"></a>\n\n<p>首先上官网上下载LINUX版本： <a href=\"http://www.navicat.com/download\" target=\"_blank\" rel=\"noopener\">http://www.navicat.com/download/navicat-for-mysql</a></p>\n<ol>\n<li><p>下载 navicat110_mysql_en.tar.gz 文件 </p>\n</li>\n<li><p>下载后解压tar文件</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf /home/rain/download/navicat8_mysql_en.tar.gz</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li>解压后 进入解压后的目录运行命令：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./start_navicat</span><br></pre></td></tr></table></figure>\n\n\n\n<p>OK，这样就完啦</p>\n<p>连接上<a href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\" rel=\"noopener\">数据库</a>后里面的中文数据是乱码,把Ubuntu的字符集修改为zh_CN.utf8就行了,修改方法:</p>\n<p>1.查看系统支持的字符集: locale -a </p>\n<p>2,修改字符集: export LANG=zh_CN.utf8 </p>\n<p><strong>破解方案：</strong></p>\n<p>第一次执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。</p>\n<p>cd /home/rain/.navicat/ </p>\n<p>此文件夹下有一个system.reg文件</p>\n<p>rm system.reg</p>\n<p>把此文件删除后，下次启动navicat 会重新生成此文件，30天试用期会按新的时间开始计算。</p>\n<p><strong>问题：</strong><br><strong><a href=\"http://lib.csdn.net/base/linux\" target=\"_blank\" rel=\"noopener\">Linux</a>下MySQL workbench连接<a href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\" rel=\"noopener\">数据库</a>，表中数据不乱码，但是我下载安装类Navicat for mysql 64位 英文版，其中显示的中文数据乱码</strong></p>\n<p>解决步骤：<br>1、下载好navicat112_mysql_en_x64.tar.gz压缩文件，解压出文件，我用的命令是 tar xvf navicat112_mysql_en_x64.tar.gz<br>2、我连接上mysql数据库，其中表中字段有中文全部乱码，打开navicat112_mysql_en_x64.tar.gz解压的目录，用文本编辑器方式打开start_navicat会看到 export LANG=”en_US.UTF-8”，改为export LANG=”zh_CN.UTF-8”，然后保存。<br>3、打开navicat，新建连接，对连接进行 Edit Connection ，Advanced 其中到Encoding  我选择的是Auto</p>\n<p>4、保存之后，打开数据库表中数据中文数据显示正常。</p>\n","site":{"data":{}},"excerpt":"<p>今天安装了Navicat for MySQL有LINUX版本了哈， 开心的说，</p>","more":"<p>首先上官网上下载LINUX版本： <a href=\"http://www.navicat.com/download\" target=\"_blank\" rel=\"noopener\">http://www.navicat.com/download/navicat-for-mysql</a></p>\n<ol>\n<li><p>下载 navicat110_mysql_en.tar.gz 文件 </p>\n</li>\n<li><p>下载后解压tar文件</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf /home/rain/download/navicat8_mysql_en.tar.gz</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li>解压后 进入解压后的目录运行命令：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./start_navicat</span><br></pre></td></tr></table></figure>\n\n\n\n<p>OK，这样就完啦</p>\n<p>连接上<a href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\" rel=\"noopener\">数据库</a>后里面的中文数据是乱码,把Ubuntu的字符集修改为zh_CN.utf8就行了,修改方法:</p>\n<p>1.查看系统支持的字符集: locale -a </p>\n<p>2,修改字符集: export LANG=zh_CN.utf8 </p>\n<p><strong>破解方案：</strong></p>\n<p>第一次执行start_navicat时，会在用户主目录下生成一个名为.navicat的隐藏文件夹。</p>\n<p>cd /home/rain/.navicat/ </p>\n<p>此文件夹下有一个system.reg文件</p>\n<p>rm system.reg</p>\n<p>把此文件删除后，下次启动navicat 会重新生成此文件，30天试用期会按新的时间开始计算。</p>\n<p><strong>问题：</strong><br><strong><a href=\"http://lib.csdn.net/base/linux\" target=\"_blank\" rel=\"noopener\">Linux</a>下MySQL workbench连接<a href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\" rel=\"noopener\">数据库</a>，表中数据不乱码，但是我下载安装类Navicat for mysql 64位 英文版，其中显示的中文数据乱码</strong></p>\n<p>解决步骤：<br>1、下载好navicat112_mysql_en_x64.tar.gz压缩文件，解压出文件，我用的命令是 tar xvf navicat112_mysql_en_x64.tar.gz<br>2、我连接上mysql数据库，其中表中字段有中文全部乱码，打开navicat112_mysql_en_x64.tar.gz解压的目录，用文本编辑器方式打开start_navicat会看到 export LANG=”en_US.UTF-8”，改为export LANG=”zh_CN.UTF-8”，然后保存。<br>3、打开navicat，新建连接，对连接进行 Edit Connection ，Advanced 其中到Encoding  我选择的是Auto</p>\n<p>4、保存之后，打开数据库表中数据中文数据显示正常。</p>"},{"title":"【常见问题】Ubuntu下利用deepin-wine安装软件简要方案","date":"2018-07-12T06:51:25.000Z","_content":"\n> 一直以来，Linux作为开发机比较给力，但是常用软件(如QQ、微信等)的缺乏使Linux在桌面端一直不火，用户量低于Windows以及macOS，今天分享一个Ubuntu下安装常用软件的方法。\n\n<!-- more -->\n\n### 博主电脑环境\n\n- Ubuntu 18.10 x64\n\n### 教程\n\n#### 安装deepin-wine\n\n输入以下命令即可\n\n复制\n\n| `123` | `git clone https://github.com/wszqkzqk/deepin-wine-ubuntu.gitcd deepin-wine-ubuntu./install` |\n| ----- | ------------------------------------------------------------ |\n|       |                                                              |\n\n#### 安装软件\n\n- 下载软件(GUI下载或wget等均可)\n  http://mirrors.aliyun.com/deepin/pool/non-free/\n\n- 使用如下命令安装软件\n\n  复制\n\n  | `1`  | `sudo dpkg -i xxx.deb` |\n  | ---- | ---------------------- |\n  |      |                        |\n\n> 目前博主已经成功安装Tim、微信、百度网盘、迅雷精简版、foobar2000等。\n\n或者： https://github.com/hillwoodroc/winetricks-zh","source":"_posts/常见问题/ubuntu安装wine应用.md","raw":"---\ntitle: 【常见问题】Ubuntu下利用deepin-wine安装软件简要方案\ndate: 2018-07-12 14:51:25\ntags:\n- wine\n- linux\ncategories:\n- 常见问题\n---\n\n> 一直以来，Linux作为开发机比较给力，但是常用软件(如QQ、微信等)的缺乏使Linux在桌面端一直不火，用户量低于Windows以及macOS，今天分享一个Ubuntu下安装常用软件的方法。\n\n<!-- more -->\n\n### 博主电脑环境\n\n- Ubuntu 18.10 x64\n\n### 教程\n\n#### 安装deepin-wine\n\n输入以下命令即可\n\n复制\n\n| `123` | `git clone https://github.com/wszqkzqk/deepin-wine-ubuntu.gitcd deepin-wine-ubuntu./install` |\n| ----- | ------------------------------------------------------------ |\n|       |                                                              |\n\n#### 安装软件\n\n- 下载软件(GUI下载或wget等均可)\n  http://mirrors.aliyun.com/deepin/pool/non-free/\n\n- 使用如下命令安装软件\n\n  复制\n\n  | `1`  | `sudo dpkg -i xxx.deb` |\n  | ---- | ---------------------- |\n  |      |                        |\n\n> 目前博主已经成功安装Tim、微信、百度网盘、迅雷精简版、foobar2000等。\n\n或者： https://github.com/hillwoodroc/winetricks-zh","slug":"常见问题/ubuntu安装wine应用","published":1,"updated":"2020-01-23T09:36:55.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b7k00013v8n7maydkok","content":"<blockquote>\n<p>一直以来，Linux作为开发机比较给力，但是常用软件(如QQ、微信等)的缺乏使Linux在桌面端一直不火，用户量低于Windows以及macOS，今天分享一个Ubuntu下安装常用软件的方法。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"博主电脑环境\"><a href=\"#博主电脑环境\" class=\"headerlink\" title=\"博主电脑环境\"></a>博主电脑环境</h3><ul>\n<li>Ubuntu 18.10 x64</li>\n</ul>\n<h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><h4 id=\"安装deepin-wine\"><a href=\"#安装deepin-wine\" class=\"headerlink\" title=\"安装deepin-wine\"></a>安装deepin-wine</h4><p>输入以下命令即可</p>\n<p>复制</p>\n<table>\n<thead>\n<tr>\n<th><code>123</code></th>\n<th><code>git clone https://github.com/wszqkzqk/deepin-wine-ubuntu.gitcd deepin-wine-ubuntu./install</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h4><ul>\n<li><p>下载软件(GUI下载或wget等均可)<br><a href=\"http://mirrors.aliyun.com/deepin/pool/non-free/\" target=\"_blank\" rel=\"noopener\">http://mirrors.aliyun.com/deepin/pool/non-free/</a></p>\n</li>\n<li><p>使用如下命令安装软件</p>\n<p>复制</p>\n<table>\n<thead>\n<tr>\n<th><code>1</code></th>\n<th><code>sudo dpkg -i xxx.deb</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<blockquote>\n<p>目前博主已经成功安装Tim、微信、百度网盘、迅雷精简版、foobar2000等。</p>\n</blockquote>\n<p>或者： <a href=\"https://github.com/hillwoodroc/winetricks-zh\" target=\"_blank\" rel=\"noopener\">https://github.com/hillwoodroc/winetricks-zh</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>一直以来，Linux作为开发机比较给力，但是常用软件(如QQ、微信等)的缺乏使Linux在桌面端一直不火，用户量低于Windows以及macOS，今天分享一个Ubuntu下安装常用软件的方法。</p>\n</blockquote>","more":"<h3 id=\"博主电脑环境\"><a href=\"#博主电脑环境\" class=\"headerlink\" title=\"博主电脑环境\"></a>博主电脑环境</h3><ul>\n<li>Ubuntu 18.10 x64</li>\n</ul>\n<h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><h4 id=\"安装deepin-wine\"><a href=\"#安装deepin-wine\" class=\"headerlink\" title=\"安装deepin-wine\"></a>安装deepin-wine</h4><p>输入以下命令即可</p>\n<p>复制</p>\n<table>\n<thead>\n<tr>\n<th><code>123</code></th>\n<th><code>git clone https://github.com/wszqkzqk/deepin-wine-ubuntu.gitcd deepin-wine-ubuntu./install</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"安装软件\"><a href=\"#安装软件\" class=\"headerlink\" title=\"安装软件\"></a>安装软件</h4><ul>\n<li><p>下载软件(GUI下载或wget等均可)<br><a href=\"http://mirrors.aliyun.com/deepin/pool/non-free/\" target=\"_blank\" rel=\"noopener\">http://mirrors.aliyun.com/deepin/pool/non-free/</a></p>\n</li>\n<li><p>使用如下命令安装软件</p>\n<p>复制</p>\n<table>\n<thead>\n<tr>\n<th><code>1</code></th>\n<th><code>sudo dpkg -i xxx.deb</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<blockquote>\n<p>目前博主已经成功安装Tim、微信、百度网盘、迅雷精简版、foobar2000等。</p>\n</blockquote>\n<p>或者： <a href=\"https://github.com/hillwoodroc/winetricks-zh\" target=\"_blank\" rel=\"noopener\">https://github.com/hillwoodroc/winetricks-zh</a></p>"},{"title":"【常见问题】hexo","date":"2020-01-21T06:51:25.000Z","_content":"\n`由于刚刚开始使用hexo，对很多操作都不是很理解，因此，进行了一些调研，调研结果如下，包括摘要，标签等等方式`\n\n### 如何设置文章摘要\n\n在 Markdown 中加 ``\n\n### 文章如何添加多个标签\n\n有两种多标签格式\n\n```\ntags: [a, b, c]\n```\n\n或\n\n```\ntags: \n  - a\n  - b\n  - c\n```\n\n## 修改 brand 图片（菜单上方背景图）\n\n替换 `themes\\indigo\\source\\img\\brand.jpg`，保持原文件名不变。\n\n### 如何在文章中使用图标\n\n先到 [fontawesome](http://fontawesome.io/icons/) 找到你需要的图标名，比如：`book`，按以下格式使用：\n\n```\n<i class=\"icon icon-book\"></i>\n```\n\n图标样式前缀均为 `icon`，此外还有 5 个图标大小调节类和 1 个间距类。\n\n```\n<!-- 1.3倍大小 -->\n<i class=\"icon icon-book icon-lg\"></i>\n<!-- 2倍大小 -->\n<i class=\"icon icon-book icon-2x\"></i>\n<!-- 3倍大小 -->\n<i class=\"icon icon-book icon-3x\"></i>\n<!-- 4倍大小 -->\n<i class=\"icon icon-book icon-4x\"></i>\n<!-- 5倍大小 -->\n<i class=\"icon icon-book icon-5x\"></i>\n<!-- 5px右边距 -->\n<i class=\"icon icon-book icon-pr\"></i>\n<!-- 5px左边距 -->\n<i class=\"icon icon-book icon-pl\"></i>\n```\n\n## 个别图标无法显示\n\n如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。\n\n解决办法：可配置 ADBlock 不在你的站点运行。\n\n## 生成站点后没有样式\n\n[安装less](https://github.com/yscoder/hexo-theme-indigo/wiki/安装)\n\n## 更改样式后网站没有生效\n\n确认非缓存问题后，执行 `hexo clean` 再进行生成上传。\n\n## 更改站点配色\n\n编辑 `themes\\indigo\\source\\css\\_partial\\variable.less`，更改对应的颜色变量。\n\n配色参考：[Material Design Color Palette Generator](http://www.materialpalette.com/)\n\n> 注意：使用自定义配色时需把主题配置中的 cdn 关闭，`cdn: false`。\n\n## 添加404页面\n\n在 `hexo/source` 目录内新建 `404.html`。\n\n设置元数据信息，如果不想套用主题布局可设置 `layout` 为 `false`。\n\n```\nlayout: false    \ntitle: \"My Blog Name | 404\"\n---\n```\n\n## 在博客中使用 Emoji\n\n参考 [Can i use emoji in mypage?](https://github.com/yscoder/hexo-theme-indigo/issues/90)\n\n## 自行修改样式线上不生效\n\n因为主题默认引用 cdn 样式，只有主题更新时，cdn 中的样式才会变化。 如果想使用自己修改的样式，需要把修改配置中的 `cdn: false`。这样就不在引用 cdn 资源，使用本地资源了。","source":"_posts/常见问题/hexo常见问题.md","raw":"---\ntitle: 【常见问题】hexo\ndate: 2020-01-21 14:51:25\ntags:\n- hexo\ncategories:\n- 常见问题\n---\n\n`由于刚刚开始使用hexo，对很多操作都不是很理解，因此，进行了一些调研，调研结果如下，包括摘要，标签等等方式`\n\n### 如何设置文章摘要\n\n在 Markdown 中加 ``\n\n### 文章如何添加多个标签\n\n有两种多标签格式\n\n```\ntags: [a, b, c]\n```\n\n或\n\n```\ntags: \n  - a\n  - b\n  - c\n```\n\n## 修改 brand 图片（菜单上方背景图）\n\n替换 `themes\\indigo\\source\\img\\brand.jpg`，保持原文件名不变。\n\n### 如何在文章中使用图标\n\n先到 [fontawesome](http://fontawesome.io/icons/) 找到你需要的图标名，比如：`book`，按以下格式使用：\n\n```\n<i class=\"icon icon-book\"></i>\n```\n\n图标样式前缀均为 `icon`，此外还有 5 个图标大小调节类和 1 个间距类。\n\n```\n<!-- 1.3倍大小 -->\n<i class=\"icon icon-book icon-lg\"></i>\n<!-- 2倍大小 -->\n<i class=\"icon icon-book icon-2x\"></i>\n<!-- 3倍大小 -->\n<i class=\"icon icon-book icon-3x\"></i>\n<!-- 4倍大小 -->\n<i class=\"icon icon-book icon-4x\"></i>\n<!-- 5倍大小 -->\n<i class=\"icon icon-book icon-5x\"></i>\n<!-- 5px右边距 -->\n<i class=\"icon icon-book icon-pr\"></i>\n<!-- 5px左边距 -->\n<i class=\"icon icon-book icon-pl\"></i>\n```\n\n## 个别图标无法显示\n\n如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。\n\n解决办法：可配置 ADBlock 不在你的站点运行。\n\n## 生成站点后没有样式\n\n[安装less](https://github.com/yscoder/hexo-theme-indigo/wiki/安装)\n\n## 更改样式后网站没有生效\n\n确认非缓存问题后，执行 `hexo clean` 再进行生成上传。\n\n## 更改站点配色\n\n编辑 `themes\\indigo\\source\\css\\_partial\\variable.less`，更改对应的颜色变量。\n\n配色参考：[Material Design Color Palette Generator](http://www.materialpalette.com/)\n\n> 注意：使用自定义配色时需把主题配置中的 cdn 关闭，`cdn: false`。\n\n## 添加404页面\n\n在 `hexo/source` 目录内新建 `404.html`。\n\n设置元数据信息，如果不想套用主题布局可设置 `layout` 为 `false`。\n\n```\nlayout: false    \ntitle: \"My Blog Name | 404\"\n---\n```\n\n## 在博客中使用 Emoji\n\n参考 [Can i use emoji in mypage?](https://github.com/yscoder/hexo-theme-indigo/issues/90)\n\n## 自行修改样式线上不生效\n\n因为主题默认引用 cdn 样式，只有主题更新时，cdn 中的样式才会变化。 如果想使用自己修改的样式，需要把修改配置中的 `cdn: false`。这样就不在引用 cdn 资源，使用本地资源了。","slug":"常见问题/hexo常见问题","published":1,"updated":"2020-01-21T09:46:30.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b7o00033v8ng2vrcszt","content":"<p><code>由于刚刚开始使用hexo，对很多操作都不是很理解，因此，进行了一些调研，调研结果如下，包括摘要，标签等等方式</code></p>\n<h3 id=\"如何设置文章摘要\"><a href=\"#如何设置文章摘要\" class=\"headerlink\" title=\"如何设置文章摘要\"></a>如何设置文章摘要</h3><p>在 Markdown 中加 ``</p>\n<h3 id=\"文章如何添加多个标签\"><a href=\"#文章如何添加多个标签\" class=\"headerlink\" title=\"文章如何添加多个标签\"></a>文章如何添加多个标签</h3><p>有两种多标签格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tags: [a, b, c]</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tags: </span><br><span class=\"line\">  - a</span><br><span class=\"line\">  - b</span><br><span class=\"line\">  - c</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"修改-brand-图片（菜单上方背景图）\"><a href=\"#修改-brand-图片（菜单上方背景图）\" class=\"headerlink\" title=\"修改 brand 图片（菜单上方背景图）\"></a>修改 brand 图片（菜单上方背景图）</h2><p>替换 <code>themes\\indigo\\source\\img\\brand.jpg</code>，保持原文件名不变。</p>\n<h3 id=\"如何在文章中使用图标\"><a href=\"#如何在文章中使用图标\" class=\"headerlink\" title=\"如何在文章中使用图标\"></a>如何在文章中使用图标</h3><p>先到 <a href=\"http://fontawesome.io/icons/\" target=\"_blank\" rel=\"noopener\">fontawesome</a> 找到你需要的图标名，比如：<code>book</code>，按以下格式使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book&quot;&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure>\n\n<p>图标样式前缀均为 <code>icon</code>，此外还有 5 个图标大小调节类和 1 个间距类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 1.3倍大小 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-lg&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 2倍大小 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-2x&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 3倍大小 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-3x&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 4倍大小 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-4x&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 5倍大小 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-5x&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 5px右边距 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-pr&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 5px左边距 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-pl&quot;&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"个别图标无法显示\"><a href=\"#个别图标无法显示\" class=\"headerlink\" title=\"个别图标无法显示\"></a>个别图标无法显示</h2><p>如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。</p>\n<p>解决办法：可配置 ADBlock 不在你的站点运行。</p>\n<h2 id=\"生成站点后没有样式\"><a href=\"#生成站点后没有样式\" class=\"headerlink\" title=\"生成站点后没有样式\"></a>生成站点后没有样式</h2><p><a href=\"https://github.com/yscoder/hexo-theme-indigo/wiki/安装\" target=\"_blank\" rel=\"noopener\">安装less</a></p>\n<h2 id=\"更改样式后网站没有生效\"><a href=\"#更改样式后网站没有生效\" class=\"headerlink\" title=\"更改样式后网站没有生效\"></a>更改样式后网站没有生效</h2><p>确认非缓存问题后，执行 <code>hexo clean</code> 再进行生成上传。</p>\n<h2 id=\"更改站点配色\"><a href=\"#更改站点配色\" class=\"headerlink\" title=\"更改站点配色\"></a>更改站点配色</h2><p>编辑 <code>themes\\indigo\\source\\css\\_partial\\variable.less</code>，更改对应的颜色变量。</p>\n<p>配色参考：<a href=\"http://www.materialpalette.com/\" target=\"_blank\" rel=\"noopener\">Material Design Color Palette Generator</a></p>\n<blockquote>\n<p>注意：使用自定义配色时需把主题配置中的 cdn 关闭，<code>cdn: false</code>。</p>\n</blockquote>\n<h2 id=\"添加404页面\"><a href=\"#添加404页面\" class=\"headerlink\" title=\"添加404页面\"></a>添加404页面</h2><p>在 <code>hexo/source</code> 目录内新建 <code>404.html</code>。</p>\n<p>设置元数据信息，如果不想套用主题布局可设置 <code>layout</code> 为 <code>false</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layout: false    </span><br><span class=\"line\">title: &quot;My Blog Name | 404&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在博客中使用-Emoji\"><a href=\"#在博客中使用-Emoji\" class=\"headerlink\" title=\"在博客中使用 Emoji\"></a>在博客中使用 Emoji</h2><p>参考 <a href=\"https://github.com/yscoder/hexo-theme-indigo/issues/90\" target=\"_blank\" rel=\"noopener\">Can i use emoji in mypage?</a></p>\n<h2 id=\"自行修改样式线上不生效\"><a href=\"#自行修改样式线上不生效\" class=\"headerlink\" title=\"自行修改样式线上不生效\"></a>自行修改样式线上不生效</h2><p>因为主题默认引用 cdn 样式，只有主题更新时，cdn 中的样式才会变化。 如果想使用自己修改的样式，需要把修改配置中的 <code>cdn: false</code>。这样就不在引用 cdn 资源，使用本地资源了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>由于刚刚开始使用hexo，对很多操作都不是很理解，因此，进行了一些调研，调研结果如下，包括摘要，标签等等方式</code></p>\n<h3 id=\"如何设置文章摘要\"><a href=\"#如何设置文章摘要\" class=\"headerlink\" title=\"如何设置文章摘要\"></a>如何设置文章摘要</h3><p>在 Markdown 中加 ``</p>\n<h3 id=\"文章如何添加多个标签\"><a href=\"#文章如何添加多个标签\" class=\"headerlink\" title=\"文章如何添加多个标签\"></a>文章如何添加多个标签</h3><p>有两种多标签格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tags: [a, b, c]</span><br></pre></td></tr></table></figure>\n\n<p>或</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tags: </span><br><span class=\"line\">  - a</span><br><span class=\"line\">  - b</span><br><span class=\"line\">  - c</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"修改-brand-图片（菜单上方背景图）\"><a href=\"#修改-brand-图片（菜单上方背景图）\" class=\"headerlink\" title=\"修改 brand 图片（菜单上方背景图）\"></a>修改 brand 图片（菜单上方背景图）</h2><p>替换 <code>themes\\indigo\\source\\img\\brand.jpg</code>，保持原文件名不变。</p>\n<h3 id=\"如何在文章中使用图标\"><a href=\"#如何在文章中使用图标\" class=\"headerlink\" title=\"如何在文章中使用图标\"></a>如何在文章中使用图标</h3><p>先到 <a href=\"http://fontawesome.io/icons/\" target=\"_blank\" rel=\"noopener\">fontawesome</a> 找到你需要的图标名，比如：<code>book</code>，按以下格式使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book&quot;&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure>\n\n<p>图标样式前缀均为 <code>icon</code>，此外还有 5 个图标大小调节类和 1 个间距类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 1.3倍大小 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-lg&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 2倍大小 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-2x&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 3倍大小 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-3x&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 4倍大小 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-4x&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 5倍大小 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-5x&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 5px右边距 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-pr&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class=\"line\">&lt;!-- 5px左边距 --&gt;</span><br><span class=\"line\">&lt;i class&#x3D;&quot;icon icon-book icon-pl&quot;&gt;&lt;&#x2F;i&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"个别图标无法显示\"><a href=\"#个别图标无法显示\" class=\"headerlink\" title=\"个别图标无法显示\"></a>个别图标无法显示</h2><p>如果你的浏览器安装了 ADBlock，它会屏蔽 SNS 相关的内容，比如：Github。</p>\n<p>解决办法：可配置 ADBlock 不在你的站点运行。</p>\n<h2 id=\"生成站点后没有样式\"><a href=\"#生成站点后没有样式\" class=\"headerlink\" title=\"生成站点后没有样式\"></a>生成站点后没有样式</h2><p><a href=\"https://github.com/yscoder/hexo-theme-indigo/wiki/安装\" target=\"_blank\" rel=\"noopener\">安装less</a></p>\n<h2 id=\"更改样式后网站没有生效\"><a href=\"#更改样式后网站没有生效\" class=\"headerlink\" title=\"更改样式后网站没有生效\"></a>更改样式后网站没有生效</h2><p>确认非缓存问题后，执行 <code>hexo clean</code> 再进行生成上传。</p>\n<h2 id=\"更改站点配色\"><a href=\"#更改站点配色\" class=\"headerlink\" title=\"更改站点配色\"></a>更改站点配色</h2><p>编辑 <code>themes\\indigo\\source\\css\\_partial\\variable.less</code>，更改对应的颜色变量。</p>\n<p>配色参考：<a href=\"http://www.materialpalette.com/\" target=\"_blank\" rel=\"noopener\">Material Design Color Palette Generator</a></p>\n<blockquote>\n<p>注意：使用自定义配色时需把主题配置中的 cdn 关闭，<code>cdn: false</code>。</p>\n</blockquote>\n<h2 id=\"添加404页面\"><a href=\"#添加404页面\" class=\"headerlink\" title=\"添加404页面\"></a>添加404页面</h2><p>在 <code>hexo/source</code> 目录内新建 <code>404.html</code>。</p>\n<p>设置元数据信息，如果不想套用主题布局可设置 <code>layout</code> 为 <code>false</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">layout: false    </span><br><span class=\"line\">title: &quot;My Blog Name | 404&quot;</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在博客中使用-Emoji\"><a href=\"#在博客中使用-Emoji\" class=\"headerlink\" title=\"在博客中使用 Emoji\"></a>在博客中使用 Emoji</h2><p>参考 <a href=\"https://github.com/yscoder/hexo-theme-indigo/issues/90\" target=\"_blank\" rel=\"noopener\">Can i use emoji in mypage?</a></p>\n<h2 id=\"自行修改样式线上不生效\"><a href=\"#自行修改样式线上不生效\" class=\"headerlink\" title=\"自行修改样式线上不生效\"></a>自行修改样式线上不生效</h2><p>因为主题默认引用 cdn 样式，只有主题更新时，cdn 中的样式才会变化。 如果想使用自己修改的样式，需要把修改配置中的 <code>cdn: false</code>。这样就不在引用 cdn 资源，使用本地资源了。</p>\n"},{"title":"Ubuntu 安装vs code","date":"2018-07-18T16:00:00.000Z","_content":"\n# [ubuntu16.04安装visual-studio-code](https://www.cnblogs.com/iamhenanese/p/5628275.html)\n\n[微软主页的安装说明](https://code.visualstudio.com/docs/setup/linux)，https://code.visualstudio.com/docs/setup/linux  \n\n有**一点**英语基础就能看懂，写的很好，一切以官方文档为主\n\n方法一：可以使用umake，（要先安装，非常牛逼的工具，可以安装很多种流行的开发工具）\n\nsudo apt install ubuntu-make\n\numake web visual-studio-code  ,会问你安装目录，回车即可，接受，完成安装，快捷方式会出现在快速启动栏，不过有个问题，我不懂如何命令行启动，这让我用的不舒服。\n\numake -r web visual-studio-code   即可删除\n\n方法二：或者到微软的vscode网站  （下载地址）https://code.visualstudio.com/Download，即可安装，可以使用（  命令行输入code .  在任何目录中打开该编辑器，只用deb安装的可以命令行打开，其他不行） 推荐使用这种方法，bug最少，启动最方便\n\n方法三：或者直接下载一个.zip文件，双击一个叫code的可执行文件即可。\n\n感觉非常棒，但是换编辑器太花时间，而且atom已经用的比较习惯了，所以先放一放。\n\n如果不能安装成功，可以看一看参考[Arun Pyasi的文章](http://os.51cto.com/art/201509/490032.htm)，他写的更详细，网址http://os.51cto.com/art/201509/490032.htm","source":"_posts/常见问题/ubuntu安装vscode.md","raw":"---\ntitle: Ubuntu 安装vs code\ndate: 2018-7-19\ntags:\n- 应用安装\ncategories:\n- 常见问题\n---\n\n# [ubuntu16.04安装visual-studio-code](https://www.cnblogs.com/iamhenanese/p/5628275.html)\n\n[微软主页的安装说明](https://code.visualstudio.com/docs/setup/linux)，https://code.visualstudio.com/docs/setup/linux  \n\n有**一点**英语基础就能看懂，写的很好，一切以官方文档为主\n\n方法一：可以使用umake，（要先安装，非常牛逼的工具，可以安装很多种流行的开发工具）\n\nsudo apt install ubuntu-make\n\numake web visual-studio-code  ,会问你安装目录，回车即可，接受，完成安装，快捷方式会出现在快速启动栏，不过有个问题，我不懂如何命令行启动，这让我用的不舒服。\n\numake -r web visual-studio-code   即可删除\n\n方法二：或者到微软的vscode网站  （下载地址）https://code.visualstudio.com/Download，即可安装，可以使用（  命令行输入code .  在任何目录中打开该编辑器，只用deb安装的可以命令行打开，其他不行） 推荐使用这种方法，bug最少，启动最方便\n\n方法三：或者直接下载一个.zip文件，双击一个叫code的可执行文件即可。\n\n感觉非常棒，但是换编辑器太花时间，而且atom已经用的比较习惯了，所以先放一放。\n\n如果不能安装成功，可以看一看参考[Arun Pyasi的文章](http://os.51cto.com/art/201509/490032.htm)，他写的更详细，网址http://os.51cto.com/art/201509/490032.htm","slug":"常见问题/ubuntu安装vscode","published":1,"updated":"2020-01-23T09:10:20.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b7s000e3v8n5q6g9lny","content":"<h1 id=\"ubuntu16-04安装visual-studio-code\"><a href=\"#ubuntu16-04安装visual-studio-code\" class=\"headerlink\" title=\"ubuntu16.04安装visual-studio-code\"></a><a href=\"https://www.cnblogs.com/iamhenanese/p/5628275.html\" target=\"_blank\" rel=\"noopener\">ubuntu16.04安装visual-studio-code</a></h1><p><a href=\"https://code.visualstudio.com/docs/setup/linux\" target=\"_blank\" rel=\"noopener\">微软主页的安装说明</a>，<a href=\"https://code.visualstudio.com/docs/setup/linux\" target=\"_blank\" rel=\"noopener\">https://code.visualstudio.com/docs/setup/linux</a>  </p>\n<p>有<strong>一点</strong>英语基础就能看懂，写的很好，一切以官方文档为主</p>\n<p>方法一：可以使用umake，（要先安装，非常牛逼的工具，可以安装很多种流行的开发工具）</p>\n<p>sudo apt install ubuntu-make</p>\n<p>umake web visual-studio-code  ,会问你安装目录，回车即可，接受，完成安装，快捷方式会出现在快速启动栏，不过有个问题，我不懂如何命令行启动，这让我用的不舒服。</p>\n<p>umake -r web visual-studio-code   即可删除</p>\n<p>方法二：或者到微软的vscode网站  （下载地址）<a href=\"https://code.visualstudio.com/Download，即可安装，可以使用（\" target=\"_blank\" rel=\"noopener\">https://code.visualstudio.com/Download，即可安装，可以使用（</a>  命令行输入code .  在任何目录中打开该编辑器，只用deb安装的可以命令行打开，其他不行） 推荐使用这种方法，bug最少，启动最方便</p>\n<p>方法三：或者直接下载一个.zip文件，双击一个叫code的可执行文件即可。</p>\n<p>感觉非常棒，但是换编辑器太花时间，而且atom已经用的比较习惯了，所以先放一放。</p>\n<p>如果不能安装成功，可以看一看参考<a href=\"http://os.51cto.com/art/201509/490032.htm\" target=\"_blank\" rel=\"noopener\">Arun Pyasi的文章</a>，他写的更详细，网址<a href=\"http://os.51cto.com/art/201509/490032.htm\" target=\"_blank\" rel=\"noopener\">http://os.51cto.com/art/201509/490032.htm</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ubuntu16-04安装visual-studio-code\"><a href=\"#ubuntu16-04安装visual-studio-code\" class=\"headerlink\" title=\"ubuntu16.04安装visual-studio-code\"></a><a href=\"https://www.cnblogs.com/iamhenanese/p/5628275.html\" target=\"_blank\" rel=\"noopener\">ubuntu16.04安装visual-studio-code</a></h1><p><a href=\"https://code.visualstudio.com/docs/setup/linux\" target=\"_blank\" rel=\"noopener\">微软主页的安装说明</a>，<a href=\"https://code.visualstudio.com/docs/setup/linux\" target=\"_blank\" rel=\"noopener\">https://code.visualstudio.com/docs/setup/linux</a>  </p>\n<p>有<strong>一点</strong>英语基础就能看懂，写的很好，一切以官方文档为主</p>\n<p>方法一：可以使用umake，（要先安装，非常牛逼的工具，可以安装很多种流行的开发工具）</p>\n<p>sudo apt install ubuntu-make</p>\n<p>umake web visual-studio-code  ,会问你安装目录，回车即可，接受，完成安装，快捷方式会出现在快速启动栏，不过有个问题，我不懂如何命令行启动，这让我用的不舒服。</p>\n<p>umake -r web visual-studio-code   即可删除</p>\n<p>方法二：或者到微软的vscode网站  （下载地址）<a href=\"https://code.visualstudio.com/Download，即可安装，可以使用（\" target=\"_blank\" rel=\"noopener\">https://code.visualstudio.com/Download，即可安装，可以使用（</a>  命令行输入code .  在任何目录中打开该编辑器，只用deb安装的可以命令行打开，其他不行） 推荐使用这种方法，bug最少，启动最方便</p>\n<p>方法三：或者直接下载一个.zip文件，双击一个叫code的可执行文件即可。</p>\n<p>感觉非常棒，但是换编辑器太花时间，而且atom已经用的比较习惯了，所以先放一放。</p>\n<p>如果不能安装成功，可以看一看参考<a href=\"http://os.51cto.com/art/201509/490032.htm\" target=\"_blank\" rel=\"noopener\">Arun Pyasi的文章</a>，他写的更详细，网址<a href=\"http://os.51cto.com/art/201509/490032.htm\" target=\"_blank\" rel=\"noopener\">http://os.51cto.com/art/201509/490032.htm</a></p>\n"},{"title":"linux命令-scp","date":"2018-08-16T16:00:00.000Z","_content":"\nscp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。\n\n<!-- more -->\n\n1．命令格式：\n\nscp [参数] [原路径] [目标路径]\n\n2．命令功能：\n\nscp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。\n\n3．命令参数：\n\n-1 强制scp命令使用协议ssh1 \n\n-2 强制scp命令使用协议ssh2 \n\n-4 强制scp命令只使用IPv4寻址 \n\n-6 强制scp命令只使用IPv6寻址 \n\n-B 使用批处理模式（传输过程中不询问传输口令或短语） \n\n-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） \n\n-p 保留原文件的修改时间，访问时间和访问权限。 \n\n-q 不显示传输进度条。 \n\n-r 递归复制整个目录。 \n\n-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 \n\n-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 \n\n-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 \n\n-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。  \n\n-l limit 限定用户所能使用的带宽，以Kbit/s为单位。  \n\n-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， \n\n-P port 注意是大写的P, port是指定数据传输用到的端口号 \n\n-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n\n4．使用实例：\n\nscp命令的实际应用概述： \n\n从本地服务器复制到远程服务器：\n\n(1) 复制文件： \n\n命令格式： \n\nscp local_file remote_username@remote_ip:remote_folder \n\n或者 \n\nscp local_file remote_username@remote_ip:remote_file \n\n或者 \n\nscp local_file remote_ip:remote_folder \n\n或者 \n\nscp local_file remote_ip:remote_file \n\n第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名 \n\n第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名 \n\n(2) 复制目录： \n\n命令格式： \n\nscp -r local_folder remote_username@remote_ip:remote_folder \n\n或者 \n\nscp -r local_folder remote_ip:remote_folder \n\n第1个指定了用户名，命令执行后需要输入用户密码； \n\n第2个没有指定用户名，命令执行后需要输入用户名和密码；\n\n \n\n从远程服务器复制到本地服务器：\n\n从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。\n\n \n\n实例1：从远处复制文件到本地目录\n\n命令：\n\nscp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/\n\n输出：\n\n ","source":"_posts/常见问题/云服务器/linux命令-scp.md","raw":"---\ntitle: linux命令-scp\ndate: 2018-08-17\ntags:\n- linux\n- 云服务器\ncategories:\n- 常见问题\n---\n\nscp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。\n\n<!-- more -->\n\n1．命令格式：\n\nscp [参数] [原路径] [目标路径]\n\n2．命令功能：\n\nscp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。\n\n3．命令参数：\n\n-1 强制scp命令使用协议ssh1 \n\n-2 强制scp命令使用协议ssh2 \n\n-4 强制scp命令只使用IPv4寻址 \n\n-6 强制scp命令只使用IPv6寻址 \n\n-B 使用批处理模式（传输过程中不询问传输口令或短语） \n\n-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） \n\n-p 保留原文件的修改时间，访问时间和访问权限。 \n\n-q 不显示传输进度条。 \n\n-r 递归复制整个目录。 \n\n-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 \n\n-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 \n\n-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 \n\n-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。  \n\n-l limit 限定用户所能使用的带宽，以Kbit/s为单位。  \n\n-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， \n\n-P port 注意是大写的P, port是指定数据传输用到的端口号 \n\n-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。\n\n4．使用实例：\n\nscp命令的实际应用概述： \n\n从本地服务器复制到远程服务器：\n\n(1) 复制文件： \n\n命令格式： \n\nscp local_file remote_username@remote_ip:remote_folder \n\n或者 \n\nscp local_file remote_username@remote_ip:remote_file \n\n或者 \n\nscp local_file remote_ip:remote_folder \n\n或者 \n\nscp local_file remote_ip:remote_file \n\n第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名 \n\n第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名 \n\n(2) 复制目录： \n\n命令格式： \n\nscp -r local_folder remote_username@remote_ip:remote_folder \n\n或者 \n\nscp -r local_folder remote_ip:remote_folder \n\n第1个指定了用户名，命令执行后需要输入用户密码； \n\n第2个没有指定用户名，命令执行后需要输入用户名和密码；\n\n \n\n从远程服务器复制到本地服务器：\n\n从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。\n\n \n\n实例1：从远处复制文件到本地目录\n\n命令：\n\nscp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/\n\n输出：\n\n ","slug":"常见问题/云服务器/linux命令-scp","published":1,"updated":"2020-01-23T09:29:00.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b7w000h3v8n2tqr4ykg","content":"<p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p>\n<a id=\"more\"></a>\n\n<p>1．命令格式：</p>\n<p>scp [参数] [原路径] [目标路径]</p>\n<p>2．命令功能：</p>\n<p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。</p>\n<p>3．命令参数：</p>\n<p>-1 强制scp命令使用协议ssh1 </p>\n<p>-2 强制scp命令使用协议ssh2 </p>\n<p>-4 强制scp命令只使用IPv4寻址 </p>\n<p>-6 强制scp命令只使用IPv6寻址 </p>\n<p>-B 使用批处理模式（传输过程中不询问传输口令或短语） </p>\n<p>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） </p>\n<p>-p 保留原文件的修改时间，访问时间和访问权限。 </p>\n<p>-q 不显示传输进度条。 </p>\n<p>-r 递归复制整个目录。 </p>\n<p>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 </p>\n<p>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 </p>\n<p>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 </p>\n<p>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。  </p>\n<p>-l limit 限定用户所能使用的带宽，以Kbit/s为单位。  </p>\n<p>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， </p>\n<p>-P port 注意是大写的P, port是指定数据传输用到的端口号 </p>\n<p>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</p>\n<p>4．使用实例：</p>\n<p>scp命令的实际应用概述： </p>\n<p>从本地服务器复制到远程服务器：</p>\n<p>(1) 复制文件： </p>\n<p>命令格式： </p>\n<p>scp local_file remote_username@remote_ip:remote_folder </p>\n<p>或者 </p>\n<p>scp local_file remote_username@remote_ip:remote_file </p>\n<p>或者 </p>\n<p>scp local_file remote_ip:remote_folder </p>\n<p>或者 </p>\n<p>scp local_file remote_ip:remote_file </p>\n<p>第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名 </p>\n<p>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名 </p>\n<p>(2) 复制目录： </p>\n<p>命令格式： </p>\n<p>scp -r local_folder remote_username@remote_ip:remote_folder </p>\n<p>或者 </p>\n<p>scp -r local_folder remote_ip:remote_folder </p>\n<p>第1个指定了用户名，命令执行后需要输入用户密码； </p>\n<p>第2个没有指定用户名，命令执行后需要输入用户名和密码；</p>\n<p>从远程服务器复制到本地服务器：</p>\n<p>从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。</p>\n<p>实例1：从远处复制文件到本地目录</p>\n<p>命令：</p>\n<p>scp <a href=\"mailto:root@192.168.120.204\">root@192.168.120.204</a>:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/</p>\n<p>输出：</p>\n","site":{"data":{}},"excerpt":"<p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p>","more":"<p>1．命令格式：</p>\n<p>scp [参数] [原路径] [目标路径]</p>\n<p>2．命令功能：</p>\n<p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。</p>\n<p>3．命令参数：</p>\n<p>-1 强制scp命令使用协议ssh1 </p>\n<p>-2 强制scp命令使用协议ssh2 </p>\n<p>-4 强制scp命令只使用IPv4寻址 </p>\n<p>-6 强制scp命令只使用IPv6寻址 </p>\n<p>-B 使用批处理模式（传输过程中不询问传输口令或短语） </p>\n<p>-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） </p>\n<p>-p 保留原文件的修改时间，访问时间和访问权限。 </p>\n<p>-q 不显示传输进度条。 </p>\n<p>-r 递归复制整个目录。 </p>\n<p>-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 </p>\n<p>-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 </p>\n<p>-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 </p>\n<p>-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。  </p>\n<p>-l limit 限定用户所能使用的带宽，以Kbit/s为单位。  </p>\n<p>-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， </p>\n<p>-P port 注意是大写的P, port是指定数据传输用到的端口号 </p>\n<p>-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</p>\n<p>4．使用实例：</p>\n<p>scp命令的实际应用概述： </p>\n<p>从本地服务器复制到远程服务器：</p>\n<p>(1) 复制文件： </p>\n<p>命令格式： </p>\n<p>scp local_file remote_username@remote_ip:remote_folder </p>\n<p>或者 </p>\n<p>scp local_file remote_username@remote_ip:remote_file </p>\n<p>或者 </p>\n<p>scp local_file remote_ip:remote_folder </p>\n<p>或者 </p>\n<p>scp local_file remote_ip:remote_file </p>\n<p>第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名 </p>\n<p>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名 </p>\n<p>(2) 复制目录： </p>\n<p>命令格式： </p>\n<p>scp -r local_folder remote_username@remote_ip:remote_folder </p>\n<p>或者 </p>\n<p>scp -r local_folder remote_ip:remote_folder </p>\n<p>第1个指定了用户名，命令执行后需要输入用户密码； </p>\n<p>第2个没有指定用户名，命令执行后需要输入用户名和密码；</p>\n<p>从远程服务器复制到本地服务器：</p>\n<p>从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。</p>\n<p>实例1：从远处复制文件到本地目录</p>\n<p>命令：</p>\n<p>scp <a href=\"mailto:root@192.168.120.204\">root@192.168.120.204</a>:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/</p>\n<p>输出：</p>"},{"title":"linux多命令连接","date":"2018-07-05T16:00:00.000Z","_content":"\n当我们需要一次执行多个命令的时候，命令之间需要用连接符连接，不同的连接符有不同的效果。下面我们总结一下，加以区分。\n\n<!-- more -->\n\n(1)  ; \n\n分号，没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。\n\n(2) ||\n\n逻辑或，当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。\n\n(3) &&\n\n逻辑与，当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 || 正好相反。\n\n(4) |\n\n管道符，当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错。\n\n例 ls | grep *.txt\n\n﻿\n\n**在linux中，&和&&,|和||介绍如下：**\n\n**&  表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &**\n\n**&& 表示前一条命令执行成功时，才执行后一条命令 ，如 echo '1‘ && echo '2'**   \n\n**| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo 'yes' | wc -l**\n\n**|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo \"fail\"**","source":"_posts/常见问题/云服务器/linux多命令连接.md","raw":"---\ntitle: linux多命令连接\ndate: 2018-07-06\ntags:\n- linux\n- 云服务器\ncategories:\n- 常见问题\n---\n\n当我们需要一次执行多个命令的时候，命令之间需要用连接符连接，不同的连接符有不同的效果。下面我们总结一下，加以区分。\n\n<!-- more -->\n\n(1)  ; \n\n分号，没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。\n\n(2) ||\n\n逻辑或，当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。\n\n(3) &&\n\n逻辑与，当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 || 正好相反。\n\n(4) |\n\n管道符，当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错。\n\n例 ls | grep *.txt\n\n﻿\n\n**在linux中，&和&&,|和||介绍如下：**\n\n**&  表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &**\n\n**&& 表示前一条命令执行成功时，才执行后一条命令 ，如 echo '1‘ && echo '2'**   \n\n**| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo 'yes' | wc -l**\n\n**|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo \"fail\"**","slug":"常见问题/云服务器/linux多命令连接","published":1,"updated":"2020-01-23T09:28:55.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b7x000i3v8napp29d7n","content":"<p>当我们需要一次执行多个命令的时候，命令之间需要用连接符连接，不同的连接符有不同的效果。下面我们总结一下，加以区分。</p>\n<a id=\"more\"></a>\n\n<p>(1)  ; </p>\n<p>分号，没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。</p>\n<p>(2) ||</p>\n<p>逻辑或，当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。</p>\n<p>(3) &amp;&amp;</p>\n<p>逻辑与，当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 || 正好相反。</p>\n<p>(4) |</p>\n<p>管道符，当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错。</p>\n<p>例 ls | grep *.txt</p>\n<p>﻿</p>\n<p><strong>在linux中，&amp;和&amp;&amp;,|和||介绍如下：</strong></p>\n<p><strong>&amp;  表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &amp;</strong></p>\n<p><strong>&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ &amp;&amp; echo ‘2’</strong>   </p>\n<p><strong>| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l</strong></p>\n<p><strong>|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</strong></p>\n","site":{"data":{}},"excerpt":"<p>当我们需要一次执行多个命令的时候，命令之间需要用连接符连接，不同的连接符有不同的效果。下面我们总结一下，加以区分。</p>","more":"<p>(1)  ; </p>\n<p>分号，没有任何逻辑关系的连接符。当多个命令用分号连接时，各命令之间的执行成功与否彼此没有任何影响，都会一条一条执行下去。</p>\n<p>(2) ||</p>\n<p>逻辑或，当用此连接符连接多个命令时，前面的命令执行成功，则后面的命令不会执行。前面的命令执行失败，后面的命令才会执行。</p>\n<p>(3) &amp;&amp;</p>\n<p>逻辑与，当用此连接符连接多个命令时，前面的命令执行成功，才会执行后面的命令，前面的命令执行失败，后面的命令不会执行，与 || 正好相反。</p>\n<p>(4) |</p>\n<p>管道符，当用此连接符连接多个命令时，前面命令执行的正确输出，会交给后面的命令继续处理。若前面的命令执行失败，则会报错，若后面的命令无法处理前面命令的输出，也会报错。</p>\n<p>例 ls | grep *.txt</p>\n<p>﻿</p>\n<p><strong>在linux中，&amp;和&amp;&amp;,|和||介绍如下：</strong></p>\n<p><strong>&amp;  表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &amp;</strong></p>\n<p><strong>&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo ‘1‘ &amp;&amp; echo ‘2’</strong>   </p>\n<p><strong>| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo ‘yes’ | wc -l</strong></p>\n<p><strong>|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo “fail”</strong></p>"},{"title":"bash快捷键","date":"2019-04-23T16:00:00.000Z","_content":"\n\n今天敲命令行时想在单词间移动，竟然不记得快速移动的快捷键。试了`Ctrl + W`和`Ctrl + B/F`均不凑效，于是怀念之前某博主分享的终端快捷键说明图。\n\n好在很快从浏览记录中找到了链接。原博主([@linuxtoy](https://link.juejin.im/?target=https%3A%2F%2Ftwitter.com%2Flinuxtoy))分享的终端跳转解说图为：\n\n[![img](https://user-gold-cdn.xitu.io/2019/2/10/168d7a68490a6ba5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)](https://link.juejin.im/?target=https%3A%2F%2Ftlanyan.me%2Fbash-shortcuts%2Fbash-shortcut%2F)\n\n虽然命令难记，但解说图清晰易懂，让人印象深刻。\n\n趁热打铁，马上找了篇解说`bash`快捷键的文章温习一下。博主[Alan Skorkin](https://link.juejin.im/?target=https%3A%2F%2Fskorks.com)的\"[Bash Shortcuts For Maximum Productivity](https://link.juejin.im/?target=1)\"一文写得十分详细，故在此翻译和分享，并部分内容做注释和修正。\n\nAlan Skorkin将bash快捷键分成四类，接下来一一给出。\n\n## 编辑\n\n- **Ctrl + a** – 跳到行首\n- **Ctrl + e** – 跳到行尾\n- **Ctrl + k** – 删除当前光标至行尾内容\n- **Ctrl + u** – 删除当前光标至行首内容\n- **Ctrl + w** – 删除当前光标至**词首**内容\n- **Ctrl + y** – 将剪切的内容粘贴在光标后\n- **Ctrl + xx** – 在行首和当前光标处(来回)移动\n- **Alt + b** – 跳到词首\n- **Alt + f** – 跳到词尾\n- **Alt + d** – 删除自光标处起的**单词**内容\n- **Alt + c** – 大写光标处的字符（**注：该条内容与原文不同**）\n- **Alt + u** – 大写自光标处起的**单词**内容\n- **Alt + l** – 小写自光标处起的**单词**内容\n- **Alt + t** – 将光标处单词与上一个词交换\n- **Ctrl + f** – 向前移动一个字符(相当于按向左箭头)\n- **Ctrl + b** – 向后移动一个字符(相当于按向右箭头)\n- **Ctrl + d** – 删除光标后一个字符（相当于按Delete）\n- **Ctrl + h** – 删除光标前一个字符（相当于按后退键）\n- **Ctrl + t** – 交换光标处的两个字符\n\n## 搜索\n\n- **Ctrl + r** – 反向搜索历史命令\n- **Ctrl + g** – 退出历史搜索模式（相当于按Esc）\n- **Ctrl + p** – 上一个历史命令（相当于按向上箭头）\n- **Ctrl + n** – 下一个历史命令（相当于按向下箭头）\n- **Alt + .** – 使用上一个命令的最后一个单词\n\n## 控制\n\n- **Ctrl + l** – 清屏\n- **Ctrl + s** – 终止输出到屏幕（对长时间运行并打印详细信息的命令）\n- **Ctrl + q** – 允许输出到屏幕（如果之前用过终止输出命令）\n- **Ctrl + c** – 终止命令\n- **Ctrl + z** – 中断命令\n\n## Bang(即感叹号)\n\n- **!!** – 执行上一条命令\n- **!blah** –执行最近运行过的以`blah`开头的命令\n- **!blah:p** – 打印`!blah`要执行的命令（并将其作为最后一条命令加入到命令历史中）\n- **!$** – 上一条命令的最后一个单词 (等同于`Alt + .`)\n- **!$:p** – 打印`!$`指代的单词\n- **!\\*** – 上一条命令除最后一个词的部分\n- **!\\*:p** – 打印`!*`指代部分\n\n如果错误，敬请指正！\n\n## ","source":"_posts/常见问题/云服务器/bash快捷键.md","raw":"---\ntitle: bash快捷键\ndate: 2019-04-24\ntags:\n- linux\n- 快捷键\n- 云服务器\ncategories:\n- 常见问题\n---\n\n\n今天敲命令行时想在单词间移动，竟然不记得快速移动的快捷键。试了`Ctrl + W`和`Ctrl + B/F`均不凑效，于是怀念之前某博主分享的终端快捷键说明图。\n\n好在很快从浏览记录中找到了链接。原博主([@linuxtoy](https://link.juejin.im/?target=https%3A%2F%2Ftwitter.com%2Flinuxtoy))分享的终端跳转解说图为：\n\n[![img](https://user-gold-cdn.xitu.io/2019/2/10/168d7a68490a6ba5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)](https://link.juejin.im/?target=https%3A%2F%2Ftlanyan.me%2Fbash-shortcuts%2Fbash-shortcut%2F)\n\n虽然命令难记，但解说图清晰易懂，让人印象深刻。\n\n趁热打铁，马上找了篇解说`bash`快捷键的文章温习一下。博主[Alan Skorkin](https://link.juejin.im/?target=https%3A%2F%2Fskorks.com)的\"[Bash Shortcuts For Maximum Productivity](https://link.juejin.im/?target=1)\"一文写得十分详细，故在此翻译和分享，并部分内容做注释和修正。\n\nAlan Skorkin将bash快捷键分成四类，接下来一一给出。\n\n## 编辑\n\n- **Ctrl + a** – 跳到行首\n- **Ctrl + e** – 跳到行尾\n- **Ctrl + k** – 删除当前光标至行尾内容\n- **Ctrl + u** – 删除当前光标至行首内容\n- **Ctrl + w** – 删除当前光标至**词首**内容\n- **Ctrl + y** – 将剪切的内容粘贴在光标后\n- **Ctrl + xx** – 在行首和当前光标处(来回)移动\n- **Alt + b** – 跳到词首\n- **Alt + f** – 跳到词尾\n- **Alt + d** – 删除自光标处起的**单词**内容\n- **Alt + c** – 大写光标处的字符（**注：该条内容与原文不同**）\n- **Alt + u** – 大写自光标处起的**单词**内容\n- **Alt + l** – 小写自光标处起的**单词**内容\n- **Alt + t** – 将光标处单词与上一个词交换\n- **Ctrl + f** – 向前移动一个字符(相当于按向左箭头)\n- **Ctrl + b** – 向后移动一个字符(相当于按向右箭头)\n- **Ctrl + d** – 删除光标后一个字符（相当于按Delete）\n- **Ctrl + h** – 删除光标前一个字符（相当于按后退键）\n- **Ctrl + t** – 交换光标处的两个字符\n\n## 搜索\n\n- **Ctrl + r** – 反向搜索历史命令\n- **Ctrl + g** – 退出历史搜索模式（相当于按Esc）\n- **Ctrl + p** – 上一个历史命令（相当于按向上箭头）\n- **Ctrl + n** – 下一个历史命令（相当于按向下箭头）\n- **Alt + .** – 使用上一个命令的最后一个单词\n\n## 控制\n\n- **Ctrl + l** – 清屏\n- **Ctrl + s** – 终止输出到屏幕（对长时间运行并打印详细信息的命令）\n- **Ctrl + q** – 允许输出到屏幕（如果之前用过终止输出命令）\n- **Ctrl + c** – 终止命令\n- **Ctrl + z** – 中断命令\n\n## Bang(即感叹号)\n\n- **!!** – 执行上一条命令\n- **!blah** –执行最近运行过的以`blah`开头的命令\n- **!blah:p** – 打印`!blah`要执行的命令（并将其作为最后一条命令加入到命令历史中）\n- **!$** – 上一条命令的最后一个单词 (等同于`Alt + .`)\n- **!$:p** – 打印`!$`指代的单词\n- **!\\*** – 上一条命令除最后一个词的部分\n- **!\\*:p** – 打印`!*`指代部分\n\n如果错误，敬请指正！\n\n## ","slug":"常见问题/云服务器/bash快捷键","published":1,"updated":"2020-01-23T09:41:30.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b7y000k3v8n3ekzdyh1","content":"<p>今天敲命令行时想在单词间移动，竟然不记得快速移动的快捷键。试了<code>Ctrl + W</code>和<code>Ctrl + B/F</code>均不凑效，于是怀念之前某博主分享的终端快捷键说明图。</p>\n<p>好在很快从浏览记录中找到了链接。原博主(<a href=\"https://link.juejin.im/?target=https%3A%2F%2Ftwitter.com%2Flinuxtoy\">@linuxtoy</a>)分享的终端跳转解说图为：</p>\n<p>[<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://link.juejin.im/?target=https%3A%2F%2Ftlanyan.me%2Fbash-shortcuts%2Fbash-shortcut%2F\" alt=\"img](https://user-gold-cdn.xitu.io/2019/2/10/168d7a68490a6ba5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img](https://user-gold-cdn.xitu.io/2019/2/10/168d7a68490a6ba5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</div>\n            </figure></p>\n<p>虽然命令难记，但解说图清晰易懂，让人印象深刻。</p>\n<p>趁热打铁，马上找了篇解说<code>bash</code>快捷键的文章温习一下。博主<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fskorks.com\">Alan Skorkin</a>的”<a href=\"https://link.juejin.im/?target=1\">Bash Shortcuts For Maximum Productivity</a>“一文写得十分详细，故在此翻译和分享，并部分内容做注释和修正。</p>\n<p>Alan Skorkin将bash快捷键分成四类，接下来一一给出。</p>\n<h2 id=\"编辑\"><a href=\"#编辑\" class=\"headerlink\" title=\"编辑\"></a>编辑</h2><ul>\n<li><strong>Ctrl + a</strong> – 跳到行首</li>\n<li><strong>Ctrl + e</strong> – 跳到行尾</li>\n<li><strong>Ctrl + k</strong> – 删除当前光标至行尾内容</li>\n<li><strong>Ctrl + u</strong> – 删除当前光标至行首内容</li>\n<li><strong>Ctrl + w</strong> – 删除当前光标至<strong>词首</strong>内容</li>\n<li><strong>Ctrl + y</strong> – 将剪切的内容粘贴在光标后</li>\n<li><strong>Ctrl + xx</strong> – 在行首和当前光标处(来回)移动</li>\n<li><strong>Alt + b</strong> – 跳到词首</li>\n<li><strong>Alt + f</strong> – 跳到词尾</li>\n<li><strong>Alt + d</strong> – 删除自光标处起的<strong>单词</strong>内容</li>\n<li><strong>Alt + c</strong> – 大写光标处的字符（<strong>注：该条内容与原文不同</strong>）</li>\n<li><strong>Alt + u</strong> – 大写自光标处起的<strong>单词</strong>内容</li>\n<li><strong>Alt + l</strong> – 小写自光标处起的<strong>单词</strong>内容</li>\n<li><strong>Alt + t</strong> – 将光标处单词与上一个词交换</li>\n<li><strong>Ctrl + f</strong> – 向前移动一个字符(相当于按向左箭头)</li>\n<li><strong>Ctrl + b</strong> – 向后移动一个字符(相当于按向右箭头)</li>\n<li><strong>Ctrl + d</strong> – 删除光标后一个字符（相当于按Delete）</li>\n<li><strong>Ctrl + h</strong> – 删除光标前一个字符（相当于按后退键）</li>\n<li><strong>Ctrl + t</strong> – 交换光标处的两个字符</li>\n</ul>\n<h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><ul>\n<li><strong>Ctrl + r</strong> – 反向搜索历史命令</li>\n<li><strong>Ctrl + g</strong> – 退出历史搜索模式（相当于按Esc）</li>\n<li><strong>Ctrl + p</strong> – 上一个历史命令（相当于按向上箭头）</li>\n<li><strong>Ctrl + n</strong> – 下一个历史命令（相当于按向下箭头）</li>\n<li><strong>Alt + .</strong> – 使用上一个命令的最后一个单词</li>\n</ul>\n<h2 id=\"控制\"><a href=\"#控制\" class=\"headerlink\" title=\"控制\"></a>控制</h2><ul>\n<li><strong>Ctrl + l</strong> – 清屏</li>\n<li><strong>Ctrl + s</strong> – 终止输出到屏幕（对长时间运行并打印详细信息的命令）</li>\n<li><strong>Ctrl + q</strong> – 允许输出到屏幕（如果之前用过终止输出命令）</li>\n<li><strong>Ctrl + c</strong> – 终止命令</li>\n<li><strong>Ctrl + z</strong> – 中断命令</li>\n</ul>\n<h2 id=\"Bang-即感叹号\"><a href=\"#Bang-即感叹号\" class=\"headerlink\" title=\"Bang(即感叹号)\"></a>Bang(即感叹号)</h2><ul>\n<li><strong>!!</strong> – 执行上一条命令</li>\n<li><strong>!blah</strong> –执行最近运行过的以<code>blah</code>开头的命令</li>\n<li><strong>!blah:p</strong> – 打印<code>!blah</code>要执行的命令（并将其作为最后一条命令加入到命令历史中）</li>\n<li><strong>!$</strong> – 上一条命令的最后一个单词 (等同于<code>Alt + .</code>)</li>\n<li><strong>!$:p</strong> – 打印<code>!$</code>指代的单词</li>\n<li><strong>!*</strong> – 上一条命令除最后一个词的部分</li>\n<li><strong>!*:p</strong> – 打印<code>!*</code>指代部分</li>\n</ul>\n<p>如果错误，敬请指正！</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>","site":{"data":{}},"excerpt":"","more":"<p>今天敲命令行时想在单词间移动，竟然不记得快速移动的快捷键。试了<code>Ctrl + W</code>和<code>Ctrl + B/F</code>均不凑效，于是怀念之前某博主分享的终端快捷键说明图。</p>\n<p>好在很快从浏览记录中找到了链接。原博主(<a href=\"https://link.juejin.im/?target=https%3A%2F%2Ftwitter.com%2Flinuxtoy\">@linuxtoy</a>)分享的终端跳转解说图为：</p>\n<p>[<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://link.juejin.im/?target=https%3A%2F%2Ftlanyan.me%2Fbash-shortcuts%2Fbash-shortcut%2F\" alt=\"img](https://user-gold-cdn.xitu.io/2019/2/10/168d7a68490a6ba5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img](https://user-gold-cdn.xitu.io/2019/2/10/168d7a68490a6ba5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</div>\n            </figure></p>\n<p>虽然命令难记，但解说图清晰易懂，让人印象深刻。</p>\n<p>趁热打铁，马上找了篇解说<code>bash</code>快捷键的文章温习一下。博主<a href=\"https://link.juejin.im/?target=https%3A%2F%2Fskorks.com\">Alan Skorkin</a>的”<a href=\"https://link.juejin.im/?target=1\">Bash Shortcuts For Maximum Productivity</a>“一文写得十分详细，故在此翻译和分享，并部分内容做注释和修正。</p>\n<p>Alan Skorkin将bash快捷键分成四类，接下来一一给出。</p>\n<h2 id=\"编辑\"><a href=\"#编辑\" class=\"headerlink\" title=\"编辑\"></a>编辑</h2><ul>\n<li><strong>Ctrl + a</strong> – 跳到行首</li>\n<li><strong>Ctrl + e</strong> – 跳到行尾</li>\n<li><strong>Ctrl + k</strong> – 删除当前光标至行尾内容</li>\n<li><strong>Ctrl + u</strong> – 删除当前光标至行首内容</li>\n<li><strong>Ctrl + w</strong> – 删除当前光标至<strong>词首</strong>内容</li>\n<li><strong>Ctrl + y</strong> – 将剪切的内容粘贴在光标后</li>\n<li><strong>Ctrl + xx</strong> – 在行首和当前光标处(来回)移动</li>\n<li><strong>Alt + b</strong> – 跳到词首</li>\n<li><strong>Alt + f</strong> – 跳到词尾</li>\n<li><strong>Alt + d</strong> – 删除自光标处起的<strong>单词</strong>内容</li>\n<li><strong>Alt + c</strong> – 大写光标处的字符（<strong>注：该条内容与原文不同</strong>）</li>\n<li><strong>Alt + u</strong> – 大写自光标处起的<strong>单词</strong>内容</li>\n<li><strong>Alt + l</strong> – 小写自光标处起的<strong>单词</strong>内容</li>\n<li><strong>Alt + t</strong> – 将光标处单词与上一个词交换</li>\n<li><strong>Ctrl + f</strong> – 向前移动一个字符(相当于按向左箭头)</li>\n<li><strong>Ctrl + b</strong> – 向后移动一个字符(相当于按向右箭头)</li>\n<li><strong>Ctrl + d</strong> – 删除光标后一个字符（相当于按Delete）</li>\n<li><strong>Ctrl + h</strong> – 删除光标前一个字符（相当于按后退键）</li>\n<li><strong>Ctrl + t</strong> – 交换光标处的两个字符</li>\n</ul>\n<h2 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h2><ul>\n<li><strong>Ctrl + r</strong> – 反向搜索历史命令</li>\n<li><strong>Ctrl + g</strong> – 退出历史搜索模式（相当于按Esc）</li>\n<li><strong>Ctrl + p</strong> – 上一个历史命令（相当于按向上箭头）</li>\n<li><strong>Ctrl + n</strong> – 下一个历史命令（相当于按向下箭头）</li>\n<li><strong>Alt + .</strong> – 使用上一个命令的最后一个单词</li>\n</ul>\n<h2 id=\"控制\"><a href=\"#控制\" class=\"headerlink\" title=\"控制\"></a>控制</h2><ul>\n<li><strong>Ctrl + l</strong> – 清屏</li>\n<li><strong>Ctrl + s</strong> – 终止输出到屏幕（对长时间运行并打印详细信息的命令）</li>\n<li><strong>Ctrl + q</strong> – 允许输出到屏幕（如果之前用过终止输出命令）</li>\n<li><strong>Ctrl + c</strong> – 终止命令</li>\n<li><strong>Ctrl + z</strong> – 中断命令</li>\n</ul>\n<h2 id=\"Bang-即感叹号\"><a href=\"#Bang-即感叹号\" class=\"headerlink\" title=\"Bang(即感叹号)\"></a>Bang(即感叹号)</h2><ul>\n<li><strong>!!</strong> – 执行上一条命令</li>\n<li><strong>!blah</strong> –执行最近运行过的以<code>blah</code>开头的命令</li>\n<li><strong>!blah:p</strong> – 打印<code>!blah</code>要执行的命令（并将其作为最后一条命令加入到命令历史中）</li>\n<li><strong>!$</strong> – 上一条命令的最后一个单词 (等同于<code>Alt + .</code>)</li>\n<li><strong>!$:p</strong> – 打印<code>!$</code>指代的单词</li>\n<li><strong>!*</strong> – 上一条命令除最后一个词的部分</li>\n<li><strong>!*:p</strong> – 打印<code>!*</code>指代部分</li>\n</ul>\n<p>如果错误，敬请指正！</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2>"},{"title":"go使用protocbuf","date":"2019-02-17T16:00:00.000Z","_content":"\n1. git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态\n2. git stash #把所有没有提交的修改暂存到stash里面。可用git stash [pop](https://www.baidu.com/s?wd=pop&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)回复。\n3. git reset --hard HASH #返回到某个节点，不保留修改。\n4. git reset --soft HASH #返回到某个节点。\n5. 保留修改git clean -df #返回到某个节点\n6. git clean 参数-n 显示 将要 删除的文件和目录-f 删除 文件-df 删除文件和目录\n\n```bash\n回退命令：\n$ git reset --hard HEAD^         回退到上个版本\n$ git reset --hard HEAD~3        回退到前3次提交之前，以此类推，回退到n次提交之前\n$ git reset --hard commit_id     退到/进到 指定commit的sha码\n\n强推到远程：\n$ git push origin HEAD --force\n```\n\n","source":"_posts/常见问题/云服务器/git常见命令.md","raw":"---\ntitle: go使用protocbuf\ndate: 2019-2-18\ntags:\n- git\n- 云服务器\ncategories:\n- 常见问题\n---\n\n1. git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态\n2. git stash #把所有没有提交的修改暂存到stash里面。可用git stash [pop](https://www.baidu.com/s?wd=pop&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)回复。\n3. git reset --hard HASH #返回到某个节点，不保留修改。\n4. git reset --soft HASH #返回到某个节点。\n5. 保留修改git clean -df #返回到某个节点\n6. git clean 参数-n 显示 将要 删除的文件和目录-f 删除 文件-df 删除文件和目录\n\n```bash\n回退命令：\n$ git reset --hard HEAD^         回退到上个版本\n$ git reset --hard HEAD~3        回退到前3次提交之前，以此类推，回退到n次提交之前\n$ git reset --hard commit_id     退到/进到 指定commit的sha码\n\n强推到远程：\n$ git push origin HEAD --force\n```\n\n","slug":"常见问题/云服务器/git常见命令","published":1,"updated":"2020-01-23T09:28:50.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b7y000l3v8n3rui7k3o","content":"<ol>\n<li>git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态</li>\n<li>git stash #把所有没有提交的修改暂存到stash里面。可用git stash <a href=\"https://www.baidu.com/s?wd=pop&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao\" target=\"_blank\" rel=\"noopener\">pop</a>回复。</li>\n<li>git reset –hard HASH #返回到某个节点，不保留修改。</li>\n<li>git reset –soft HASH #返回到某个节点。</li>\n<li>保留修改git clean -df #返回到某个节点</li>\n<li>git clean 参数-n 显示 将要 删除的文件和目录-f 删除 文件-df 删除文件和目录</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">回退命令：</span><br><span class=\"line\">$ git reset --hard HEAD^         回退到上个版本</span><br><span class=\"line\">$ git reset --hard HEAD~3        回退到前3次提交之前，以此类推，回退到n次提交之前</span><br><span class=\"line\">$ git reset --hard commit_id     退到/进到 指定commit的sha码</span><br><span class=\"line\"></span><br><span class=\"line\">强推到远程：</span><br><span class=\"line\">$ git push origin HEAD --force</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态</li>\n<li>git stash #把所有没有提交的修改暂存到stash里面。可用git stash <a href=\"https://www.baidu.com/s?wd=pop&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao\" target=\"_blank\" rel=\"noopener\">pop</a>回复。</li>\n<li>git reset –hard HASH #返回到某个节点，不保留修改。</li>\n<li>git reset –soft HASH #返回到某个节点。</li>\n<li>保留修改git clean -df #返回到某个节点</li>\n<li>git clean 参数-n 显示 将要 删除的文件和目录-f 删除 文件-df 删除文件和目录</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">回退命令：</span><br><span class=\"line\">$ git reset --hard HEAD^         回退到上个版本</span><br><span class=\"line\">$ git reset --hard HEAD~3        回退到前3次提交之前，以此类推，回退到n次提交之前</span><br><span class=\"line\">$ git reset --hard commit_id     退到/进到 指定commit的sha码</span><br><span class=\"line\"></span><br><span class=\"line\">强推到远程：</span><br><span class=\"line\">$ git push origin HEAD --force</span><br></pre></td></tr></table></figure>\n\n"},{"title":"linux搜索","date":"2018-07-05T16:00:00.000Z","_content":"\n# [Ubuntu的which、whereis、locate和find命令](https://www.cnblogs.com/andrewlee0708/p/Linux_locate.html)\n\n<!-- more -->\n\nwhich 只能寻找执行文件 ，并在PATH变量里面寻找。\n\nwhereis 从linux文件数据库（/var/lib/slocate/slocate.db）寻找，所以有可能找到刚刚删除，或者没有发现新建的文件。\n\nlocate 同上,不过文件名是部分匹配。\n\nfind 是直接在硬盘上搜寻，功能强大，但耗硬盘，一般不要用。","source":"_posts/常见问题/云服务器/linux搜索命令.md","raw":"---\ntitle: linux搜索\ndate: 2018-07-06\ntags:\n- linux\n- 云服务器\ncategories:\n- 常见问题\n---\n\n# [Ubuntu的which、whereis、locate和find命令](https://www.cnblogs.com/andrewlee0708/p/Linux_locate.html)\n\n<!-- more -->\n\nwhich 只能寻找执行文件 ，并在PATH变量里面寻找。\n\nwhereis 从linux文件数据库（/var/lib/slocate/slocate.db）寻找，所以有可能找到刚刚删除，或者没有发现新建的文件。\n\nlocate 同上,不过文件名是部分匹配。\n\nfind 是直接在硬盘上搜寻，功能强大，但耗硬盘，一般不要用。","slug":"常见问题/云服务器/linux搜索命令","published":1,"updated":"2020-01-23T09:29:07.265Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b7z000n3v8ncp3de2gn","content":"<h1 id=\"Ubuntu的which、whereis、locate和find命令\"><a href=\"#Ubuntu的which、whereis、locate和find命令\" class=\"headerlink\" title=\"Ubuntu的which、whereis、locate和find命令\"></a><a href=\"https://www.cnblogs.com/andrewlee0708/p/Linux_locate.html\" target=\"_blank\" rel=\"noopener\">Ubuntu的which、whereis、locate和find命令</a></h1><a id=\"more\"></a>\n\n<p>which 只能寻找执行文件 ，并在PATH变量里面寻找。</p>\n<p>whereis 从linux文件数据库（/var/lib/slocate/slocate.db）寻找，所以有可能找到刚刚删除，或者没有发现新建的文件。</p>\n<p>locate 同上,不过文件名是部分匹配。</p>\n<p>find 是直接在硬盘上搜寻，功能强大，但耗硬盘，一般不要用。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Ubuntu的which、whereis、locate和find命令\"><a href=\"#Ubuntu的which、whereis、locate和find命令\" class=\"headerlink\" title=\"Ubuntu的which、whereis、locate和find命令\"></a><a href=\"https://www.cnblogs.com/andrewlee0708/p/Linux_locate.html\" target=\"_blank\" rel=\"noopener\">Ubuntu的which、whereis、locate和find命令</a></h1>","more":"<p>which 只能寻找执行文件 ，并在PATH变量里面寻找。</p>\n<p>whereis 从linux文件数据库（/var/lib/slocate/slocate.db）寻找，所以有可能找到刚刚删除，或者没有发现新建的文件。</p>\n<p>locate 同上,不过文件名是部分匹配。</p>\n<p>find 是直接在硬盘上搜寻，功能强大，但耗硬盘，一般不要用。</p>"},{"title":"nginx 403报错","date":"2018-08-22T16:00:00.000Z","_content":"\n由于开发需要，在本地环境中配置了LNMP环境，使用的是Centos 6.5 的yum安装，安装一切正常，但是由于默认网站文件夹比较奇葩，于是把网站文件用mv命令移动到了新的目录，并相应修改了配置文件，并重启Nginx。\n\n<!-- more -->\n\n那么好，问题来了！本以为重启就OK了。居然报个“403 is forbidden“的错误。。查看/var/log/nginx/error.log日志显示：xxx 403 forbidden (13: Permission denied)错误。我勒个去~\n\n引起nginx 403 forbidden通常是三种情况：一是缺少索引文件，二是权限问题，三是SELinux状态。\n\n一、缺少index.html或者index.php文件，就是配置文件中index index.html index.htm这行中的指定的文件。\n\n\n\n我是按照腾讯云官网文档进行配置的， 官网上应该给index增加index.php 索引文件，此外最好设置权限","source":"_posts/常见问题/云服务器/nginx403.md","raw":"---\ntitle: nginx 403报错\ndate: 2018-08-23\ntags:\n- linux\n- nginx\n- 云服务器\ncategories:\n- 常见问题\n---\n\n由于开发需要，在本地环境中配置了LNMP环境，使用的是Centos 6.5 的yum安装，安装一切正常，但是由于默认网站文件夹比较奇葩，于是把网站文件用mv命令移动到了新的目录，并相应修改了配置文件，并重启Nginx。\n\n<!-- more -->\n\n那么好，问题来了！本以为重启就OK了。居然报个“403 is forbidden“的错误。。查看/var/log/nginx/error.log日志显示：xxx 403 forbidden (13: Permission denied)错误。我勒个去~\n\n引起nginx 403 forbidden通常是三种情况：一是缺少索引文件，二是权限问题，三是SELinux状态。\n\n一、缺少index.html或者index.php文件，就是配置文件中index index.html index.htm这行中的指定的文件。\n\n\n\n我是按照腾讯云官网文档进行配置的， 官网上应该给index增加index.php 索引文件，此外最好设置权限","slug":"常见问题/云服务器/nginx403","published":1,"updated":"2020-01-23T09:29:15.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b81000r3v8ndvfzenfu","content":"<p>由于开发需要，在本地环境中配置了LNMP环境，使用的是Centos 6.5 的yum安装，安装一切正常，但是由于默认网站文件夹比较奇葩，于是把网站文件用mv命令移动到了新的目录，并相应修改了配置文件，并重启Nginx。</p>\n<a id=\"more\"></a>\n\n<p>那么好，问题来了！本以为重启就OK了。居然报个“403 is forbidden“的错误。。查看/var/log/nginx/error.log日志显示：xxx 403 forbidden (13: Permission denied)错误。我勒个去~</p>\n<p>引起nginx 403 forbidden通常是三种情况：一是缺少索引文件，二是权限问题，三是SELinux状态。</p>\n<p>一、缺少index.html或者index.php文件，就是配置文件中index index.html index.htm这行中的指定的文件。</p>\n<p>我是按照腾讯云官网文档进行配置的， 官网上应该给index增加index.php 索引文件，此外最好设置权限</p>\n","site":{"data":{}},"excerpt":"<p>由于开发需要，在本地环境中配置了LNMP环境，使用的是Centos 6.5 的yum安装，安装一切正常，但是由于默认网站文件夹比较奇葩，于是把网站文件用mv命令移动到了新的目录，并相应修改了配置文件，并重启Nginx。</p>","more":"<p>那么好，问题来了！本以为重启就OK了。居然报个“403 is forbidden“的错误。。查看/var/log/nginx/error.log日志显示：xxx 403 forbidden (13: Permission denied)错误。我勒个去~</p>\n<p>引起nginx 403 forbidden通常是三种情况：一是缺少索引文件，二是权限问题，三是SELinux状态。</p>\n<p>一、缺少index.html或者index.php文件，就是配置文件中index index.html index.htm这行中的指定的文件。</p>\n<p>我是按照腾讯云官网文档进行配置的， 官网上应该给index增加index.php 索引文件，此外最好设置权限</p>"},{"title":"mysql 忘记密码","date":"2018-05-22T16:00:00.000Z","_content":"\n\n\nmysql 忘记密码时，如何进行恢复\n\n<!-- more -->\n\nI. 在终端输入sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf\n\nII. 在[mysqld]下方的skip-external-locking下面添加一行：\n\nskip-grant-tables\n\nIII. 重启MySQL服务：\n\nsudo service mysql restart\n\nIV. 在终端输入命令：mysql 进入mysql\n\nV. 输入USE mysql （切换至mysql数据库）\n\nVI. 将root用户的密码修改为0000：\n\nUPDATE mysql.user SET authentication_string=password('0000') WHERE User='root' AND Host ='localhost';\n\nVII. 修改字段plugin：\n\nUPDATE user SET plugin=\"mysql_native_password\";\n\n（Plugin字段标识可以用于验证用户身份的插件，如果字段为空，服务器使用内建授权验证机制验证用户身份。 ）\n\nVIII. 输入flush privileges;\n\nIX. 输入quit;\n\nX. 把/etc/mysql/mysql.conf.d/mysqld.cnf文件中添加的一行注释掉\n\\--------------------- \n作者：rhanqtlnuse \n来源：CSDN \n原文：https://blog.csdn.net/hq815601489/article/details/78608644 \n版权声明：本文为博主原创文章，转载请附上博文链接！","source":"_posts/常见问题/云服务器/mysql忘记密码.md","raw":"---\ntitle: mysql 忘记密码\ndate: 2018-05-23\ntags:\n- linux\n- mysql\n- 云服务器\ncategories:\n- 常见问题\n---\n\n\n\nmysql 忘记密码时，如何进行恢复\n\n<!-- more -->\n\nI. 在终端输入sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf\n\nII. 在[mysqld]下方的skip-external-locking下面添加一行：\n\nskip-grant-tables\n\nIII. 重启MySQL服务：\n\nsudo service mysql restart\n\nIV. 在终端输入命令：mysql 进入mysql\n\nV. 输入USE mysql （切换至mysql数据库）\n\nVI. 将root用户的密码修改为0000：\n\nUPDATE mysql.user SET authentication_string=password('0000') WHERE User='root' AND Host ='localhost';\n\nVII. 修改字段plugin：\n\nUPDATE user SET plugin=\"mysql_native_password\";\n\n（Plugin字段标识可以用于验证用户身份的插件，如果字段为空，服务器使用内建授权验证机制验证用户身份。 ）\n\nVIII. 输入flush privileges;\n\nIX. 输入quit;\n\nX. 把/etc/mysql/mysql.conf.d/mysqld.cnf文件中添加的一行注释掉\n\\--------------------- \n作者：rhanqtlnuse \n来源：CSDN \n原文：https://blog.csdn.net/hq815601489/article/details/78608644 \n版权声明：本文为博主原创文章，转载请附上博文链接！","slug":"常见问题/云服务器/mysql忘记密码","published":1,"updated":"2020-01-23T09:34:13.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b82000u3v8nhpi5hwkr","content":"<p>mysql 忘记密码时，如何进行恢复</p>\n<a id=\"more\"></a>\n\n<p>I. 在终端输入sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf</p>\n<p>II. 在[mysqld]下方的skip-external-locking下面添加一行：</p>\n<p>skip-grant-tables</p>\n<p>III. 重启MySQL服务：</p>\n<p>sudo service mysql restart</p>\n<p>IV. 在终端输入命令：mysql 进入mysql</p>\n<p>V. 输入USE mysql （切换至mysql数据库）</p>\n<p>VI. 将root用户的密码修改为0000：</p>\n<p>UPDATE mysql.user SET authentication_string=password(‘0000’) WHERE User=’root’ AND Host =’localhost’;</p>\n<p>VII. 修改字段plugin：</p>\n<p>UPDATE user SET plugin=”mysql_native_password”;</p>\n<p>（Plugin字段标识可以用于验证用户身份的插件，如果字段为空，服务器使用内建授权验证机制验证用户身份。 ）</p>\n<p>VIII. 输入flush privileges;</p>\n<p>IX. 输入quit;</p>\n<p>X. 把/etc/mysql/mysql.conf.d/mysqld.cnf文件中添加的一行注释掉<br>-——————–<br>作者：rhanqtlnuse<br>来源：CSDN<br>原文：<a href=\"https://blog.csdn.net/hq815601489/article/details/78608644\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hq815601489/article/details/78608644</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>\n","site":{"data":{}},"excerpt":"<p>mysql 忘记密码时，如何进行恢复</p>","more":"<p>I. 在终端输入sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf</p>\n<p>II. 在[mysqld]下方的skip-external-locking下面添加一行：</p>\n<p>skip-grant-tables</p>\n<p>III. 重启MySQL服务：</p>\n<p>sudo service mysql restart</p>\n<p>IV. 在终端输入命令：mysql 进入mysql</p>\n<p>V. 输入USE mysql （切换至mysql数据库）</p>\n<p>VI. 将root用户的密码修改为0000：</p>\n<p>UPDATE mysql.user SET authentication_string=password(‘0000’) WHERE User=’root’ AND Host =’localhost’;</p>\n<p>VII. 修改字段plugin：</p>\n<p>UPDATE user SET plugin=”mysql_native_password”;</p>\n<p>（Plugin字段标识可以用于验证用户身份的插件，如果字段为空，服务器使用内建授权验证机制验证用户身份。 ）</p>\n<p>VIII. 输入flush privileges;</p>\n<p>IX. 输入quit;</p>\n<p>X. 把/etc/mysql/mysql.conf.d/mysqld.cnf文件中添加的一行注释掉<br>-——————–<br>作者：rhanqtlnuse<br>来源：CSDN<br>原文：<a href=\"https://blog.csdn.net/hq815601489/article/details/78608644\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hq815601489/article/details/78608644</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>"},{"title":"访问php直接下载，而不是访问","date":"2018-08-22T16:00:00.000Z","_content":"\n遇到这种问题，首先确认你web服务器配置中的.php是不是被指定给FastCGI server处理：\n\n<!-- more -->\n\nlocation ~ .php$ {\nfastcgi_pass 127.0.0.1:9000;\n\n}\n\n如已配置，那么可能是由于fastcgi_script_name访问脚本路径不正确引起的。\n\n尤其是带有子目录的情况，比如对于Yii框架而言，路径通常是project/web\n\n那么如果在URL中访问 /project/index.php，那么nginx配置中的SCRIPT_NAME会是全路径：project/index.php\n\n如果你配置中的代码如下：\n\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n\n那么实际访问的文件就是/var/site_root/project/web/project/index.php，这显然不是我们想要的结果，我们想访问的是/project/web/index.php。\n\n这些错误可以通过查看php-fpm.log（错误日志）来跟踪。\n\n解决方法是修改相应的路径配置。\n\n此时我们先在查看下错误日志 error.log，发现里面都是清一色的报错：\n\n\n\nconnect() failed (111: Connection refused) while connecting to upstream ......   fastcgi://127.0.0.1:9000 ......\n\n\n提示的意思就是说连接不上9000端口，这就奇怪了，其实在平时配置nginx的server里面，大部分应该都是配置127.0.0.1:9000 作为分发端口。\n\n\n现在需要查看一下是否有监听9000端口：\n\n\n[root@izwz9glf2r6p2z8ytslvblz /]# netstat -ant | grep 9000\n发现并没有监听到，但实际上我们的php-fpm已经启动，那现在怎么办呢？\n我们去查看一下php-fpm.conf里面的配置：\n\n\n[root@izwz9glf2r6p2z8ytslvblz /]# vim /usr/local/php/etc/php-fpm.conf\n\n\n找到listen：\n<value name=\"listen_address\">/tmp/php-cgi.sock</value>\n\n\n\n此时我们需要根据配置文件的listen地址做对应的修改：\n\n\nlocation ~ \\.php$ {\nfastcgi_pass 127.0.0.1:9000;\nfastcgi_index index.php;\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\ninclude fastcgi_params;\n\n\n}\n\n\n\n改成：\nlocation ~ \\.php$ {\nfastcgi_pass unix:/tmp/php-cgi.sock;\nfastcgi_index index.php;\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\ninclude fastcgi_params;\n}\n\n\n重启nginx。访问成功。","source":"_posts/常见问题/云服务器/访问php直接下载.md","raw":"---\ntitle: 访问php直接下载，而不是访问\ndate: 2018-08-23\ntags:\n- linux\n- nginx\n- php\n- 云服务器\ncategories:\n- 常见问题\n---\n\n遇到这种问题，首先确认你web服务器配置中的.php是不是被指定给FastCGI server处理：\n\n<!-- more -->\n\nlocation ~ .php$ {\nfastcgi_pass 127.0.0.1:9000;\n\n}\n\n如已配置，那么可能是由于fastcgi_script_name访问脚本路径不正确引起的。\n\n尤其是带有子目录的情况，比如对于Yii框架而言，路径通常是project/web\n\n那么如果在URL中访问 /project/index.php，那么nginx配置中的SCRIPT_NAME会是全路径：project/index.php\n\n如果你配置中的代码如下：\n\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n\n那么实际访问的文件就是/var/site_root/project/web/project/index.php，这显然不是我们想要的结果，我们想访问的是/project/web/index.php。\n\n这些错误可以通过查看php-fpm.log（错误日志）来跟踪。\n\n解决方法是修改相应的路径配置。\n\n此时我们先在查看下错误日志 error.log，发现里面都是清一色的报错：\n\n\n\nconnect() failed (111: Connection refused) while connecting to upstream ......   fastcgi://127.0.0.1:9000 ......\n\n\n提示的意思就是说连接不上9000端口，这就奇怪了，其实在平时配置nginx的server里面，大部分应该都是配置127.0.0.1:9000 作为分发端口。\n\n\n现在需要查看一下是否有监听9000端口：\n\n\n[root@izwz9glf2r6p2z8ytslvblz /]# netstat -ant | grep 9000\n发现并没有监听到，但实际上我们的php-fpm已经启动，那现在怎么办呢？\n我们去查看一下php-fpm.conf里面的配置：\n\n\n[root@izwz9glf2r6p2z8ytslvblz /]# vim /usr/local/php/etc/php-fpm.conf\n\n\n找到listen：\n<value name=\"listen_address\">/tmp/php-cgi.sock</value>\n\n\n\n此时我们需要根据配置文件的listen地址做对应的修改：\n\n\nlocation ~ \\.php$ {\nfastcgi_pass 127.0.0.1:9000;\nfastcgi_index index.php;\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\ninclude fastcgi_params;\n\n\n}\n\n\n\n改成：\nlocation ~ \\.php$ {\nfastcgi_pass unix:/tmp/php-cgi.sock;\nfastcgi_index index.php;\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\ninclude fastcgi_params;\n}\n\n\n重启nginx。访问成功。","slug":"常见问题/云服务器/访问php直接下载","published":1,"updated":"2020-01-23T09:28:44.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b83000y3v8nb9th7c7r","content":"<p>遇到这种问题，首先确认你web服务器配置中的.php是不是被指定给FastCGI server处理：</p>\n<a id=\"more\"></a>\n\n<p>location ~ .php$ {<br>fastcgi_pass 127.0.0.1:9000;</p>\n<p>}</p>\n<p>如已配置，那么可能是由于fastcgi_script_name访问脚本路径不正确引起的。</p>\n<p>尤其是带有子目录的情况，比如对于Yii框架而言，路径通常是project/web</p>\n<p>那么如果在URL中访问 /project/index.php，那么nginx配置中的SCRIPT_NAME会是全路径：project/index.php</p>\n<p>如果你配置中的代码如下：</p>\n<p>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</p>\n<p>那么实际访问的文件就是/var/site_root/project/web/project/index.php，这显然不是我们想要的结果，我们想访问的是/project/web/index.php。</p>\n<p>这些错误可以通过查看php-fpm.log（错误日志）来跟踪。</p>\n<p>解决方法是修改相应的路径配置。</p>\n<p>此时我们先在查看下错误日志 error.log，发现里面都是清一色的报错：</p>\n<p>connect() failed (111: Connection refused) while connecting to upstream ……   fastcgi://127.0.0.1:9000 ……</p>\n<p>提示的意思就是说连接不上9000端口，这就奇怪了，其实在平时配置nginx的server里面，大部分应该都是配置127.0.0.1:9000 作为分发端口。</p>\n<p>现在需要查看一下是否有监听9000端口：</p>\n<p>[root@izwz9glf2r6p2z8ytslvblz /]# netstat -ant | grep 9000<br>发现并没有监听到，但实际上我们的php-fpm已经启动，那现在怎么办呢？<br>我们去查看一下php-fpm.conf里面的配置：</p>\n<p>[root@izwz9glf2r6p2z8ytslvblz /]# vim /usr/local/php/etc/php-fpm.conf</p>\n<p>找到listen：<br><value name=\"listen_address\">/tmp/php-cgi.sock</value></p>\n<p>此时我们需要根据配置文件的listen地址做对应的修改：</p>\n<p>location ~ .php$ {<br>fastcgi_pass 127.0.0.1:9000;<br>fastcgi_index index.php;<br>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br>include fastcgi_params;</p>\n<p>}</p>\n<p>改成：<br>location ~ .php$ {<br>fastcgi_pass unix:/tmp/php-cgi.sock;<br>fastcgi_index index.php;<br>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br>include fastcgi_params;<br>}</p>\n<p>重启nginx。访问成功。</p>\n","site":{"data":{}},"excerpt":"<p>遇到这种问题，首先确认你web服务器配置中的.php是不是被指定给FastCGI server处理：</p>","more":"<p>location ~ .php$ {<br>fastcgi_pass 127.0.0.1:9000;</p>\n<p>}</p>\n<p>如已配置，那么可能是由于fastcgi_script_name访问脚本路径不正确引起的。</p>\n<p>尤其是带有子目录的情况，比如对于Yii框架而言，路径通常是project/web</p>\n<p>那么如果在URL中访问 /project/index.php，那么nginx配置中的SCRIPT_NAME会是全路径：project/index.php</p>\n<p>如果你配置中的代码如下：</p>\n<p>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</p>\n<p>那么实际访问的文件就是/var/site_root/project/web/project/index.php，这显然不是我们想要的结果，我们想访问的是/project/web/index.php。</p>\n<p>这些错误可以通过查看php-fpm.log（错误日志）来跟踪。</p>\n<p>解决方法是修改相应的路径配置。</p>\n<p>此时我们先在查看下错误日志 error.log，发现里面都是清一色的报错：</p>\n<p>connect() failed (111: Connection refused) while connecting to upstream ……   fastcgi://127.0.0.1:9000 ……</p>\n<p>提示的意思就是说连接不上9000端口，这就奇怪了，其实在平时配置nginx的server里面，大部分应该都是配置127.0.0.1:9000 作为分发端口。</p>\n<p>现在需要查看一下是否有监听9000端口：</p>\n<p>[root@izwz9glf2r6p2z8ytslvblz /]# netstat -ant | grep 9000<br>发现并没有监听到，但实际上我们的php-fpm已经启动，那现在怎么办呢？<br>我们去查看一下php-fpm.conf里面的配置：</p>\n<p>[root@izwz9glf2r6p2z8ytslvblz /]# vim /usr/local/php/etc/php-fpm.conf</p>\n<p>找到listen：<br><value name=\"listen_address\">/tmp/php-cgi.sock</value></p>\n<p>此时我们需要根据配置文件的listen地址做对应的修改：</p>\n<p>location ~ .php$ {<br>fastcgi_pass 127.0.0.1:9000;<br>fastcgi_index index.php;<br>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br>include fastcgi_params;</p>\n<p>}</p>\n<p>改成：<br>location ~ .php$ {<br>fastcgi_pass unix:/tmp/php-cgi.sock;<br>fastcgi_index index.php;<br>fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br>include fastcgi_params;<br>}</p>\n<p>重启nginx。访问成功。</p>"},{"title":"配置mysql远程访问","date":"2018-09-05T16:00:00.000Z","_content":"\n1.使用yum命令安装mysql\n\n```\n[root@bogon ~]#  yum -y install mysql-server  \n```\n\n<!-- more -->\n\n2.设置开机启动\n\n```\n[root@bogon ~]#  chkconfig mysqld on \n```\n\n3.启动MySQL服务\n\n```\n[root@bogon ~]#  service mysqld start  \n```\n\n4.设置MySQL的root用户设置密码\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```\n[root@bogon ~]#  mysql -u root  \nmysql> select user,host,password from mysql.user;  \n+------+-----------+----------+  \n| user | host      | password |  \n+------+-----------+----------+  \n| root | localhost |          |  \n| root | bogon     |          |  \n| root | 127.0.0.1 |          |  \n|      | localhost |          |  \n|      | bogon     |          |  \n+------+-----------+----------+  \n5 rows in set (0.01 sec)  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n查询用户的密码，都为空，用下面的命令设置root的密码为root\n\n```mysql\nmysql> set password for root@localhost=password('root');  \nmysql> exit  \n```\n\n6.创建mysql新用户test_user\n\n```\nmysql> create user 'test_user'@'%' identified by 'test_user';  \nQuery OK, 0 rows affected (0.00 sec) \n```\n\n7.给新用户test_user授权，让他可以从外部登陆和本地登陆\n注意：@左边是用户名，右边是域名、IP和%，表示可以访问mysql的域名和IP，%表示外部任何地址都能访问。\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```\nmysql> grant all privileges on *.* to 'test_user'@'localhost' identified by 'test_user';  \nQuery OK, 0 rows affected (0.00 sec)  \nmysql> grant all privileges on *.* to 'test_user'@'%' identified by 'test_user';  \nQuery OK, 0 rows affected (0.00 sec)  \nmysql> select user,host,password from mysql.user;  \n+----------+-----------+-------------------------------------------+  \n| user     | host      | password                                  |  \n+----------+-----------+-------------------------------------------+  \n| root     | localhost | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |  \n| root     | bogon     |                                           |  \n| root     | 127.0.0.1 |                                           |  \n|          | localhost |                                           |  \n|          | bogon     |                                           |  \n| test_user | %         | *3046CF87132BBD4FDDF06F321C6859074843B7D3 |  \n| test_user | localhost | *3046CF87132BBD4FDDF06F321C6859074843B7D3 |  \n+----------+-----------+-------------------------------------------+  \n7 rows in set (0.00 sec)  \nmysql> flush privileges;  \nQuery OK, 0 rows affected (0.01 sec)  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n8.查看mysql5.1的默认存储引擎\n从下面的执行结果可以看出，mysql的默认引擎是MyISAM，这个引擎是不支持事务的。\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```mysql\nmysql> show engines;  \n+------------+---------+------------------------------------------------------------+--------------+------+------------+  \n| Engine     | Support | Comment                                                    | Transactions | XA   | Savepoints |  \n+------------+---------+------------------------------------------------------------+--------------+------+------------+  \n| MRG_MYISAM | YES     | Collection of identical MyISAM tables                      | NO           | NO   | NO         |  \n| CSV        | YES     | CSV storage engine                                         | NO           | NO   | NO         |  \n| MyISAM     | DEFAULT | Default engine as of MySQL 3.23 with great performance     | NO           | NO   | NO         |  \n| InnoDB     | YES     | Supports transactions, row-level locking, and foreign keys | YES          | YES  | YES        |  \n| MEMORY     | YES     | Hash based, stored in memory, useful for temporary tables  | NO           | NO   | NO         |  \n+------------+---------+------------------------------------------------------------+--------------+------+------------+  \n5 rows in set (0.00 sec)  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n也可以以下面的方式查看\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```mysql\nmysql> show variables like 'storage_engine';  \n+----------------+--------+  \n| Variable_name  | Value  |  \n+----------------+--------+  \n| storage_engine | MyISAM |  \n+----------------+--------+  \n1 row in set (0.00 sec)  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n9.修改mysql的默认引擎为InnoDB\n9.1 停止mysql\n\n```mysql\nmysql> exit;  \n[root@bogon ~]# service mysqld stop  \n```\n\n9.2 修改/etc/my.cnf\n[mysqld] 后加入\n\n```bash\ndefault-storage-engine=InnoDB  \n```\n\n加入后my.cnf的内容为：\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```bash\n[root@bogon etc]# more my.cnf  \n[mysqld]  \ndatadir=/var/lib/mysql  \nsocket=/var/lib/mysql/mysql.sock  \nuser=mysql  \n# Disabling symbolic-links is recommended to prevent assorted security risks  \nsymbolic-links=0  \n  \ndefault-storage-engine=InnoDB  \n  \n[mysqld_safe]  \nlog-error=/var/log/mysqld.log  \npid-file=/var/run/mysqld/mysqld.pid  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n9.3 启动mysql\n\n```bash\n[root@bogon etc]# service mysqld start  \nStarting mysqld:  [  OK  ] \n```\n\n9.4 查看mysql默认存储引擎\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```mysql\n[root@bogon etc]# mysql -u root -p  \nEnter password:   \nWelcome to the MySQL monitor.  Commands end with ; or \\g.  \nYour MySQL connection id is 2  \nServer version: 5.1.73 Source distribution  \n  \nCopyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.  \n  \nOracle is a registered trademark of Oracle Corporation and/or its  \naffiliates. Other names may be trademarks of their respective  \nowners.  \n  \nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.  \n  \nmysql> show variables like 'storage_engine';  \n+----------------+--------+  \n| Variable_name  | Value  |  \n+----------------+--------+  \n| storage_engine | InnoDB |  \n+----------------+--------+  \n1 row in set (0.00 sec)  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n10.CentOS6.5开放mysql端口3306\nCentOS6.5默认是不开放端口的，如果要让外部的系统访问CentOS6.5上的mysql，必须开放mysql的端口3306\n10.1 修改/etc/sysconfig/iptables\n添加下面一行\n\n```mysql\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT \n```\n\n修改后iptables中的内容是\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```mysql\n[root@bogon etc]# more /etc/sysconfig/iptables  \n# Firewall configuration written by system-config-firewall  \n# Manual customization of this file is not recommended.  \n*filter  \n:INPUT ACCEPT [0:0]  \n:FORWARD ACCEPT [0:0]  \n:OUTPUT ACCEPT [0:0]  \n-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT  \n-A INPUT -p icmp -j ACCEPT  \n-A INPUT -i lo -j ACCEPT  \n-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT  \n#添加配置项  \n-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT  \n-A INPUT -m state --state NEW -m tcp -p tcp --dport 11211 -j ACCEPT  \n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT  \n-A INPUT -j REJECT --reject-with icmp-host-prohibited  \n-A FORWARD -j REJECT --reject-with icmp-host-prohibited  \n  \nCOMMIT  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n11.重启防火墙\n\n```bash\n[root@bogon etc]# service iptables restart \n```\n\n这样就可以从外部访问mysql了。\n\n至此，mysql在CentOS6.5上的安装过程、用户创建、外部访问的步骤全部完成。\n\n \n\n—————————分割线—————————————\n\n上面都是从别人发表的文章中截取的~~~作者要是看到了莫怪，我只是想收藏，怕源文被删就看不到了，谢谢你们这些摘树的前人。\n\n其实这样在云主机上设置mysql并访问是OK的。适用于一切的centos6.5，亦或者其他linux系统。万变不离其宗，系统的改变，无非是命令行语言的改变，其宗旨是不会变的。\n\n \n\nLZ第一次用云主机，想试试在本地远程访问一下，结果发现，咦，连接出错了~~~，后来试了很多方法，还是没有能成功。\n\n刚开始，用Navicat连接远程数据库，出现如下错误：应该就是远程不允许访问了。\n\n![img](https://app.yinxiang.com/shard/s37/res/1697e3b0-837f-41b0-8baa-8e4578dda4c8.png)\n\n远程拒绝访问的情况可能有两种：\n\n一、mysql设置中，不允许远程访问.也即你使用的mysql登陆账号没有远程访问的权限。比如root账号，在我们之前看到的use权限列表中，root就没有远程访问的权限。现在来设置root的远程访问权限。\n\n方法一：实现远程连接(授权法)\n\nmysql> use mysql;\n\nDatabase changed\n\nmysql> grant all privileges  on *.* to root@'%' identified by \"root\";\n\nmysql> select host,user,password from user;\n\n+--------------+------+-------------------------------------------+\n\n| host     | user | password                  |\n\n+--------------+------+-------------------------------------------+\n\n| localhost   | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |\n\n| 192.168.1.1 | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |\n\n| %       | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |\n\n+--------------+------+-------------------------------------------+\n\n3 rows in set (0.00 sec)\n\n这样机器就可以以用户名root密码root远程访问该机器上的MySql.\n\n方法二：实现远程连接（改表法）\n\n将host字段的值改为%就表示在任何客户端机器上能以root用户登录到mysql服务器，建议在开发时设为%。 \n\nmysql> use mysql;\n\nDatabase changed\n\nmysql> update user set host = '%' where user = 'root';\n\n这时，root将权限改为ALL PRIVILEGES；\n\n这样在远端就可以通过root用户访问Mysql.\n\n二、确定服务器上的防火墙没有阻止 3306 端口。也即服务器上面有没有开放mysql的端口~（我的就是这个问题）\n\n　　看到上面的第10条中，在端口管理iptables中添加3306端口的开放配置，这样算是硬件的配置。然后看看你的云主机设置里面有没有开放对应的端口，或者说是不是开放了所有端口~我的云主机如下图：\n\n![img](https://app.yinxiang.com/shard/s37/res/5269b539-f016-491c-b76c-a43e8e5833d5.png)![img](https://app.yinxiang.com/shard/s37/res/900f746d-0def-457f-92df-c08e0894825d.png)\n\n腾讯云主机中，貌似是没有开放所有端口的，所以需要我们自己在这里稍微设置一下，勾选“默认安全组放通全部端口”选项，“确定”。基本上，我们能做的都做了，要不然就是配置文件出错了，再返回去看看。设置好了以后，我去试了一下连接，结果成功了~\n\n![img](https://app.yinxiang.com/shard/s37/res/a5e1fa91-d624-48e2-95fd-9b9e261f5b65.png)\n\n哈哈，好高兴~以后遇到这些问题就知道在哪些地方找问题了~~~","source":"_posts/常见问题/云服务器/配置mysql远程访问权限.md","raw":"---\ntitle: 配置mysql远程访问\ndate: 2018-09-06\ntags:\n- linux\n- 云服务器\n- mysql\ncategories:\n- 常见问题\n---\n\n1.使用yum命令安装mysql\n\n```\n[root@bogon ~]#  yum -y install mysql-server  \n```\n\n<!-- more -->\n\n2.设置开机启动\n\n```\n[root@bogon ~]#  chkconfig mysqld on \n```\n\n3.启动MySQL服务\n\n```\n[root@bogon ~]#  service mysqld start  \n```\n\n4.设置MySQL的root用户设置密码\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```\n[root@bogon ~]#  mysql -u root  \nmysql> select user,host,password from mysql.user;  \n+------+-----------+----------+  \n| user | host      | password |  \n+------+-----------+----------+  \n| root | localhost |          |  \n| root | bogon     |          |  \n| root | 127.0.0.1 |          |  \n|      | localhost |          |  \n|      | bogon     |          |  \n+------+-----------+----------+  \n5 rows in set (0.01 sec)  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n查询用户的密码，都为空，用下面的命令设置root的密码为root\n\n```mysql\nmysql> set password for root@localhost=password('root');  \nmysql> exit  \n```\n\n6.创建mysql新用户test_user\n\n```\nmysql> create user 'test_user'@'%' identified by 'test_user';  \nQuery OK, 0 rows affected (0.00 sec) \n```\n\n7.给新用户test_user授权，让他可以从外部登陆和本地登陆\n注意：@左边是用户名，右边是域名、IP和%，表示可以访问mysql的域名和IP，%表示外部任何地址都能访问。\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```\nmysql> grant all privileges on *.* to 'test_user'@'localhost' identified by 'test_user';  \nQuery OK, 0 rows affected (0.00 sec)  \nmysql> grant all privileges on *.* to 'test_user'@'%' identified by 'test_user';  \nQuery OK, 0 rows affected (0.00 sec)  \nmysql> select user,host,password from mysql.user;  \n+----------+-----------+-------------------------------------------+  \n| user     | host      | password                                  |  \n+----------+-----------+-------------------------------------------+  \n| root     | localhost | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |  \n| root     | bogon     |                                           |  \n| root     | 127.0.0.1 |                                           |  \n|          | localhost |                                           |  \n|          | bogon     |                                           |  \n| test_user | %         | *3046CF87132BBD4FDDF06F321C6859074843B7D3 |  \n| test_user | localhost | *3046CF87132BBD4FDDF06F321C6859074843B7D3 |  \n+----------+-----------+-------------------------------------------+  \n7 rows in set (0.00 sec)  \nmysql> flush privileges;  \nQuery OK, 0 rows affected (0.01 sec)  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n8.查看mysql5.1的默认存储引擎\n从下面的执行结果可以看出，mysql的默认引擎是MyISAM，这个引擎是不支持事务的。\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```mysql\nmysql> show engines;  \n+------------+---------+------------------------------------------------------------+--------------+------+------------+  \n| Engine     | Support | Comment                                                    | Transactions | XA   | Savepoints |  \n+------------+---------+------------------------------------------------------------+--------------+------+------------+  \n| MRG_MYISAM | YES     | Collection of identical MyISAM tables                      | NO           | NO   | NO         |  \n| CSV        | YES     | CSV storage engine                                         | NO           | NO   | NO         |  \n| MyISAM     | DEFAULT | Default engine as of MySQL 3.23 with great performance     | NO           | NO   | NO         |  \n| InnoDB     | YES     | Supports transactions, row-level locking, and foreign keys | YES          | YES  | YES        |  \n| MEMORY     | YES     | Hash based, stored in memory, useful for temporary tables  | NO           | NO   | NO         |  \n+------------+---------+------------------------------------------------------------+--------------+------+------------+  \n5 rows in set (0.00 sec)  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n也可以以下面的方式查看\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```mysql\nmysql> show variables like 'storage_engine';  \n+----------------+--------+  \n| Variable_name  | Value  |  \n+----------------+--------+  \n| storage_engine | MyISAM |  \n+----------------+--------+  \n1 row in set (0.00 sec)  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n9.修改mysql的默认引擎为InnoDB\n9.1 停止mysql\n\n```mysql\nmysql> exit;  \n[root@bogon ~]# service mysqld stop  \n```\n\n9.2 修改/etc/my.cnf\n[mysqld] 后加入\n\n```bash\ndefault-storage-engine=InnoDB  \n```\n\n加入后my.cnf的内容为：\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```bash\n[root@bogon etc]# more my.cnf  \n[mysqld]  \ndatadir=/var/lib/mysql  \nsocket=/var/lib/mysql/mysql.sock  \nuser=mysql  \n# Disabling symbolic-links is recommended to prevent assorted security risks  \nsymbolic-links=0  \n  \ndefault-storage-engine=InnoDB  \n  \n[mysqld_safe]  \nlog-error=/var/log/mysqld.log  \npid-file=/var/run/mysqld/mysqld.pid  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n9.3 启动mysql\n\n```bash\n[root@bogon etc]# service mysqld start  \nStarting mysqld:  [  OK  ] \n```\n\n9.4 查看mysql默认存储引擎\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```mysql\n[root@bogon etc]# mysql -u root -p  \nEnter password:   \nWelcome to the MySQL monitor.  Commands end with ; or \\g.  \nYour MySQL connection id is 2  \nServer version: 5.1.73 Source distribution  \n  \nCopyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.  \n  \nOracle is a registered trademark of Oracle Corporation and/or its  \naffiliates. Other names may be trademarks of their respective  \nowners.  \n  \nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.  \n  \nmysql> show variables like 'storage_engine';  \n+----------------+--------+  \n| Variable_name  | Value  |  \n+----------------+--------+  \n| storage_engine | InnoDB |  \n+----------------+--------+  \n1 row in set (0.00 sec)  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n10.CentOS6.5开放mysql端口3306\nCentOS6.5默认是不开放端口的，如果要让外部的系统访问CentOS6.5上的mysql，必须开放mysql的端口3306\n10.1 修改/etc/sysconfig/iptables\n添加下面一行\n\n```mysql\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT \n```\n\n修改后iptables中的内容是\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n```mysql\n[root@bogon etc]# more /etc/sysconfig/iptables  \n# Firewall configuration written by system-config-firewall  \n# Manual customization of this file is not recommended.  \n*filter  \n:INPUT ACCEPT [0:0]  \n:FORWARD ACCEPT [0:0]  \n:OUTPUT ACCEPT [0:0]  \n-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT  \n-A INPUT -p icmp -j ACCEPT  \n-A INPUT -i lo -j ACCEPT  \n-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT  \n#添加配置项  \n-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT  \n-A INPUT -m state --state NEW -m tcp -p tcp --dport 11211 -j ACCEPT  \n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT  \n-A INPUT -j REJECT --reject-with icmp-host-prohibited  \n-A FORWARD -j REJECT --reject-with icmp-host-prohibited  \n  \nCOMMIT  \n```\n\n![复制代码](https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif)\n\n11.重启防火墙\n\n```bash\n[root@bogon etc]# service iptables restart \n```\n\n这样就可以从外部访问mysql了。\n\n至此，mysql在CentOS6.5上的安装过程、用户创建、外部访问的步骤全部完成。\n\n \n\n—————————分割线—————————————\n\n上面都是从别人发表的文章中截取的~~~作者要是看到了莫怪，我只是想收藏，怕源文被删就看不到了，谢谢你们这些摘树的前人。\n\n其实这样在云主机上设置mysql并访问是OK的。适用于一切的centos6.5，亦或者其他linux系统。万变不离其宗，系统的改变，无非是命令行语言的改变，其宗旨是不会变的。\n\n \n\nLZ第一次用云主机，想试试在本地远程访问一下，结果发现，咦，连接出错了~~~，后来试了很多方法，还是没有能成功。\n\n刚开始，用Navicat连接远程数据库，出现如下错误：应该就是远程不允许访问了。\n\n![img](https://app.yinxiang.com/shard/s37/res/1697e3b0-837f-41b0-8baa-8e4578dda4c8.png)\n\n远程拒绝访问的情况可能有两种：\n\n一、mysql设置中，不允许远程访问.也即你使用的mysql登陆账号没有远程访问的权限。比如root账号，在我们之前看到的use权限列表中，root就没有远程访问的权限。现在来设置root的远程访问权限。\n\n方法一：实现远程连接(授权法)\n\nmysql> use mysql;\n\nDatabase changed\n\nmysql> grant all privileges  on *.* to root@'%' identified by \"root\";\n\nmysql> select host,user,password from user;\n\n+--------------+------+-------------------------------------------+\n\n| host     | user | password                  |\n\n+--------------+------+-------------------------------------------+\n\n| localhost   | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |\n\n| 192.168.1.1 | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |\n\n| %       | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |\n\n+--------------+------+-------------------------------------------+\n\n3 rows in set (0.00 sec)\n\n这样机器就可以以用户名root密码root远程访问该机器上的MySql.\n\n方法二：实现远程连接（改表法）\n\n将host字段的值改为%就表示在任何客户端机器上能以root用户登录到mysql服务器，建议在开发时设为%。 \n\nmysql> use mysql;\n\nDatabase changed\n\nmysql> update user set host = '%' where user = 'root';\n\n这时，root将权限改为ALL PRIVILEGES；\n\n这样在远端就可以通过root用户访问Mysql.\n\n二、确定服务器上的防火墙没有阻止 3306 端口。也即服务器上面有没有开放mysql的端口~（我的就是这个问题）\n\n　　看到上面的第10条中，在端口管理iptables中添加3306端口的开放配置，这样算是硬件的配置。然后看看你的云主机设置里面有没有开放对应的端口，或者说是不是开放了所有端口~我的云主机如下图：\n\n![img](https://app.yinxiang.com/shard/s37/res/5269b539-f016-491c-b76c-a43e8e5833d5.png)![img](https://app.yinxiang.com/shard/s37/res/900f746d-0def-457f-92df-c08e0894825d.png)\n\n腾讯云主机中，貌似是没有开放所有端口的，所以需要我们自己在这里稍微设置一下，勾选“默认安全组放通全部端口”选项，“确定”。基本上，我们能做的都做了，要不然就是配置文件出错了，再返回去看看。设置好了以后，我去试了一下连接，结果成功了~\n\n![img](https://app.yinxiang.com/shard/s37/res/a5e1fa91-d624-48e2-95fd-9b9e261f5b65.png)\n\n哈哈，好高兴~以后遇到这些问题就知道在哪些地方找问题了~~~","slug":"常见问题/云服务器/配置mysql远程访问权限","published":1,"updated":"2020-01-23T09:34:37.632Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b8400113v8n58eqbqey","content":"<p>1.使用yum命令安装mysql</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon ~]#  yum -y install mysql-server</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<p>2.设置开机启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon ~]#  chkconfig mysqld on</span><br></pre></td></tr></table></figure>\n\n<p>3.启动MySQL服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon ~]#  service mysqld start</span><br></pre></td></tr></table></figure>\n\n<p>4.设置MySQL的root用户设置密码</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon ~]#  mysql -u root  </span><br><span class=\"line\">mysql&gt; select user,host,password from mysql.user;  </span><br><span class=\"line\">+------+-----------+----------+  </span><br><span class=\"line\">| user | host      | password |  </span><br><span class=\"line\">+------+-----------+----------+  </span><br><span class=\"line\">| root | localhost |          |  </span><br><span class=\"line\">| root | bogon     |          |  </span><br><span class=\"line\">| root | 127.0.0.1 |          |  </span><br><span class=\"line\">|      | localhost |          |  </span><br><span class=\"line\">|      | bogon     |          |  </span><br><span class=\"line\">+------+-----------+----------+  </span><br><span class=\"line\">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>查询用户的密码，都为空，用下面的命令设置root的密码为root</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set password for root@localhost&#x3D;password(&#39;root&#39;);  </span><br><span class=\"line\">mysql&gt; exit</span><br></pre></td></tr></table></figure>\n\n<p>6.创建mysql新用户test_user</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create user &#39;test_user&#39;@&#39;%&#39; identified by &#39;test_user&#39;;  </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>7.给新用户test_user授权，让他可以从外部登陆和本地登陆<br>注意：@左边是用户名，右边是域名、IP和%，表示可以访问mysql的域名和IP，%表示外部任何地址都能访问。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; grant all privileges on *.* to &#39;test_user&#39;@&#39;localhost&#39; identified by &#39;test_user&#39;;  </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)  </span><br><span class=\"line\">mysql&gt; grant all privileges on *.* to &#39;test_user&#39;@&#39;%&#39; identified by &#39;test_user&#39;;  </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)  </span><br><span class=\"line\">mysql&gt; select user,host,password from mysql.user;  </span><br><span class=\"line\">+----------+-----------+-------------------------------------------+  </span><br><span class=\"line\">| user     | host      | password                                  |  </span><br><span class=\"line\">+----------+-----------+-------------------------------------------+  </span><br><span class=\"line\">| root     | localhost | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |  </span><br><span class=\"line\">| root     | bogon     |                                           |  </span><br><span class=\"line\">| root     | 127.0.0.1 |                                           |  </span><br><span class=\"line\">|          | localhost |                                           |  </span><br><span class=\"line\">|          | bogon     |                                           |  </span><br><span class=\"line\">| test_user | %         | *3046CF87132BBD4FDDF06F321C6859074843B7D3 |  </span><br><span class=\"line\">| test_user | localhost | *3046CF87132BBD4FDDF06F321C6859074843B7D3 |  </span><br><span class=\"line\">+----------+-----------+-------------------------------------------+  </span><br><span class=\"line\">7 rows in set (0.00 sec)  </span><br><span class=\"line\">mysql&gt; flush privileges;  </span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>8.查看mysql5.1的默认存储引擎<br>从下面的执行结果可以看出，mysql的默认引擎是MyISAM，这个引擎是不支持事务的。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show engines;  </span><br><span class=\"line\">+------------+---------+------------------------------------------------------------+--------------+------+------------+  </span><br><span class=\"line\">| Engine     | Support | Comment                                                    | Transactions | XA   | Savepoints |  </span><br><span class=\"line\">+------------+---------+------------------------------------------------------------+--------------+------+------------+  </span><br><span class=\"line\">| MRG_MYISAM | YES     | Collection of identical MyISAM tables                      | NO           | NO   | NO         |  </span><br><span class=\"line\">| CSV        | YES     | CSV storage engine                                         | NO           | NO   | NO         |  </span><br><span class=\"line\">| MyISAM     | DEFAULT | Default engine as of MySQL 3.23 with great performance     | NO           | NO   | NO         |  </span><br><span class=\"line\">| InnoDB     | YES     | Supports transactions, row-level locking, and foreign keys | YES          | YES  | YES        |  </span><br><span class=\"line\">| MEMORY     | YES     | Hash based, stored in memory, useful for temporary tables  | NO           | NO   | NO         |  </span><br><span class=\"line\">+------------+---------+------------------------------------------------------------+--------------+------+------------+  </span><br><span class=\"line\">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>也可以以下面的方式查看</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#39;storage_engine&#39;;  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">| Variable_name  | Value  |  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">| storage_engine | MyISAM |  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>9.修改mysql的默认引擎为InnoDB<br>9.1 停止mysql</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; exit;  </span><br><span class=\"line\">[root@bogon ~]# service mysqld stop</span><br></pre></td></tr></table></figure>\n\n<p>9.2 修改/etc/my.cnf<br>[mysqld] 后加入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default-storage-engine=InnoDB</span><br></pre></td></tr></table></figure>\n\n<p>加入后my.cnf的内容为：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon etc]<span class=\"comment\"># more my.cnf  </span></span><br><span class=\"line\">[mysqld]  </span><br><span class=\"line\">datadir=/var/lib/mysql  </span><br><span class=\"line\">socket=/var/lib/mysql/mysql.sock  </span><br><span class=\"line\">user=mysql  </span><br><span class=\"line\"><span class=\"comment\"># Disabling symbolic-links is recommended to prevent assorted security risks  </span></span><br><span class=\"line\">symbolic-links=0  </span><br><span class=\"line\">  </span><br><span class=\"line\">default-storage-engine=InnoDB  </span><br><span class=\"line\">  </span><br><span class=\"line\">[mysqld_safe]  </span><br><span class=\"line\"><span class=\"built_in\">log</span>-error=/var/<span class=\"built_in\">log</span>/mysqld.log  </span><br><span class=\"line\">pid-file=/var/run/mysqld/mysqld.pid</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>9.3 启动mysql</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon etc]<span class=\"comment\"># service mysqld start  </span></span><br><span class=\"line\">Starting mysqld:  [  OK  ]</span><br></pre></td></tr></table></figure>\n\n<p>9.4 查看mysql默认存储引擎</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon etc]# mysql -u root -p  </span><br><span class=\"line\">Enter password:   </span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.  </span><br><span class=\"line\">Your MySQL connection id is 2  </span><br><span class=\"line\">Server version: 5.1.73 Source distribution  </span><br><span class=\"line\">  </span><br><span class=\"line\">Copyright (c) 2000, 2013, Oracle and&#x2F;or its affiliates. All rights reserved.  </span><br><span class=\"line\">  </span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and&#x2F;or its  </span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective  </span><br><span class=\"line\">owners.  </span><br><span class=\"line\">  </span><br><span class=\"line\">Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.  </span><br><span class=\"line\">  </span><br><span class=\"line\">mysql&gt; show variables like &#39;storage_engine&#39;;  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">| Variable_name  | Value  |  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">| storage_engine | InnoDB |  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>10.CentOS6.5开放mysql端口3306<br>CentOS6.5默认是不开放端口的，如果要让外部的系统访问CentOS6.5上的mysql，必须开放mysql的端口3306<br>10.1 修改/etc/sysconfig/iptables<br>添加下面一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure>\n\n<p>修改后iptables中的内容是</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon etc]# more &#x2F;etc&#x2F;sysconfig&#x2F;iptables  </span><br><span class=\"line\"># Firewall configuration written by system-config-firewall  </span><br><span class=\"line\"># Manual customization of this file is not recommended.  </span><br><span class=\"line\">*filter  </span><br><span class=\"line\">:INPUT ACCEPT [0:0]  </span><br><span class=\"line\">:FORWARD ACCEPT [0:0]  </span><br><span class=\"line\">:OUTPUT ACCEPT [0:0]  </span><br><span class=\"line\">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT  </span><br><span class=\"line\">-A INPUT -p icmp -j ACCEPT  </span><br><span class=\"line\">-A INPUT -i lo -j ACCEPT  </span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT  </span><br><span class=\"line\">#添加配置项  </span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT  </span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 11211 -j ACCEPT  </span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT  </span><br><span class=\"line\">-A INPUT -j REJECT --reject-with icmp-host-prohibited  </span><br><span class=\"line\">-A FORWARD -j REJECT --reject-with icmp-host-prohibited  </span><br><span class=\"line\">  </span><br><span class=\"line\">COMMIT</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>11.重启防火墙</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon etc]<span class=\"comment\"># service iptables restart</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就可以从外部访问mysql了。</p>\n<p>至此，mysql在CentOS6.5上的安装过程、用户创建、外部访问的步骤全部完成。</p>\n<p>—————————分割线—————————————</p>\n<p>上面都是从别人发表的文章中截取的<del>~</del>作者要是看到了莫怪，我只是想收藏，怕源文被删就看不到了，谢谢你们这些摘树的前人。</p>\n<p>其实这样在云主机上设置mysql并访问是OK的。适用于一切的centos6.5，亦或者其他linux系统。万变不离其宗，系统的改变，无非是命令行语言的改变，其宗旨是不会变的。</p>\n<p>LZ第一次用云主机，想试试在本地远程访问一下，结果发现，咦，连接出错了<del>~</del>，后来试了很多方法，还是没有能成功。</p>\n<p>刚开始，用Navicat连接远程数据库，出现如下错误：应该就是远程不允许访问了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/1697e3b0-837f-41b0-8baa-8e4578dda4c8.png\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>远程拒绝访问的情况可能有两种：</p>\n<p>一、mysql设置中，不允许远程访问.也即你使用的mysql登陆账号没有远程访问的权限。比如root账号，在我们之前看到的use权限列表中，root就没有远程访问的权限。现在来设置root的远程访问权限。</p>\n<p>方法一：实现远程连接(授权法)</p>\n<p>mysql&gt; use mysql;</p>\n<p>Database changed</p>\n<p>mysql&gt; grant all privileges  on <em>.</em> to root@’%’ identified by “root”;</p>\n<p>mysql&gt; select host,user,password from user;</p>\n<p>+————–+——+——————————————-+</p>\n<p>| host     | user | password                  |</p>\n<p>+————–+——+——————————————-+</p>\n<p>| localhost   | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |</p>\n<p>| 192.168.1.1 | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |</p>\n<p>| %       | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |</p>\n<p>+————–+——+——————————————-+</p>\n<p>3 rows in set (0.00 sec)</p>\n<p>这样机器就可以以用户名root密码root远程访问该机器上的MySql.</p>\n<p>方法二：实现远程连接（改表法）</p>\n<p>将host字段的值改为%就表示在任何客户端机器上能以root用户登录到mysql服务器，建议在开发时设为%。 </p>\n<p>mysql&gt; use mysql;</p>\n<p>Database changed</p>\n<p>mysql&gt; update user set host = ‘%’ where user = ‘root’;</p>\n<p>这时，root将权限改为ALL PRIVILEGES；</p>\n<p>这样在远端就可以通过root用户访问Mysql.</p>\n<p>二、确定服务器上的防火墙没有阻止 3306 端口。也即服务器上面有没有开放mysql的端口~（我的就是这个问题）</p>\n<p>　　看到上面的第10条中，在端口管理iptables中添加3306端口的开放配置，这样算是硬件的配置。然后看看你的云主机设置里面有没有开放对应的端口，或者说是不是开放了所有端口~我的云主机如下图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/900f746d-0def-457f-92df-c08e0894825d.png\" alt=\"img](https://app.yinxiang.com/shard/s37/res/5269b539-f016-491c-b76c-a43e8e5833d5.png)![img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img](https://app.yinxiang.com/shard/s37/res/5269b539-f016-491c-b76c-a43e8e5833d5.png)![img</div>\n            </figure>\n\n<p>腾讯云主机中，貌似是没有开放所有端口的，所以需要我们自己在这里稍微设置一下，勾选“默认安全组放通全部端口”选项，“确定”。基本上，我们能做的都做了，要不然就是配置文件出错了，再返回去看看。设置好了以后，我去试了一下连接，结果成功了~</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/a5e1fa91-d624-48e2-95fd-9b9e261f5b65.png\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>哈哈，好高兴<del>以后遇到这些问题就知道在哪些地方找问题了</del></p>\n","site":{"data":{}},"excerpt":"<p>1.使用yum命令安装mysql</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon ~]#  yum -y install mysql-server</span><br></pre></td></tr></table></figure>","more":"<p>2.设置开机启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon ~]#  chkconfig mysqld on</span><br></pre></td></tr></table></figure>\n\n<p>3.启动MySQL服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon ~]#  service mysqld start</span><br></pre></td></tr></table></figure>\n\n<p>4.设置MySQL的root用户设置密码</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon ~]#  mysql -u root  </span><br><span class=\"line\">mysql&gt; select user,host,password from mysql.user;  </span><br><span class=\"line\">+------+-----------+----------+  </span><br><span class=\"line\">| user | host      | password |  </span><br><span class=\"line\">+------+-----------+----------+  </span><br><span class=\"line\">| root | localhost |          |  </span><br><span class=\"line\">| root | bogon     |          |  </span><br><span class=\"line\">| root | 127.0.0.1 |          |  </span><br><span class=\"line\">|      | localhost |          |  </span><br><span class=\"line\">|      | bogon     |          |  </span><br><span class=\"line\">+------+-----------+----------+  </span><br><span class=\"line\">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>查询用户的密码，都为空，用下面的命令设置root的密码为root</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set password for root@localhost&#x3D;password(&#39;root&#39;);  </span><br><span class=\"line\">mysql&gt; exit</span><br></pre></td></tr></table></figure>\n\n<p>6.创建mysql新用户test_user</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create user &#39;test_user&#39;@&#39;%&#39; identified by &#39;test_user&#39;;  </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>7.给新用户test_user授权，让他可以从外部登陆和本地登陆<br>注意：@左边是用户名，右边是域名、IP和%，表示可以访问mysql的域名和IP，%表示外部任何地址都能访问。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; grant all privileges on *.* to &#39;test_user&#39;@&#39;localhost&#39; identified by &#39;test_user&#39;;  </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)  </span><br><span class=\"line\">mysql&gt; grant all privileges on *.* to &#39;test_user&#39;@&#39;%&#39; identified by &#39;test_user&#39;;  </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)  </span><br><span class=\"line\">mysql&gt; select user,host,password from mysql.user;  </span><br><span class=\"line\">+----------+-----------+-------------------------------------------+  </span><br><span class=\"line\">| user     | host      | password                                  |  </span><br><span class=\"line\">+----------+-----------+-------------------------------------------+  </span><br><span class=\"line\">| root     | localhost | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |  </span><br><span class=\"line\">| root     | bogon     |                                           |  </span><br><span class=\"line\">| root     | 127.0.0.1 |                                           |  </span><br><span class=\"line\">|          | localhost |                                           |  </span><br><span class=\"line\">|          | bogon     |                                           |  </span><br><span class=\"line\">| test_user | %         | *3046CF87132BBD4FDDF06F321C6859074843B7D3 |  </span><br><span class=\"line\">| test_user | localhost | *3046CF87132BBD4FDDF06F321C6859074843B7D3 |  </span><br><span class=\"line\">+----------+-----------+-------------------------------------------+  </span><br><span class=\"line\">7 rows in set (0.00 sec)  </span><br><span class=\"line\">mysql&gt; flush privileges;  </span><br><span class=\"line\">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>8.查看mysql5.1的默认存储引擎<br>从下面的执行结果可以看出，mysql的默认引擎是MyISAM，这个引擎是不支持事务的。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show engines;  </span><br><span class=\"line\">+------------+---------+------------------------------------------------------------+--------------+------+------------+  </span><br><span class=\"line\">| Engine     | Support | Comment                                                    | Transactions | XA   | Savepoints |  </span><br><span class=\"line\">+------------+---------+------------------------------------------------------------+--------------+------+------------+  </span><br><span class=\"line\">| MRG_MYISAM | YES     | Collection of identical MyISAM tables                      | NO           | NO   | NO         |  </span><br><span class=\"line\">| CSV        | YES     | CSV storage engine                                         | NO           | NO   | NO         |  </span><br><span class=\"line\">| MyISAM     | DEFAULT | Default engine as of MySQL 3.23 with great performance     | NO           | NO   | NO         |  </span><br><span class=\"line\">| InnoDB     | YES     | Supports transactions, row-level locking, and foreign keys | YES          | YES  | YES        |  </span><br><span class=\"line\">| MEMORY     | YES     | Hash based, stored in memory, useful for temporary tables  | NO           | NO   | NO         |  </span><br><span class=\"line\">+------------+---------+------------------------------------------------------------+--------------+------+------------+  </span><br><span class=\"line\">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>也可以以下面的方式查看</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#39;storage_engine&#39;;  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">| Variable_name  | Value  |  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">| storage_engine | MyISAM |  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>9.修改mysql的默认引擎为InnoDB<br>9.1 停止mysql</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; exit;  </span><br><span class=\"line\">[root@bogon ~]# service mysqld stop</span><br></pre></td></tr></table></figure>\n\n<p>9.2 修改/etc/my.cnf<br>[mysqld] 后加入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default-storage-engine=InnoDB</span><br></pre></td></tr></table></figure>\n\n<p>加入后my.cnf的内容为：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon etc]<span class=\"comment\"># more my.cnf  </span></span><br><span class=\"line\">[mysqld]  </span><br><span class=\"line\">datadir=/var/lib/mysql  </span><br><span class=\"line\">socket=/var/lib/mysql/mysql.sock  </span><br><span class=\"line\">user=mysql  </span><br><span class=\"line\"><span class=\"comment\"># Disabling symbolic-links is recommended to prevent assorted security risks  </span></span><br><span class=\"line\">symbolic-links=0  </span><br><span class=\"line\">  </span><br><span class=\"line\">default-storage-engine=InnoDB  </span><br><span class=\"line\">  </span><br><span class=\"line\">[mysqld_safe]  </span><br><span class=\"line\"><span class=\"built_in\">log</span>-error=/var/<span class=\"built_in\">log</span>/mysqld.log  </span><br><span class=\"line\">pid-file=/var/run/mysqld/mysqld.pid</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>9.3 启动mysql</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon etc]<span class=\"comment\"># service mysqld start  </span></span><br><span class=\"line\">Starting mysqld:  [  OK  ]</span><br></pre></td></tr></table></figure>\n\n<p>9.4 查看mysql默认存储引擎</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon etc]# mysql -u root -p  </span><br><span class=\"line\">Enter password:   </span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.  </span><br><span class=\"line\">Your MySQL connection id is 2  </span><br><span class=\"line\">Server version: 5.1.73 Source distribution  </span><br><span class=\"line\">  </span><br><span class=\"line\">Copyright (c) 2000, 2013, Oracle and&#x2F;or its affiliates. All rights reserved.  </span><br><span class=\"line\">  </span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and&#x2F;or its  </span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective  </span><br><span class=\"line\">owners.  </span><br><span class=\"line\">  </span><br><span class=\"line\">Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.  </span><br><span class=\"line\">  </span><br><span class=\"line\">mysql&gt; show variables like &#39;storage_engine&#39;;  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">| Variable_name  | Value  |  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">| storage_engine | InnoDB |  </span><br><span class=\"line\">+----------------+--------+  </span><br><span class=\"line\">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>10.CentOS6.5开放mysql端口3306<br>CentOS6.5默认是不开放端口的，如果要让外部的系统访问CentOS6.5上的mysql，必须开放mysql的端口3306<br>10.1 修改/etc/sysconfig/iptables<br>添加下面一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure>\n\n<p>修改后iptables中的内容是</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon etc]# more &#x2F;etc&#x2F;sysconfig&#x2F;iptables  </span><br><span class=\"line\"># Firewall configuration written by system-config-firewall  </span><br><span class=\"line\"># Manual customization of this file is not recommended.  </span><br><span class=\"line\">*filter  </span><br><span class=\"line\">:INPUT ACCEPT [0:0]  </span><br><span class=\"line\">:FORWARD ACCEPT [0:0]  </span><br><span class=\"line\">:OUTPUT ACCEPT [0:0]  </span><br><span class=\"line\">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT  </span><br><span class=\"line\">-A INPUT -p icmp -j ACCEPT  </span><br><span class=\"line\">-A INPUT -i lo -j ACCEPT  </span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT  </span><br><span class=\"line\">#添加配置项  </span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT  </span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 11211 -j ACCEPT  </span><br><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT  </span><br><span class=\"line\">-A INPUT -j REJECT --reject-with icmp-host-prohibited  </span><br><span class=\"line\">-A FORWARD -j REJECT --reject-with icmp-host-prohibited  </span><br><span class=\"line\">  </span><br><span class=\"line\">COMMIT</span><br></pre></td></tr></table></figure>\n\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/00d39035-814c-4a24-b570-5fc3b75a3a50.gif\" alt=\"复制代码\" title=\"\">\n                </div>\n                <div class=\"image-caption\">复制代码</div>\n            </figure>\n\n<p>11.重启防火墙</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@bogon etc]<span class=\"comment\"># service iptables restart</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就可以从外部访问mysql了。</p>\n<p>至此，mysql在CentOS6.5上的安装过程、用户创建、外部访问的步骤全部完成。</p>\n<p>—————————分割线—————————————</p>\n<p>上面都是从别人发表的文章中截取的<del>~</del>作者要是看到了莫怪，我只是想收藏，怕源文被删就看不到了，谢谢你们这些摘树的前人。</p>\n<p>其实这样在云主机上设置mysql并访问是OK的。适用于一切的centos6.5，亦或者其他linux系统。万变不离其宗，系统的改变，无非是命令行语言的改变，其宗旨是不会变的。</p>\n<p>LZ第一次用云主机，想试试在本地远程访问一下，结果发现，咦，连接出错了<del>~</del>，后来试了很多方法，还是没有能成功。</p>\n<p>刚开始，用Navicat连接远程数据库，出现如下错误：应该就是远程不允许访问了。</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/1697e3b0-837f-41b0-8baa-8e4578dda4c8.png\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>远程拒绝访问的情况可能有两种：</p>\n<p>一、mysql设置中，不允许远程访问.也即你使用的mysql登陆账号没有远程访问的权限。比如root账号，在我们之前看到的use权限列表中，root就没有远程访问的权限。现在来设置root的远程访问权限。</p>\n<p>方法一：实现远程连接(授权法)</p>\n<p>mysql&gt; use mysql;</p>\n<p>Database changed</p>\n<p>mysql&gt; grant all privileges  on <em>.</em> to root@’%’ identified by “root”;</p>\n<p>mysql&gt; select host,user,password from user;</p>\n<p>+————–+——+——————————————-+</p>\n<p>| host     | user | password                  |</p>\n<p>+————–+——+——————————————-+</p>\n<p>| localhost   | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |</p>\n<p>| 192.168.1.1 | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |</p>\n<p>| %       | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |</p>\n<p>+————–+——+——————————————-+</p>\n<p>3 rows in set (0.00 sec)</p>\n<p>这样机器就可以以用户名root密码root远程访问该机器上的MySql.</p>\n<p>方法二：实现远程连接（改表法）</p>\n<p>将host字段的值改为%就表示在任何客户端机器上能以root用户登录到mysql服务器，建议在开发时设为%。 </p>\n<p>mysql&gt; use mysql;</p>\n<p>Database changed</p>\n<p>mysql&gt; update user set host = ‘%’ where user = ‘root’;</p>\n<p>这时，root将权限改为ALL PRIVILEGES；</p>\n<p>这样在远端就可以通过root用户访问Mysql.</p>\n<p>二、确定服务器上的防火墙没有阻止 3306 端口。也即服务器上面有没有开放mysql的端口~（我的就是这个问题）</p>\n<p>　　看到上面的第10条中，在端口管理iptables中添加3306端口的开放配置，这样算是硬件的配置。然后看看你的云主机设置里面有没有开放对应的端口，或者说是不是开放了所有端口~我的云主机如下图：</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/900f746d-0def-457f-92df-c08e0894825d.png\" alt=\"img](https://app.yinxiang.com/shard/s37/res/5269b539-f016-491c-b76c-a43e8e5833d5.png)![img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img](https://app.yinxiang.com/shard/s37/res/5269b539-f016-491c-b76c-a43e8e5833d5.png)![img</div>\n            </figure>\n\n<p>腾讯云主机中，貌似是没有开放所有端口的，所以需要我们自己在这里稍微设置一下，勾选“默认安全组放通全部端口”选项，“确定”。基本上，我们能做的都做了，要不然就是配置文件出错了，再返回去看看。设置好了以后，我去试了一下连接，结果成功了~</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://app.yinxiang.com/shard/s37/res/a5e1fa91-d624-48e2-95fd-9b9e261f5b65.png\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>哈哈，好高兴<del>以后遇到这些问题就知道在哪些地方找问题了</del></p>"},{"title":"vim快捷键","date":"2019-04-23T16:00:00.000Z","_content":"\n*经使用了两年多的Vim，手册也翻过一遍。虽然现在不怎么用vim了，曾经的笔记还是贴出来，与喜欢vim的朋友分享。*\n\n<!-- more -->\n\n# [1. 关于Vim](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id59)\n\nvim是我最喜欢的编辑器，也是linux下第二强大的编辑器。 虽然emacs是公认的世界第一，我认为使用emacs并没有使用vi进行编辑来得高效。 如果是初学vi，运行一下vimtutor是个聪明的决定。 （如果你的系统环境不是中文，而你想使用中文的vimtutor，就运行vimtutor zh）\n\n## [1.1 Vim的几种模式](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id60)\n\n- 正常模式：可以使用快捷键命令，或按:输入命令行。\n- 插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。\n- 可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。\n- 替换模式：正常模式下，按R进入。\n\n# [2. 启动Vim](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id61)\n\n- vim -c cmd file: 在打开文件前，先执行指定的命令；\n- vim -r file: 恢复上次异常退出的文件；\n- vim -R file: 以只读的方式打开文件，但可以强制保存；\n- vim -M file: 以只读的方式打开文件，不可以强制保存；\n- vim -y num file: 将编辑窗口的大小设为num行；\n- vim + file: 从文件的末尾开始；\n- vim +num file: 从第num行开始；\n- vim +/string file: 打开file，并将光标停留在第一个找到的string上。\n- vim --remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim --remote file在已有的gvim中打开文件。\n\n# [3. 文档操作](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id62)\n\n- :e file --关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。\n- :e! file --放弃对当前文件的修改，编辑新的文件。\n- :e+file -- 开始新的文件，并从文件尾开始编辑。\n- :e+n file -- 开始新的文件，并从第n行开始编辑。\n- :enew --编译一个未命名的新文档。(CTRL-W n)\n- :e -- 重新加载当前文档。\n- :e! -- 重新加载当前文档，并丢弃已做的改动。\n- :e#或ctrl+^ -- 回到刚才编辑的文件，很实用。\n- :f或ctrl+g -- 显示文档名，是否修改，和光标位置。\n- :f filename -- 改变编辑的文件名，这时再保存相当于另存为。\n- gf -- 打开以光标所在字符串为文件名的文件。\n- :w -- 保存修改。\n- :n1,n2w filename -- 选择性保存从某n1行到另n2行的内容。\n- :wq -- 保存并退出。\n- ZZ -- 保存并退出。\n- :x -- 保存并退出。\n- :q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)\n- :saveas newfilename -- 另存为\n- :browse e -- 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：\n  - :set browsedir=last -- 用上次访问过的目录（默认）；\n  - :set browsedir=buffer -- 用当前文件所在目录；\n  - :set browsedir=current -- 用当前工作目录；\n- :Sex -- 水平分割一个窗口，浏览文件系统；\n- :Vex -- 垂直分割一个窗口，浏览文件系统；\n\n# [4. 光标的移动](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id63)\n\n## [4.1 基本移动](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id64)\n\n以下移动都是在normal模式下。\n\n- h或退格: 左移一个字符；\n- l或空格: 右移一个字符；\n- j: 下移一行；\n- k: 上移一行；\n- gj: 移动到一段内的下一行；\n- gk: 移动到一段内的上一行；\n- +或Enter: 把光标移至下一行第一个非空白字符。\n- -: 把光标移至上一行第一个非空白字符。\n- w: 前移一个单词，光标停在下一个单词开头；\n- W: 移动下一个单词开头，但忽略一些标点；\n- e: 前移一个单词，光标停在下一个单词末尾；\n- E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；\n- b: 后移一个单词，光标停在上一个单词开头；\n- B: 移动到上一个单词开头，忽略一些标点；\n- ge: 后移一个单词，光标停在上一个单词末尾；\n- gE: 同 ge ，不过‘单词’包含单词相邻的标点。\n- (: 前移1句。\n- ): 后移1句。\n- {: 前移1段。\n- }: 后移1段。\n- fc: 把光标移到同一行的下一个c字符处\n- Fc: 把光标移到同一行的上一个c字符处\n- tc: 把光标移到同一行的下一个c字符前\n- Tc: 把光标移到同一行的上一个c字符后\n- ;: 配合f & t使用，重复一次\n- ,: 配合f & t使用，反向重复一次\n\n上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。\n\n- 0: 移动到行首。\n- g0: 移到光标所在屏幕行行首。\n- ^: 移动到本行第一个非空白字符。\n- g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。\n- $: 移动到行尾。\n- g$: 移动光标所在屏幕行行尾。\n- n|: 把光标移到递n列上。\n- nG: 到文件第n行。\n- :n<cr> 移动到第n行。\n- :$<cr> 移动到最后一行。\n- H: 把光标移到屏幕最顶端一行。\n- M: 把光标移到屏幕中间一行。\n- L: 把光标移到屏幕最底端一行。\n- gg: 到文件头部。\n- G: 到文件尾部。\n\n## [4.2 翻屏](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id65)\n\n- ctrl+f: 下翻一屏。\n- ctrl+b: 上翻一屏。\n- ctrl+d: 下翻半屏。\n- ctrl+u: 上翻半屏。\n- ctrl+e: 向下滚动一行。\n- ctrl+y: 向上滚动一行。\n- n%: 到文件n%的位置。\n- zz: 将当前行移动到屏幕中央。\n- zt: 将当前行移动到屏幕顶端。\n- zb: 将当前行移动到屏幕底端。\n\n## [4.3 标记](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id66)\n\n使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 *后退* 和 *前进* 。\n\n- m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。\n- m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。\n- `{a-z}: 移动到标记位置。\n- '{a-z}: 移动到标记行的行首。\n- `{0-9}：回到上[2-10]次关闭vim时最后离开的位置。\n- ``: 移动到上次编辑的位置。''也可以，不过``精确到列，而''精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。\n- `\": 移动到上次离开的地方。\n- `.: 移动到最后改动的地方。\n- :marks 显示所有标记。\n- :delmarks a b -- 删除标记a和b。\n- :delmarks a-c -- 删除标记a、b和c。\n- :delmarks a c-f -- 删除标记a、c、d、e、f。\n- :delmarks! -- 删除当前缓冲区的所有标记。\n- :help mark-motions 查看更多关于mark的知识。\n\n# [5. 插入文本](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id67)\n\n## [5.1 基本插入](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id68)\n\n- i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+<esc>就插入了36个+组成的分割线。\n- I: 在当前行第一个非空字符前插入；\n- gI: 在当前行第一列插入；\n- a: 在光标后插入；\n- A: 在当前行最后插入；\n- o: 在下面新建一行插入；\n- O: 在上面新建一行插入；\n- :r filename在当前位置插入另一个文件的内容。\n- :[n]r filename在第n行插入另一个文件的内容。\n- :r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。\n\n## [5.2 改写插入](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id69)\n\n- c[n]w: 改写光标后1(n)个词。\n- c[n]l: 改写光标后n个字母。\n- c[n]h: 改写光标前n个字母。\n- [n]cc: 修改当前[n]行。\n- [n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。\n- [n]S: 删除指定数目的行，并以所输入文本代替之。\n\n注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。\n\n# [6. 剪切复制和寄存器](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id70)\n\n## [6.1 剪切和复制、粘贴](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id71)\n\n- [n]x: 剪切光标右边n个字符，相当于d[n]l。\n- [n]X: 剪切光标左边n个字符，相当于d[n]h。\n- y: 复制在可视模式下选中的文本。\n- yy or Y: 复制整行文本。\n- y[n]w: 复制一(n)个词。\n- y[n]l: 复制光标右边1(n)个字符。\n- y[n]h: 复制光标左边1(n)个字符。\n- y$: 从光标当前位置复制到行尾。\n- y0: 从光标当前位置复制到行首。\n- :m,ny<cr> 复制m行到n行的内容。\n- y1G或ygg: 复制光标以上的所有行。\n- yG: 复制光标以下的所有行。\n- yaw和yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。\n- d: 删除（剪切）在可视模式下选中的文本。\n- d$ or D: 删除（剪切）当前位置到行尾的内容。\n- d[n]w: 删除（剪切）1(n)个单词\n- d[n]l: 删除（剪切）光标右边1(n)个字符。\n- d[n]h: 删除（剪切）光标左边1(n)个字符。\n- d0: 删除（剪切）当前位置到行首的内容\n- [n] dd: 删除（剪切）1(n)行。\n- :m,nd<cr> 剪切m行到n行的内容。\n- d1G或dgg: 剪切光标以上的所有行。\n- dG: 剪切光标以下的所有行。\n- daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。\n- d/f<cr>：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。\n- p: 在光标之后粘贴。\n- P: 在光标之前粘贴。\n\n## [6.2 文本对象](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id72)\n\n- aw：一个词\n- as：一句。\n- ap：一段。\n- ab：一块（包含在圆括号中的）。\n\ny, d, c, v都可以跟文本对象。\n\n## [6.3 寄存器](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id73)\n\n- a-z：都可以用作寄存器名。\"ayy把当前行的内容放入a寄存器。\n- A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如\"Ayy把当前行的内容追加到a寄存器中。\n- :reg 显示所有寄存器的内容。\n- \"\"：不加寄存器索引时，默认使用的寄存器。\n- \"*：当前选择缓冲区，\"*yy把当前行的内容放入当前选择缓冲区。\n- \"+：系统剪贴板。\"+yy把当前行的内容放入系统剪贴板。\n\n# [7. 查找与替换](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id74)\n\n## [7.1 查找](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id75)\n\n- /something: 在后面的文本中查找something。\n- ?something: 在前面的文本中查找something。\n- /pattern/+number: 将光标停在包含pattern的行后面第number行上。\n- /pattern/-number: 将光标停在包含pattern的行前面第number行上。\n- n: 向后查找下一个。\n- N: 向前查找下一个。\n\n可以用grep或vimgrep查找一个模式都在哪些地方出现过，\n\n其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。\n\n用法为： :vim[grep]/pattern/[g] [j] files\n\ng的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。\n\nj的含义是grep结束后，结果停在第j项，默认是停在第一项。\n\nvimgrep前面可以加数字限定搜索结果的上限，如\n\n:1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。\n\n \n\n其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。\n\n比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：\n\n:vim/^d{1,}./ %\n\n然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，\n\n就更像个目录了。\n\n## [7.2 替换](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id76)\n\n- :s/old/new - 用new替换当前行第一个old。\n- :s/old/new/g - 用new替换当前行所有的old。\n- :n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。\n- :%s/old/new/g - 用new替换文件中所有的old。\n- :%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。\n- :%s/$/xxx/g - 在每一行的行尾插入xxx，$表示行尾。\n- 所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。\n\n还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，\n\n语法为 :[range]g/pattern/command\n\n例如 :%g/^ xyz/normal dd。\n\n表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。\n\n关于range的规定为：\n\n- 如果不指定range，则表示当前行。\n- m,n: 从m行到n行。\n- 0: 最开始一行（可能是这样）。\n- $: 最后一行\n- .: 当前行\n- %: 所有行\n\n## [7.3 正则表达式](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id77)\n\n高级的查找替换就要用到正则表达式。\n\n- \\d: 表示十进制数（我猜的）\n- \\s: 表示空格\n- \\S: 非空字符\n- \\a: 英文字母\n- \\|: 表示 或\n- \\.: 表示.\n- {m,n}: 表示m到n个字符。这要和 \\s与\\a等连用，如 \\a\\{m,n} 表示m 到n个英文字母。\n- {m,}: 表示m到无限多个字符。\n- **: 当前目录下的所有子目录。\n\n:help pattern得到更多帮助。\n\n------\n\n# [8. 排版](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id78)\n\n## [8.1 基本排版](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id79)\n\n- << 向左缩进一个shiftwidth\n- \\>> 向右缩进一个shiftwidth\n- :ce(nter) 本行文字居中\n- :le(ft) 本行文字靠左\n- :ri(ght) 本行文字靠右\n- gq 对选中的文字重排，即对过长的文字进行断行\n- gqq 重排当前行\n- gqnq 重排n行\n- gqap 重排当前段\n- gqnap 重排n段\n- gqnj 重排当前行和下面n行\n- gqQ 重排当前段对文章末尾\n- J 拼接当前行和下一行\n- gJ 同 J ，不过合并后不留空格。\n\n## [8.2 拼写检查](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id80)\n\n- :set spell－开启拼写检查功能\n- :set nospell－关闭拼写检查功能\n- ]s－移到下一个拼写错误的单词\n- [s－作用与上一命令类似，但它是从相反方向进行搜索\n- z=－显示一个有关拼写错误单词的列表，可从中选择\n- zg－告诉拼写检查器该单词是拼写正确的\n- zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的\n\n## [8.3 统计字数](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id81)\n\ng ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。\n\n------\n\n# [9. 编辑多个文件](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id82)\n\n## [9.1 一次编辑多个文件](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id83)\n\n我们可以一次打开多个文件，如\n\n> ```\n> vi a.txt b.txt c.txt\n> ```\n\n- 使用:next(:n)编辑下一个文件。\n- :2n 编辑下2个文件。\n- 使用:previous或:N编辑上一个文件。\n- 使用:wnext，保存当前文件，并编辑下一个文件。\n- 使用:wprevious，保存当前文件，并编辑上一个文件。\n- 使用:args 显示文件列表。\n- :n filenames或:args filenames 指定新的文件列表。\n- vi -o filenames 在水平分割的多个窗口中编辑多个文件。\n- vi -O filenames 在垂直分割的多个窗口中编辑多个文件。\n\n## [9.2 多标签编辑](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id84)\n\n- vim -p files: 打开多个文件，每个文件占用一个标签页。\n- :tabe, tabnew -- 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。\n- ^w gf -- 在新的标签页里打开光标下路径指定的文件。\n- :tabn -- 切换到下一个标签。Control + PageDown，也可以。\n- :tabp -- 切换到上一个标签。Control + PageUp，也可以。\n- [n] gt -- 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。\n- :tab split -- 将当前缓冲区的内容在新页签中打开。\n- :tabc[lose] -- 关闭当前的标签页。\n- :tabo[nly] -- 关闭其它的标签页。\n- :tabs -- 列出所有的标签页和它们包含的窗口。\n- :tabm[ove] [N] -- 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。\n\n## [9.3 缓冲区](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id85)\n\n- :buffers或:ls或:files 显示缓冲区列表。\n- ctrl+^：在最近两个缓冲区间切换。\n- :bn -- 下一个缓冲区。\n- :bp -- 上一个缓冲区。\n- :bl -- 最后一个缓冲区。\n- :b[n]或:[n]b -- 切换到第n个缓冲区。\n- :nbw(ipeout) -- 彻底删除第n个缓冲区。\n- :nbd(elete) -- 删除第n个缓冲区，并未真正删除，还在unlisted列表中。\n- :ba[ll] -- 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。\n\n# [10. 分屏编辑](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id86)\n\n- vim -o file1 file2:水平分割窗口，同时打开file1和file2\n- vim -O file1 file2:垂直分割窗口，同时打开file1和file2\n\n## [10.1 水平分割](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id87)\n\n- :split(:sp) -- 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。\n- :split filename -- 水平分割窗口，并在新窗口中显示另一个文件。\n- :nsplit(:nsp) -- 水平分割出一个n行高的窗口。\n- :[N]new -- 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N)\n- ctrl+w f --水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。\n- C-w C-^ -- 水平分割一个窗口，打开刚才编辑的文件。\n\n## [10.2 垂直分割](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id88)\n\n- :vsplit(:vsp) -- 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V)\n- :[N]vne[w] -- 垂直分割出一个新窗口。\n- :vertical 水平分割的命令： 相应的垂直分割。\n\n## [10.3 关闭子窗口](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id89)\n\n- :qall -- 关闭所有窗口，退出vim。\n- :wall -- 保存所有修改过的窗口。\n- :only -- 只保留当前窗口，关闭其它窗口。(CTRL-W o)\n- :close -- 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )\n\n## [10.4 调整窗口大小](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id90)\n\n- ctrl+w + --当前窗口增高一行。也可以用n增高n行。\n- ctrl+w - --当前窗口减小一行。也可以用n减小n行。\n- ctrl+w _ --当前窗口扩展到尽可能的大。也可以用n设定行数。\n- :resize n -- 当前窗口n行高。\n- ctrl+w = -- 所有窗口同样高度。\n- n ctrl+w _ -- 当前窗口的高度设定为n行。\n- ctrl+w < --当前窗口减少一列。也可以用n减少n列。\n- ctrl+w > --当前窗口增宽一列。也可以用n增宽n列。\n- ctrl+w | --当前窗口尽可能的宽。也可以用n设定列数。\n\n## [10.5 切换和移动窗口](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id91)\n\n如果支持鼠标，切换和调整子窗口的大小就简单了。\n\n- ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。\n- ctrl+w p: 切换到前一个窗口。\n- ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。\n- ctrl+w t(b):切换到最上（下）面的窗口。<BR>\n- ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。\n- ctrl+w r：旋转窗口的位置。\n- ctrl+w T: 将当前的窗口移动到新的标签页上。\n\n# [11. 快速编辑](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id92)\n\n## [11.1 改变大小写](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id93)\n\n- ~: 反转光标所在字符的大小写。\n- 可视模式下的U或u：把选中的文本变为大写或小写。\n- gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。\n\n## [11.2 替换（normal模式）](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id94)\n\n- r: 替换光标处的字符，同样支持汉字。\n- R: 进入替换模式，按esc回到正常模式。\n\n## [11.3 撤消与重做（normal模式）](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id95)\n\n- [n] u: 取消一(n)个改动。\n- :undo 5 -- 撤销5个改变。\n- :undolist -- 你的撤销历史。\n- ctrl + r: 重做最后的改动。\n- U: 取消当前行中所有的改动。\n- :earlier 4m -- 回到4分钟前\n- :later 55s -- 前进55秒\n\n## [11.4 宏](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id96)\n\n- . --重复上一个编辑动作\n- qa：开始录制宏a（键盘操作记录）\n- q：停止录制\n- @a：播放宏a\n\n# [12. 编辑特殊文件](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id97)\n\n## [12.1 文件加解密](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id98)\n\n- vim -x file: 开始编辑一个加密的文件。\n- :X -- 为当前文件设置密码。\n- :set key= -- 去除文件的密码。\n\n[这里是](http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html) 滇狐总结的比较高级的vi技巧。\n\n## [12.2 文件的编码](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id99)\n\n- :e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。\n- :w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。\n- :set fenc或:set fileencoding，查看当前文件的编码。\n- 在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。\n\n让vim 正确处理文件格式和文件编码，有赖于 [~/.vimrc的正确配置](http://www.cnblogs.com/jiqingwu/admin/vimrc.html)\n\n## [12.3 文件格式](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id100)\n\n大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。\n\n- :e ++ff=dos filename, 让vim用dos格式打开这个文件。\n- :w ++ff=mac filename, 以mac格式存储这个文件。\n- :set ff，显示当前文件的格式。\n- 在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。\n\n# [13. 编程辅助](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id101)\n\n## [13.1 一些按键](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id102)\n\n- gd: 跳转到局部变量的定义处；\n- gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；\n- g;: 上一个修改过的地方；\n- g,: 下一个修改过的地方；\n- [[: 跳转到上一个函数块开始，需要有单独一行的{。\n- ]]: 跳转到下一个函数块开始，需要有单独一行的{。\n- []: 跳转到上一个函数块结束，需要有单独一行的}。\n- ][: 跳转到下一个函数块结束，需要有单独一行的}。\n- [{: 跳转到当前块开始处；\n- ]}: 跳转到当前块结束处；\n- [/: 跳转到当前注释块开始处；\n- ]/: 跳转到当前注释块结束处；\n- %: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。\n\n下面的括号匹配对编程很实用的。\n\n- ci', di', yi'：修改、剪切或复制'之间的内容。\n- ca', da', ya'：修改、剪切或复制'之间的内容，包含'。\n- ci\", di\", yi\"：修改、剪切或复制\"之间的内容。\n- ca\", da\", ya\"：修改、剪切或复制\"之间的内容，包含\"。\n- ci(, di(, yi(：修改、剪切或复制()之间的内容。\n- ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。\n- ci[, di[, yi[：修改、剪切或复制[]之间的内容。\n- ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。\n- ci{, di{, yi{：修改、剪切或复制{}之间的内容。\n- ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。\n- ci<, di<, yi<：修改、剪切或复制<>之间的内容。\n- ca<, da<, ya<：修改、剪切或复制<>之间的内容，包含<>。\n\n## [13.2 ctags](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id103)\n\n- ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags\n- :set tags=path/tags -- 告诉ctags使用哪个tag文件\n- :tag xyz -- 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t\n- :stag xyz -- 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口\n- :ptag xyz -- 在预览窗口中打开xyz的定义，热键是C-w }。\n- :pclose -- 关闭预览窗口。热键是C-w z。\n- :pedit abc.h -- 在预览窗口中编辑abc.h\n- :psearch abc -- 搜索当前文件和当前文件include的文件，显示包含abc的行。\n\n有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。\n\n- :[n]tnext -- 下一[n]个匹配。\n- :[n]tprev -- 上一[n]个匹配。\n- :tfirst -- 第一个匹配\n- :tlast -- 最后一个匹配\n- :tselect tagname -- 打开选择列表\n\ntab键补齐\n\n- :tag xyz<tab> -- 补齐以xyz开头的tag名，继续按tab键，会显示其他的。\n- :tag /xyz<tab> -- 会用名字中含有xyz的tag名补全。\n\n## [13.3 cscope](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id104)\n\n- cscope -Rbq: 生成cscope.out文件\n- :cs add /path/to/cscope.out /your/work/dir\n- :cs find c func -- 查找func在哪些地方被调用\n- :cw -- 打开quickfix窗口查看结果\n\n## [13.4 gtags](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id105)\n\nGtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。\n\n- :Gtags funcname 定位到 funcname 的定义处。\n- :Gtags -r funcname 查询 funcname被引用的地方。\n- :Gtags -s symbol 定位 symbol 出现的地方。\n- :Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。\n- :Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。\n- :Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示vm目录下的文件。\n\n## [13.5 编译](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id106)\n\nvim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。\n\n如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.java文件，你可以这样设置：\n\n```\nset makeprg=javac\\ abc.java\n```\n\n然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如：\n\n```\n:setl efm=%A%f:%l:\\ %m,%-Z%p^,%-C%.%#\n```\n\n%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。\n\n## [13.6 快速修改窗口](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id107)\n\n其实是quickfix插件提供的功能， 对编译调试程序非常有用 :)\n\n- :copen -- 打开快速修改窗口。\n- :cclose -- 关闭快速修改窗口。\n\n快速修改窗口在make程序时非常有用，当make之后：\n\n- :cl -- 在快速修改窗口中列出错误。\n- :cn -- 定位到下一个错误。\n- :cp -- 定位到上一个错误。\n- :cr -- 定位到第一个错误。\n\n## [13.7 自动补全](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id108)\n\n- C-x C-s -- 拼写建议。\n- C-x C-v -- 补全vim选项和命令。\n- C-x C-l -- 整行补全。\n- C-x C-f -- 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。\n- C-x C-p 和C-x C-n -- 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。\n- C-x C-o -- 编程时可以补全关键字和函数名啊。\n- C-x C-i -- 根据头文件内关键字补全。\n- C-x C-d -- 补全宏定义。\n- C-x C-n -- 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。\n\n当弹出补全菜单后：\n\n- C-p 向前切换成员；\n- C-n 向后切换成员；\n- C-e 退出下拉菜单，并退回到原来录入的文字；\n- C-y 退出下拉菜单，并接受当前选项。\n\n## [13.8 多行缩进缩出](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id109)\n\n- 正常模式下，按两下>;光标所在行会缩进。\n- 如果先按了n，再按两下>;，光标以下的n行会缩进。\n- 对应的，按两下<;，光标所在行会缩出。\n- 如果在编辑代码文件，可以用=进行调整。\n- 在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。\n- 或者n =，调整n行代码的缩排。\n\n## [13.9 折叠](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id110)\n\n- zf -- 创建折叠的命令，可以在一个可视区域上使用该命令；\n- zd -- 删除当前行的折叠；\n- zD -- 删除当前行的折叠；\n- zfap -- 折叠光标所在的段；\n- zo -- 打开折叠的文本；\n- zc -- 收起折叠；\n- za -- 打开/关闭当前折叠；\n- zr -- 打开嵌套的折行；\n- zm -- 收起嵌套的折行；\n- zR (zO) -- 打开所有折行；\n- zM (zC) -- 收起所有折行；\n- zj -- 跳到下一个折叠处；\n- zk -- 跳到上一个折叠处；\n- zi -- enable/disable fold;\n\n# [14. 命令行](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id111)\n\nnormal模式下按:进入命令行模式\n\n## [14.1 命令行模式下的快捷键：](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id112)\n\n- 上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。\n- 左右方向键：左/右移一个字符。\n- C-w： 向前删除一个单词。\n- C-h： 向前删除一个字符，等同于Backspace。\n- C-u： 从当前位置移动到命令行开头。\n- C-b： 移动到命令行开头。\n- C-e： 移动到命令行末尾。\n- Shift-Left： 左移一个单词。\n- Shift-Right： 右移一个单词。\n- @： 重复上一次的冒号命令。\n- q： 正常模式下，q然后按':'，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。\n- q/和q? 可以打开查找历史记录。\n\n## [14.2 执行外部命令](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id113)\n\n- :! cmd 执行外部命令。\n- :!! 执行上一次的外部命令。\n- :sh 调用shell，用exit返回vim。\n- :r !cmd 将命令的返回结果插入文件当前位置。\n- :m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。\n\n# [15. 其它](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id114)\n\n## [15.1 工作目录](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id115)\n\n- :pwd 显示vim的工作目录。\n- :cd path 改变vim的工作目录。\n- :set autochdir 可以让vim 根据编辑的文件自动切换工作目录。\n\n## [15.2 一些快捷键（收集中）](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id116)\n\n- K: 打开光标所在词的manpage。\n- *: 向下搜索光标所在词。\n- g*: 同上，但部分符合即可。\n- \\#: 向上搜索光标所在词。\n- g#: 同上，但部分符合即可。\n- g C-g: 统计全文或统计部分的字数。\n\n## [15.3 在线帮助](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id117)\n\n- :h(elp)或F1 打开总的帮助。\n- :help user-manual 打开用户手册。\n- 命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。\n- :helptags somepath 为somepath中的文档生成索引。\n- :helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。\n- Ctrl+] 跳转到tag主题，Ctrl+t 跳回。\n- :ver 显示版本信息。\n\n## [15.4 一些小功能](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id118)\n\n- 简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果。","source":"_posts/常见问题/云服务器/vim快捷键.md","raw":"---\ntitle: vim快捷键\ndate: 2019-04-24\ntags:\n- linux\n- 快捷键\n- 云服务器\ncategories:\n- 常见问题\n---\n\n*经使用了两年多的Vim，手册也翻过一遍。虽然现在不怎么用vim了，曾经的笔记还是贴出来，与喜欢vim的朋友分享。*\n\n<!-- more -->\n\n# [1. 关于Vim](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id59)\n\nvim是我最喜欢的编辑器，也是linux下第二强大的编辑器。 虽然emacs是公认的世界第一，我认为使用emacs并没有使用vi进行编辑来得高效。 如果是初学vi，运行一下vimtutor是个聪明的决定。 （如果你的系统环境不是中文，而你想使用中文的vimtutor，就运行vimtutor zh）\n\n## [1.1 Vim的几种模式](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id60)\n\n- 正常模式：可以使用快捷键命令，或按:输入命令行。\n- 插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。\n- 可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。\n- 替换模式：正常模式下，按R进入。\n\n# [2. 启动Vim](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id61)\n\n- vim -c cmd file: 在打开文件前，先执行指定的命令；\n- vim -r file: 恢复上次异常退出的文件；\n- vim -R file: 以只读的方式打开文件，但可以强制保存；\n- vim -M file: 以只读的方式打开文件，不可以强制保存；\n- vim -y num file: 将编辑窗口的大小设为num行；\n- vim + file: 从文件的末尾开始；\n- vim +num file: 从第num行开始；\n- vim +/string file: 打开file，并将光标停留在第一个找到的string上。\n- vim --remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim --remote file在已有的gvim中打开文件。\n\n# [3. 文档操作](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id62)\n\n- :e file --关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。\n- :e! file --放弃对当前文件的修改，编辑新的文件。\n- :e+file -- 开始新的文件，并从文件尾开始编辑。\n- :e+n file -- 开始新的文件，并从第n行开始编辑。\n- :enew --编译一个未命名的新文档。(CTRL-W n)\n- :e -- 重新加载当前文档。\n- :e! -- 重新加载当前文档，并丢弃已做的改动。\n- :e#或ctrl+^ -- 回到刚才编辑的文件，很实用。\n- :f或ctrl+g -- 显示文档名，是否修改，和光标位置。\n- :f filename -- 改变编辑的文件名，这时再保存相当于另存为。\n- gf -- 打开以光标所在字符串为文件名的文件。\n- :w -- 保存修改。\n- :n1,n2w filename -- 选择性保存从某n1行到另n2行的内容。\n- :wq -- 保存并退出。\n- ZZ -- 保存并退出。\n- :x -- 保存并退出。\n- :q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)\n- :saveas newfilename -- 另存为\n- :browse e -- 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：\n  - :set browsedir=last -- 用上次访问过的目录（默认）；\n  - :set browsedir=buffer -- 用当前文件所在目录；\n  - :set browsedir=current -- 用当前工作目录；\n- :Sex -- 水平分割一个窗口，浏览文件系统；\n- :Vex -- 垂直分割一个窗口，浏览文件系统；\n\n# [4. 光标的移动](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id63)\n\n## [4.1 基本移动](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id64)\n\n以下移动都是在normal模式下。\n\n- h或退格: 左移一个字符；\n- l或空格: 右移一个字符；\n- j: 下移一行；\n- k: 上移一行；\n- gj: 移动到一段内的下一行；\n- gk: 移动到一段内的上一行；\n- +或Enter: 把光标移至下一行第一个非空白字符。\n- -: 把光标移至上一行第一个非空白字符。\n- w: 前移一个单词，光标停在下一个单词开头；\n- W: 移动下一个单词开头，但忽略一些标点；\n- e: 前移一个单词，光标停在下一个单词末尾；\n- E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；\n- b: 后移一个单词，光标停在上一个单词开头；\n- B: 移动到上一个单词开头，忽略一些标点；\n- ge: 后移一个单词，光标停在上一个单词末尾；\n- gE: 同 ge ，不过‘单词’包含单词相邻的标点。\n- (: 前移1句。\n- ): 后移1句。\n- {: 前移1段。\n- }: 后移1段。\n- fc: 把光标移到同一行的下一个c字符处\n- Fc: 把光标移到同一行的上一个c字符处\n- tc: 把光标移到同一行的下一个c字符前\n- Tc: 把光标移到同一行的上一个c字符后\n- ;: 配合f & t使用，重复一次\n- ,: 配合f & t使用，反向重复一次\n\n上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。\n\n- 0: 移动到行首。\n- g0: 移到光标所在屏幕行行首。\n- ^: 移动到本行第一个非空白字符。\n- g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。\n- $: 移动到行尾。\n- g$: 移动光标所在屏幕行行尾。\n- n|: 把光标移到递n列上。\n- nG: 到文件第n行。\n- :n<cr> 移动到第n行。\n- :$<cr> 移动到最后一行。\n- H: 把光标移到屏幕最顶端一行。\n- M: 把光标移到屏幕中间一行。\n- L: 把光标移到屏幕最底端一行。\n- gg: 到文件头部。\n- G: 到文件尾部。\n\n## [4.2 翻屏](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id65)\n\n- ctrl+f: 下翻一屏。\n- ctrl+b: 上翻一屏。\n- ctrl+d: 下翻半屏。\n- ctrl+u: 上翻半屏。\n- ctrl+e: 向下滚动一行。\n- ctrl+y: 向上滚动一行。\n- n%: 到文件n%的位置。\n- zz: 将当前行移动到屏幕中央。\n- zt: 将当前行移动到屏幕顶端。\n- zb: 将当前行移动到屏幕底端。\n\n## [4.3 标记](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id66)\n\n使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 *后退* 和 *前进* 。\n\n- m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。\n- m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。\n- `{a-z}: 移动到标记位置。\n- '{a-z}: 移动到标记行的行首。\n- `{0-9}：回到上[2-10]次关闭vim时最后离开的位置。\n- ``: 移动到上次编辑的位置。''也可以，不过``精确到列，而''精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。\n- `\": 移动到上次离开的地方。\n- `.: 移动到最后改动的地方。\n- :marks 显示所有标记。\n- :delmarks a b -- 删除标记a和b。\n- :delmarks a-c -- 删除标记a、b和c。\n- :delmarks a c-f -- 删除标记a、c、d、e、f。\n- :delmarks! -- 删除当前缓冲区的所有标记。\n- :help mark-motions 查看更多关于mark的知识。\n\n# [5. 插入文本](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id67)\n\n## [5.1 基本插入](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id68)\n\n- i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+<esc>就插入了36个+组成的分割线。\n- I: 在当前行第一个非空字符前插入；\n- gI: 在当前行第一列插入；\n- a: 在光标后插入；\n- A: 在当前行最后插入；\n- o: 在下面新建一行插入；\n- O: 在上面新建一行插入；\n- :r filename在当前位置插入另一个文件的内容。\n- :[n]r filename在第n行插入另一个文件的内容。\n- :r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。\n\n## [5.2 改写插入](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id69)\n\n- c[n]w: 改写光标后1(n)个词。\n- c[n]l: 改写光标后n个字母。\n- c[n]h: 改写光标前n个字母。\n- [n]cc: 修改当前[n]行。\n- [n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。\n- [n]S: 删除指定数目的行，并以所输入文本代替之。\n\n注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。\n\n# [6. 剪切复制和寄存器](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id70)\n\n## [6.1 剪切和复制、粘贴](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id71)\n\n- [n]x: 剪切光标右边n个字符，相当于d[n]l。\n- [n]X: 剪切光标左边n个字符，相当于d[n]h。\n- y: 复制在可视模式下选中的文本。\n- yy or Y: 复制整行文本。\n- y[n]w: 复制一(n)个词。\n- y[n]l: 复制光标右边1(n)个字符。\n- y[n]h: 复制光标左边1(n)个字符。\n- y$: 从光标当前位置复制到行尾。\n- y0: 从光标当前位置复制到行首。\n- :m,ny<cr> 复制m行到n行的内容。\n- y1G或ygg: 复制光标以上的所有行。\n- yG: 复制光标以下的所有行。\n- yaw和yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。\n- d: 删除（剪切）在可视模式下选中的文本。\n- d$ or D: 删除（剪切）当前位置到行尾的内容。\n- d[n]w: 删除（剪切）1(n)个单词\n- d[n]l: 删除（剪切）光标右边1(n)个字符。\n- d[n]h: 删除（剪切）光标左边1(n)个字符。\n- d0: 删除（剪切）当前位置到行首的内容\n- [n] dd: 删除（剪切）1(n)行。\n- :m,nd<cr> 剪切m行到n行的内容。\n- d1G或dgg: 剪切光标以上的所有行。\n- dG: 剪切光标以下的所有行。\n- daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。\n- d/f<cr>：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。\n- p: 在光标之后粘贴。\n- P: 在光标之前粘贴。\n\n## [6.2 文本对象](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id72)\n\n- aw：一个词\n- as：一句。\n- ap：一段。\n- ab：一块（包含在圆括号中的）。\n\ny, d, c, v都可以跟文本对象。\n\n## [6.3 寄存器](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id73)\n\n- a-z：都可以用作寄存器名。\"ayy把当前行的内容放入a寄存器。\n- A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如\"Ayy把当前行的内容追加到a寄存器中。\n- :reg 显示所有寄存器的内容。\n- \"\"：不加寄存器索引时，默认使用的寄存器。\n- \"*：当前选择缓冲区，\"*yy把当前行的内容放入当前选择缓冲区。\n- \"+：系统剪贴板。\"+yy把当前行的内容放入系统剪贴板。\n\n# [7. 查找与替换](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id74)\n\n## [7.1 查找](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id75)\n\n- /something: 在后面的文本中查找something。\n- ?something: 在前面的文本中查找something。\n- /pattern/+number: 将光标停在包含pattern的行后面第number行上。\n- /pattern/-number: 将光标停在包含pattern的行前面第number行上。\n- n: 向后查找下一个。\n- N: 向前查找下一个。\n\n可以用grep或vimgrep查找一个模式都在哪些地方出现过，\n\n其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。\n\n用法为： :vim[grep]/pattern/[g] [j] files\n\ng的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。\n\nj的含义是grep结束后，结果停在第j项，默认是停在第一项。\n\nvimgrep前面可以加数字限定搜索结果的上限，如\n\n:1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。\n\n \n\n其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。\n\n比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：\n\n:vim/^d{1,}./ %\n\n然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，\n\n就更像个目录了。\n\n## [7.2 替换](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id76)\n\n- :s/old/new - 用new替换当前行第一个old。\n- :s/old/new/g - 用new替换当前行所有的old。\n- :n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。\n- :%s/old/new/g - 用new替换文件中所有的old。\n- :%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。\n- :%s/$/xxx/g - 在每一行的行尾插入xxx，$表示行尾。\n- 所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。\n\n还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，\n\n语法为 :[range]g/pattern/command\n\n例如 :%g/^ xyz/normal dd。\n\n表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。\n\n关于range的规定为：\n\n- 如果不指定range，则表示当前行。\n- m,n: 从m行到n行。\n- 0: 最开始一行（可能是这样）。\n- $: 最后一行\n- .: 当前行\n- %: 所有行\n\n## [7.3 正则表达式](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id77)\n\n高级的查找替换就要用到正则表达式。\n\n- \\d: 表示十进制数（我猜的）\n- \\s: 表示空格\n- \\S: 非空字符\n- \\a: 英文字母\n- \\|: 表示 或\n- \\.: 表示.\n- {m,n}: 表示m到n个字符。这要和 \\s与\\a等连用，如 \\a\\{m,n} 表示m 到n个英文字母。\n- {m,}: 表示m到无限多个字符。\n- **: 当前目录下的所有子目录。\n\n:help pattern得到更多帮助。\n\n------\n\n# [8. 排版](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id78)\n\n## [8.1 基本排版](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id79)\n\n- << 向左缩进一个shiftwidth\n- \\>> 向右缩进一个shiftwidth\n- :ce(nter) 本行文字居中\n- :le(ft) 本行文字靠左\n- :ri(ght) 本行文字靠右\n- gq 对选中的文字重排，即对过长的文字进行断行\n- gqq 重排当前行\n- gqnq 重排n行\n- gqap 重排当前段\n- gqnap 重排n段\n- gqnj 重排当前行和下面n行\n- gqQ 重排当前段对文章末尾\n- J 拼接当前行和下一行\n- gJ 同 J ，不过合并后不留空格。\n\n## [8.2 拼写检查](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id80)\n\n- :set spell－开启拼写检查功能\n- :set nospell－关闭拼写检查功能\n- ]s－移到下一个拼写错误的单词\n- [s－作用与上一命令类似，但它是从相反方向进行搜索\n- z=－显示一个有关拼写错误单词的列表，可从中选择\n- zg－告诉拼写检查器该单词是拼写正确的\n- zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的\n\n## [8.3 统计字数](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id81)\n\ng ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。\n\n------\n\n# [9. 编辑多个文件](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id82)\n\n## [9.1 一次编辑多个文件](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id83)\n\n我们可以一次打开多个文件，如\n\n> ```\n> vi a.txt b.txt c.txt\n> ```\n\n- 使用:next(:n)编辑下一个文件。\n- :2n 编辑下2个文件。\n- 使用:previous或:N编辑上一个文件。\n- 使用:wnext，保存当前文件，并编辑下一个文件。\n- 使用:wprevious，保存当前文件，并编辑上一个文件。\n- 使用:args 显示文件列表。\n- :n filenames或:args filenames 指定新的文件列表。\n- vi -o filenames 在水平分割的多个窗口中编辑多个文件。\n- vi -O filenames 在垂直分割的多个窗口中编辑多个文件。\n\n## [9.2 多标签编辑](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id84)\n\n- vim -p files: 打开多个文件，每个文件占用一个标签页。\n- :tabe, tabnew -- 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。\n- ^w gf -- 在新的标签页里打开光标下路径指定的文件。\n- :tabn -- 切换到下一个标签。Control + PageDown，也可以。\n- :tabp -- 切换到上一个标签。Control + PageUp，也可以。\n- [n] gt -- 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。\n- :tab split -- 将当前缓冲区的内容在新页签中打开。\n- :tabc[lose] -- 关闭当前的标签页。\n- :tabo[nly] -- 关闭其它的标签页。\n- :tabs -- 列出所有的标签页和它们包含的窗口。\n- :tabm[ove] [N] -- 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。\n\n## [9.3 缓冲区](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id85)\n\n- :buffers或:ls或:files 显示缓冲区列表。\n- ctrl+^：在最近两个缓冲区间切换。\n- :bn -- 下一个缓冲区。\n- :bp -- 上一个缓冲区。\n- :bl -- 最后一个缓冲区。\n- :b[n]或:[n]b -- 切换到第n个缓冲区。\n- :nbw(ipeout) -- 彻底删除第n个缓冲区。\n- :nbd(elete) -- 删除第n个缓冲区，并未真正删除，还在unlisted列表中。\n- :ba[ll] -- 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。\n\n# [10. 分屏编辑](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id86)\n\n- vim -o file1 file2:水平分割窗口，同时打开file1和file2\n- vim -O file1 file2:垂直分割窗口，同时打开file1和file2\n\n## [10.1 水平分割](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id87)\n\n- :split(:sp) -- 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。\n- :split filename -- 水平分割窗口，并在新窗口中显示另一个文件。\n- :nsplit(:nsp) -- 水平分割出一个n行高的窗口。\n- :[N]new -- 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N)\n- ctrl+w f --水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。\n- C-w C-^ -- 水平分割一个窗口，打开刚才编辑的文件。\n\n## [10.2 垂直分割](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id88)\n\n- :vsplit(:vsp) -- 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V)\n- :[N]vne[w] -- 垂直分割出一个新窗口。\n- :vertical 水平分割的命令： 相应的垂直分割。\n\n## [10.3 关闭子窗口](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id89)\n\n- :qall -- 关闭所有窗口，退出vim。\n- :wall -- 保存所有修改过的窗口。\n- :only -- 只保留当前窗口，关闭其它窗口。(CTRL-W o)\n- :close -- 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )\n\n## [10.4 调整窗口大小](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id90)\n\n- ctrl+w + --当前窗口增高一行。也可以用n增高n行。\n- ctrl+w - --当前窗口减小一行。也可以用n减小n行。\n- ctrl+w _ --当前窗口扩展到尽可能的大。也可以用n设定行数。\n- :resize n -- 当前窗口n行高。\n- ctrl+w = -- 所有窗口同样高度。\n- n ctrl+w _ -- 当前窗口的高度设定为n行。\n- ctrl+w < --当前窗口减少一列。也可以用n减少n列。\n- ctrl+w > --当前窗口增宽一列。也可以用n增宽n列。\n- ctrl+w | --当前窗口尽可能的宽。也可以用n设定列数。\n\n## [10.5 切换和移动窗口](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id91)\n\n如果支持鼠标，切换和调整子窗口的大小就简单了。\n\n- ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。\n- ctrl+w p: 切换到前一个窗口。\n- ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。\n- ctrl+w t(b):切换到最上（下）面的窗口。<BR>\n- ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。\n- ctrl+w r：旋转窗口的位置。\n- ctrl+w T: 将当前的窗口移动到新的标签页上。\n\n# [11. 快速编辑](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id92)\n\n## [11.1 改变大小写](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id93)\n\n- ~: 反转光标所在字符的大小写。\n- 可视模式下的U或u：把选中的文本变为大写或小写。\n- gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。\n\n## [11.2 替换（normal模式）](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id94)\n\n- r: 替换光标处的字符，同样支持汉字。\n- R: 进入替换模式，按esc回到正常模式。\n\n## [11.3 撤消与重做（normal模式）](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id95)\n\n- [n] u: 取消一(n)个改动。\n- :undo 5 -- 撤销5个改变。\n- :undolist -- 你的撤销历史。\n- ctrl + r: 重做最后的改动。\n- U: 取消当前行中所有的改动。\n- :earlier 4m -- 回到4分钟前\n- :later 55s -- 前进55秒\n\n## [11.4 宏](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id96)\n\n- . --重复上一个编辑动作\n- qa：开始录制宏a（键盘操作记录）\n- q：停止录制\n- @a：播放宏a\n\n# [12. 编辑特殊文件](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id97)\n\n## [12.1 文件加解密](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id98)\n\n- vim -x file: 开始编辑一个加密的文件。\n- :X -- 为当前文件设置密码。\n- :set key= -- 去除文件的密码。\n\n[这里是](http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html) 滇狐总结的比较高级的vi技巧。\n\n## [12.2 文件的编码](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id99)\n\n- :e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。\n- :w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。\n- :set fenc或:set fileencoding，查看当前文件的编码。\n- 在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。\n\n让vim 正确处理文件格式和文件编码，有赖于 [~/.vimrc的正确配置](http://www.cnblogs.com/jiqingwu/admin/vimrc.html)\n\n## [12.3 文件格式](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id100)\n\n大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。\n\n- :e ++ff=dos filename, 让vim用dos格式打开这个文件。\n- :w ++ff=mac filename, 以mac格式存储这个文件。\n- :set ff，显示当前文件的格式。\n- 在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。\n\n# [13. 编程辅助](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id101)\n\n## [13.1 一些按键](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id102)\n\n- gd: 跳转到局部变量的定义处；\n- gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；\n- g;: 上一个修改过的地方；\n- g,: 下一个修改过的地方；\n- [[: 跳转到上一个函数块开始，需要有单独一行的{。\n- ]]: 跳转到下一个函数块开始，需要有单独一行的{。\n- []: 跳转到上一个函数块结束，需要有单独一行的}。\n- ][: 跳转到下一个函数块结束，需要有单独一行的}。\n- [{: 跳转到当前块开始处；\n- ]}: 跳转到当前块结束处；\n- [/: 跳转到当前注释块开始处；\n- ]/: 跳转到当前注释块结束处；\n- %: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。\n\n下面的括号匹配对编程很实用的。\n\n- ci', di', yi'：修改、剪切或复制'之间的内容。\n- ca', da', ya'：修改、剪切或复制'之间的内容，包含'。\n- ci\", di\", yi\"：修改、剪切或复制\"之间的内容。\n- ca\", da\", ya\"：修改、剪切或复制\"之间的内容，包含\"。\n- ci(, di(, yi(：修改、剪切或复制()之间的内容。\n- ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。\n- ci[, di[, yi[：修改、剪切或复制[]之间的内容。\n- ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。\n- ci{, di{, yi{：修改、剪切或复制{}之间的内容。\n- ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。\n- ci<, di<, yi<：修改、剪切或复制<>之间的内容。\n- ca<, da<, ya<：修改、剪切或复制<>之间的内容，包含<>。\n\n## [13.2 ctags](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id103)\n\n- ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags\n- :set tags=path/tags -- 告诉ctags使用哪个tag文件\n- :tag xyz -- 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t\n- :stag xyz -- 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口\n- :ptag xyz -- 在预览窗口中打开xyz的定义，热键是C-w }。\n- :pclose -- 关闭预览窗口。热键是C-w z。\n- :pedit abc.h -- 在预览窗口中编辑abc.h\n- :psearch abc -- 搜索当前文件和当前文件include的文件，显示包含abc的行。\n\n有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。\n\n- :[n]tnext -- 下一[n]个匹配。\n- :[n]tprev -- 上一[n]个匹配。\n- :tfirst -- 第一个匹配\n- :tlast -- 最后一个匹配\n- :tselect tagname -- 打开选择列表\n\ntab键补齐\n\n- :tag xyz<tab> -- 补齐以xyz开头的tag名，继续按tab键，会显示其他的。\n- :tag /xyz<tab> -- 会用名字中含有xyz的tag名补全。\n\n## [13.3 cscope](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id104)\n\n- cscope -Rbq: 生成cscope.out文件\n- :cs add /path/to/cscope.out /your/work/dir\n- :cs find c func -- 查找func在哪些地方被调用\n- :cw -- 打开quickfix窗口查看结果\n\n## [13.4 gtags](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id105)\n\nGtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。\n\n- :Gtags funcname 定位到 funcname 的定义处。\n- :Gtags -r funcname 查询 funcname被引用的地方。\n- :Gtags -s symbol 定位 symbol 出现的地方。\n- :Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。\n- :Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。\n- :Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示vm目录下的文件。\n\n## [13.5 编译](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id106)\n\nvim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。\n\n如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.java文件，你可以这样设置：\n\n```\nset makeprg=javac\\ abc.java\n```\n\n然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如：\n\n```\n:setl efm=%A%f:%l:\\ %m,%-Z%p^,%-C%.%#\n```\n\n%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。\n\n## [13.6 快速修改窗口](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id107)\n\n其实是quickfix插件提供的功能， 对编译调试程序非常有用 :)\n\n- :copen -- 打开快速修改窗口。\n- :cclose -- 关闭快速修改窗口。\n\n快速修改窗口在make程序时非常有用，当make之后：\n\n- :cl -- 在快速修改窗口中列出错误。\n- :cn -- 定位到下一个错误。\n- :cp -- 定位到上一个错误。\n- :cr -- 定位到第一个错误。\n\n## [13.7 自动补全](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id108)\n\n- C-x C-s -- 拼写建议。\n- C-x C-v -- 补全vim选项和命令。\n- C-x C-l -- 整行补全。\n- C-x C-f -- 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。\n- C-x C-p 和C-x C-n -- 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。\n- C-x C-o -- 编程时可以补全关键字和函数名啊。\n- C-x C-i -- 根据头文件内关键字补全。\n- C-x C-d -- 补全宏定义。\n- C-x C-n -- 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。\n\n当弹出补全菜单后：\n\n- C-p 向前切换成员；\n- C-n 向后切换成员；\n- C-e 退出下拉菜单，并退回到原来录入的文字；\n- C-y 退出下拉菜单，并接受当前选项。\n\n## [13.8 多行缩进缩出](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id109)\n\n- 正常模式下，按两下>;光标所在行会缩进。\n- 如果先按了n，再按两下>;，光标以下的n行会缩进。\n- 对应的，按两下<;，光标所在行会缩出。\n- 如果在编辑代码文件，可以用=进行调整。\n- 在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。\n- 或者n =，调整n行代码的缩排。\n\n## [13.9 折叠](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id110)\n\n- zf -- 创建折叠的命令，可以在一个可视区域上使用该命令；\n- zd -- 删除当前行的折叠；\n- zD -- 删除当前行的折叠；\n- zfap -- 折叠光标所在的段；\n- zo -- 打开折叠的文本；\n- zc -- 收起折叠；\n- za -- 打开/关闭当前折叠；\n- zr -- 打开嵌套的折行；\n- zm -- 收起嵌套的折行；\n- zR (zO) -- 打开所有折行；\n- zM (zC) -- 收起所有折行；\n- zj -- 跳到下一个折叠处；\n- zk -- 跳到上一个折叠处；\n- zi -- enable/disable fold;\n\n# [14. 命令行](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id111)\n\nnormal模式下按:进入命令行模式\n\n## [14.1 命令行模式下的快捷键：](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id112)\n\n- 上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。\n- 左右方向键：左/右移一个字符。\n- C-w： 向前删除一个单词。\n- C-h： 向前删除一个字符，等同于Backspace。\n- C-u： 从当前位置移动到命令行开头。\n- C-b： 移动到命令行开头。\n- C-e： 移动到命令行末尾。\n- Shift-Left： 左移一个单词。\n- Shift-Right： 右移一个单词。\n- @： 重复上一次的冒号命令。\n- q： 正常模式下，q然后按':'，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。\n- q/和q? 可以打开查找历史记录。\n\n## [14.2 执行外部命令](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id113)\n\n- :! cmd 执行外部命令。\n- :!! 执行上一次的外部命令。\n- :sh 调用shell，用exit返回vim。\n- :r !cmd 将命令的返回结果插入文件当前位置。\n- :m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。\n\n# [15. 其它](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id114)\n\n## [15.1 工作目录](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id115)\n\n- :pwd 显示vim的工作目录。\n- :cd path 改变vim的工作目录。\n- :set autochdir 可以让vim 根据编辑的文件自动切换工作目录。\n\n## [15.2 一些快捷键（收集中）](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id116)\n\n- K: 打开光标所在词的manpage。\n- *: 向下搜索光标所在词。\n- g*: 同上，但部分符合即可。\n- \\#: 向上搜索光标所在词。\n- g#: 同上，但部分符合即可。\n- g C-g: 统计全文或统计部分的字数。\n\n## [15.3 在线帮助](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id117)\n\n- :h(elp)或F1 打开总的帮助。\n- :help user-manual 打开用户手册。\n- 命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。\n- :helptags somepath 为somepath中的文档生成索引。\n- :helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。\n- Ctrl+] 跳转到tag主题，Ctrl+t 跳回。\n- :ver 显示版本信息。\n\n## [15.4 一些小功能](http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id118)\n\n- 简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果。","slug":"常见问题/云服务器/vim快捷键","published":1,"updated":"2020-01-23T09:40:45.901Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qn1b88001c3v8nb52p6t2x","content":"<p><em>经使用了两年多的Vim，手册也翻过一遍。虽然现在不怎么用vim了，曾经的笔记还是贴出来，与喜欢vim的朋友分享。</em></p>\n<a id=\"more\"></a>\n\n<h1 id=\"1-关于Vim\"><a href=\"#1-关于Vim\" class=\"headerlink\" title=\"1. 关于Vim\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id59\" target=\"_blank\" rel=\"noopener\">1. 关于Vim</a></h1><p>vim是我最喜欢的编辑器，也是linux下第二强大的编辑器。 虽然emacs是公认的世界第一，我认为使用emacs并没有使用vi进行编辑来得高效。 如果是初学vi，运行一下vimtutor是个聪明的决定。 （如果你的系统环境不是中文，而你想使用中文的vimtutor，就运行vimtutor zh）</p>\n<h2 id=\"1-1-Vim的几种模式\"><a href=\"#1-1-Vim的几种模式\" class=\"headerlink\" title=\"1.1 Vim的几种模式\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id60\" target=\"_blank\" rel=\"noopener\">1.1 Vim的几种模式</a></h2><ul>\n<li>正常模式：可以使用快捷键命令，或按:输入命令行。</li>\n<li>插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。</li>\n<li>可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。</li>\n<li>替换模式：正常模式下，按R进入。</li>\n</ul>\n<h1 id=\"2-启动Vim\"><a href=\"#2-启动Vim\" class=\"headerlink\" title=\"2. 启动Vim\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id61\" target=\"_blank\" rel=\"noopener\">2. 启动Vim</a></h1><ul>\n<li>vim -c cmd file: 在打开文件前，先执行指定的命令；</li>\n<li>vim -r file: 恢复上次异常退出的文件；</li>\n<li>vim -R file: 以只读的方式打开文件，但可以强制保存；</li>\n<li>vim -M file: 以只读的方式打开文件，不可以强制保存；</li>\n<li>vim -y num file: 将编辑窗口的大小设为num行；</li>\n<li>vim + file: 从文件的末尾开始；</li>\n<li>vim +num file: 从第num行开始；</li>\n<li>vim +/string file: 打开file，并将光标停留在第一个找到的string上。</li>\n<li>vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</li>\n</ul>\n<h1 id=\"3-文档操作\"><a href=\"#3-文档操作\" class=\"headerlink\" title=\"3. 文档操作\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id62\" target=\"_blank\" rel=\"noopener\">3. 文档操作</a></h1><ul>\n<li>:e file –关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。</li>\n<li>:e! file –放弃对当前文件的修改，编辑新的文件。</li>\n<li>:e+file – 开始新的文件，并从文件尾开始编辑。</li>\n<li>:e+n file – 开始新的文件，并从第n行开始编辑。</li>\n<li>:enew –编译一个未命名的新文档。(CTRL-W n)</li>\n<li>:e – 重新加载当前文档。</li>\n<li>:e! – 重新加载当前文档，并丢弃已做的改动。</li>\n<li>:e#或ctrl+^ – 回到刚才编辑的文件，很实用。</li>\n<li>:f或ctrl+g – 显示文档名，是否修改，和光标位置。</li>\n<li>:f filename – 改变编辑的文件名，这时再保存相当于另存为。</li>\n<li>gf – 打开以光标所在字符串为文件名的文件。</li>\n<li>:w – 保存修改。</li>\n<li>:n1,n2w filename – 选择性保存从某n1行到另n2行的内容。</li>\n<li>:wq – 保存并退出。</li>\n<li>ZZ – 保存并退出。</li>\n<li>:x – 保存并退出。</li>\n<li>:q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)</li>\n<li>:saveas newfilename – 另存为</li>\n<li>:browse e – 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：<ul>\n<li>:set browsedir=last – 用上次访问过的目录（默认）；</li>\n<li>:set browsedir=buffer – 用当前文件所在目录；</li>\n<li>:set browsedir=current – 用当前工作目录；</li>\n</ul>\n</li>\n<li>:Sex – 水平分割一个窗口，浏览文件系统；</li>\n<li>:Vex – 垂直分割一个窗口，浏览文件系统；</li>\n</ul>\n<h1 id=\"4-光标的移动\"><a href=\"#4-光标的移动\" class=\"headerlink\" title=\"4. 光标的移动\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id63\" target=\"_blank\" rel=\"noopener\">4. 光标的移动</a></h1><h2 id=\"4-1-基本移动\"><a href=\"#4-1-基本移动\" class=\"headerlink\" title=\"4.1 基本移动\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id64\" target=\"_blank\" rel=\"noopener\">4.1 基本移动</a></h2><p>以下移动都是在normal模式下。</p>\n<ul>\n<li>h或退格: 左移一个字符；</li>\n<li>l或空格: 右移一个字符；</li>\n<li>j: 下移一行；</li>\n<li>k: 上移一行；</li>\n<li>gj: 移动到一段内的下一行；</li>\n<li>gk: 移动到一段内的上一行；</li>\n<li>+或Enter: 把光标移至下一行第一个非空白字符。</li>\n<li>-: 把光标移至上一行第一个非空白字符。</li>\n<li>w: 前移一个单词，光标停在下一个单词开头；</li>\n<li>W: 移动下一个单词开头，但忽略一些标点；</li>\n<li>e: 前移一个单词，光标停在下一个单词末尾；</li>\n<li>E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</li>\n<li>b: 后移一个单词，光标停在上一个单词开头；</li>\n<li>B: 移动到上一个单词开头，忽略一些标点；</li>\n<li>ge: 后移一个单词，光标停在上一个单词末尾；</li>\n<li>gE: 同 ge ，不过‘单词’包含单词相邻的标点。</li>\n<li>(: 前移1句。</li>\n<li>): 后移1句。</li>\n<li>{: 前移1段。</li>\n<li>}: 后移1段。</li>\n<li>fc: 把光标移到同一行的下一个c字符处</li>\n<li>Fc: 把光标移到同一行的上一个c字符处</li>\n<li>tc: 把光标移到同一行的下一个c字符前</li>\n<li>Tc: 把光标移到同一行的上一个c字符后</li>\n<li>;: 配合f &amp; t使用，重复一次</li>\n<li>,: 配合f &amp; t使用，反向重复一次</li>\n</ul>\n<p>上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</p>\n<ul>\n<li>0: 移动到行首。</li>\n<li>g0: 移到光标所在屏幕行行首。</li>\n<li>^: 移动到本行第一个非空白字符。</li>\n<li>g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。</li>\n<li>$: 移动到行尾。</li>\n<li>g$: 移动光标所在屏幕行行尾。</li>\n<li>n|: 把光标移到递n列上。</li>\n<li>nG: 到文件第n行。</li>\n<li>:n<cr> 移动到第n行。</li>\n<li>:$<cr> 移动到最后一行。</li>\n<li>H: 把光标移到屏幕最顶端一行。</li>\n<li>M: 把光标移到屏幕中间一行。</li>\n<li>L: 把光标移到屏幕最底端一行。</li>\n<li>gg: 到文件头部。</li>\n<li>G: 到文件尾部。</li>\n</ul>\n<h2 id=\"4-2-翻屏\"><a href=\"#4-2-翻屏\" class=\"headerlink\" title=\"4.2 翻屏\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id65\" target=\"_blank\" rel=\"noopener\">4.2 翻屏</a></h2><ul>\n<li>ctrl+f: 下翻一屏。</li>\n<li>ctrl+b: 上翻一屏。</li>\n<li>ctrl+d: 下翻半屏。</li>\n<li>ctrl+u: 上翻半屏。</li>\n<li>ctrl+e: 向下滚动一行。</li>\n<li>ctrl+y: 向上滚动一行。</li>\n<li>n%: 到文件n%的位置。</li>\n<li>zz: 将当前行移动到屏幕中央。</li>\n<li>zt: 将当前行移动到屏幕顶端。</li>\n<li>zb: 将当前行移动到屏幕底端。</li>\n</ul>\n<h2 id=\"4-3-标记\"><a href=\"#4-3-标记\" class=\"headerlink\" title=\"4.3 标记\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id66\" target=\"_blank\" rel=\"noopener\">4.3 标记</a></h2><p>使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 <em>后退</em> 和 <em>前进</em> 。</p>\n<ul>\n<li>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。</li>\n<li>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li>\n<li>`{a-z}: 移动到标记位置。</li>\n<li>‘{a-z}: 移动到标记行的行首。</li>\n<li>`{0-9}：回到上[2-10]次关闭vim时最后离开的位置。</li>\n<li><code>: 移动到上次编辑的位置。&#39;&#39;也可以，不过</code>精确到列，而’’精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</li>\n<li>`”: 移动到上次离开的地方。</li>\n<li>`.: 移动到最后改动的地方。</li>\n<li>:marks 显示所有标记。</li>\n<li>:delmarks a b – 删除标记a和b。</li>\n<li>:delmarks a-c – 删除标记a、b和c。</li>\n<li>:delmarks a c-f – 删除标记a、c、d、e、f。</li>\n<li>:delmarks! – 删除当前缓冲区的所有标记。</li>\n<li>:help mark-motions 查看更多关于mark的知识。</li>\n</ul>\n<h1 id=\"5-插入文本\"><a href=\"#5-插入文本\" class=\"headerlink\" title=\"5. 插入文本\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id67\" target=\"_blank\" rel=\"noopener\">5. 插入文本</a></h1><h2 id=\"5-1-基本插入\"><a href=\"#5-1-基本插入\" class=\"headerlink\" title=\"5.1 基本插入\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id68\" target=\"_blank\" rel=\"noopener\">5.1 基本插入</a></h2><ul>\n<li>i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+<esc>就插入了36个+组成的分割线。</li>\n<li>I: 在当前行第一个非空字符前插入；</li>\n<li>gI: 在当前行第一列插入；</li>\n<li>a: 在光标后插入；</li>\n<li>A: 在当前行最后插入；</li>\n<li>o: 在下面新建一行插入；</li>\n<li>O: 在上面新建一行插入；</li>\n<li>:r filename在当前位置插入另一个文件的内容。</li>\n<li>:[n]r filename在第n行插入另一个文件的内容。</li>\n<li>:r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。</li>\n</ul>\n<h2 id=\"5-2-改写插入\"><a href=\"#5-2-改写插入\" class=\"headerlink\" title=\"5.2 改写插入\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id69\" target=\"_blank\" rel=\"noopener\">5.2 改写插入</a></h2><ul>\n<li>c[n]w: 改写光标后1(n)个词。</li>\n<li>c[n]l: 改写光标后n个字母。</li>\n<li>c[n]h: 改写光标前n个字母。</li>\n<li>[n]cc: 修改当前[n]行。</li>\n<li>[n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。</li>\n<li>[n]S: 删除指定数目的行，并以所输入文本代替之。</li>\n</ul>\n<p>注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。</p>\n<h1 id=\"6-剪切复制和寄存器\"><a href=\"#6-剪切复制和寄存器\" class=\"headerlink\" title=\"6. 剪切复制和寄存器\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id70\" target=\"_blank\" rel=\"noopener\">6. 剪切复制和寄存器</a></h1><h2 id=\"6-1-剪切和复制、粘贴\"><a href=\"#6-1-剪切和复制、粘贴\" class=\"headerlink\" title=\"6.1 剪切和复制、粘贴\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id71\" target=\"_blank\" rel=\"noopener\">6.1 剪切和复制、粘贴</a></h2><ul>\n<li>[n]x: 剪切光标右边n个字符，相当于d[n]l。</li>\n<li>[n]X: 剪切光标左边n个字符，相当于d[n]h。</li>\n<li>y: 复制在可视模式下选中的文本。</li>\n<li>yy or Y: 复制整行文本。</li>\n<li>y[n]w: 复制一(n)个词。</li>\n<li>y[n]l: 复制光标右边1(n)个字符。</li>\n<li>y[n]h: 复制光标左边1(n)个字符。</li>\n<li>y$: 从光标当前位置复制到行尾。</li>\n<li>y0: 从光标当前位置复制到行首。</li>\n<li>:m,ny<cr> 复制m行到n行的内容。</li>\n<li>y1G或ygg: 复制光标以上的所有行。</li>\n<li>yG: 复制光标以下的所有行。</li>\n<li>yaw和yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。</li>\n<li>d: 删除（剪切）在可视模式下选中的文本。</li>\n<li>d$ or D: 删除（剪切）当前位置到行尾的内容。</li>\n<li>d[n]w: 删除（剪切）1(n)个单词</li>\n<li>d[n]l: 删除（剪切）光标右边1(n)个字符。</li>\n<li>d[n]h: 删除（剪切）光标左边1(n)个字符。</li>\n<li>d0: 删除（剪切）当前位置到行首的内容</li>\n<li>[n] dd: 删除（剪切）1(n)行。</li>\n<li>:m,nd<cr> 剪切m行到n行的内容。</li>\n<li>d1G或dgg: 剪切光标以上的所有行。</li>\n<li>dG: 剪切光标以下的所有行。</li>\n<li>daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li>\n<li>d/f<cr>：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。</li>\n<li>p: 在光标之后粘贴。</li>\n<li>P: 在光标之前粘贴。</li>\n</ul>\n<h2 id=\"6-2-文本对象\"><a href=\"#6-2-文本对象\" class=\"headerlink\" title=\"6.2 文本对象\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id72\" target=\"_blank\" rel=\"noopener\">6.2 文本对象</a></h2><ul>\n<li>aw：一个词</li>\n<li>as：一句。</li>\n<li>ap：一段。</li>\n<li>ab：一块（包含在圆括号中的）。</li>\n</ul>\n<p>y, d, c, v都可以跟文本对象。</p>\n<h2 id=\"6-3-寄存器\"><a href=\"#6-3-寄存器\" class=\"headerlink\" title=\"6.3 寄存器\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id73\" target=\"_blank\" rel=\"noopener\">6.3 寄存器</a></h2><ul>\n<li>a-z：都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。</li>\n<li>A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如”Ayy把当前行的内容追加到a寄存器中。</li>\n<li>:reg 显示所有寄存器的内容。</li>\n<li>“”：不加寄存器索引时，默认使用的寄存器。</li>\n<li>“<em>：当前选择缓冲区，”</em>yy把当前行的内容放入当前选择缓冲区。</li>\n<li>“+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。</li>\n</ul>\n<h1 id=\"7-查找与替换\"><a href=\"#7-查找与替换\" class=\"headerlink\" title=\"7. 查找与替换\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id74\" target=\"_blank\" rel=\"noopener\">7. 查找与替换</a></h1><h2 id=\"7-1-查找\"><a href=\"#7-1-查找\" class=\"headerlink\" title=\"7.1 查找\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id75\" target=\"_blank\" rel=\"noopener\">7.1 查找</a></h2><ul>\n<li>/something: 在后面的文本中查找something。</li>\n<li>?something: 在前面的文本中查找something。</li>\n<li>/pattern/+number: 将光标停在包含pattern的行后面第number行上。</li>\n<li>/pattern/-number: 将光标停在包含pattern的行前面第number行上。</li>\n<li>n: 向后查找下一个。</li>\n<li>N: 向前查找下一个。</li>\n</ul>\n<p>可以用grep或vimgrep查找一个模式都在哪些地方出现过，</p>\n<p>其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。</p>\n<p>用法为： :vim[grep]/pattern/[g] [j] files</p>\n<p>g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</p>\n<p>j的含义是grep结束后，结果停在第j项，默认是停在第一项。</p>\n<p>vimgrep前面可以加数字限定搜索结果的上限，如</p>\n<p>:1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。</p>\n<p>其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。</p>\n<p>比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：</p>\n<p>:vim/^d{1,}./ %</p>\n<p>然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，</p>\n<p>就更像个目录了。</p>\n<h2 id=\"7-2-替换\"><a href=\"#7-2-替换\" class=\"headerlink\" title=\"7.2 替换\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id76\" target=\"_blank\" rel=\"noopener\">7.2 替换</a></h2><ul>\n<li>:s/old/new - 用new替换当前行第一个old。</li>\n<li>:s/old/new/g - 用new替换当前行所有的old。</li>\n<li>:n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。</li>\n<li>:%s/old/new/g - 用new替换文件中所有的old。</li>\n<li>:%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。</li>\n<li>:%s/$/xxx/g - 在每一行的行尾插入xxx，$表示行尾。</li>\n<li>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。</li>\n</ul>\n<p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，</p>\n<p>语法为 :[range]g/pattern/command</p>\n<p>例如 :%g/^ xyz/normal dd。</p>\n<p>表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。</p>\n<p>关于range的规定为：</p>\n<ul>\n<li>如果不指定range，则表示当前行。</li>\n<li>m,n: 从m行到n行。</li>\n<li>0: 最开始一行（可能是这样）。</li>\n<li>$: 最后一行</li>\n<li>.: 当前行</li>\n<li>%: 所有行</li>\n</ul>\n<h2 id=\"7-3-正则表达式\"><a href=\"#7-3-正则表达式\" class=\"headerlink\" title=\"7.3 正则表达式\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id77\" target=\"_blank\" rel=\"noopener\">7.3 正则表达式</a></h2><p>高级的查找替换就要用到正则表达式。</p>\n<ul>\n<li>\\d: 表示十进制数（我猜的）</li>\n<li>\\s: 表示空格</li>\n<li>\\S: 非空字符</li>\n<li>\\a: 英文字母</li>\n<li>|: 表示 或</li>\n<li>.: 表示.</li>\n<li>{m,n}: 表示m到n个字符。这要和 \\s与\\a等连用，如 \\a{m,n} 表示m 到n个英文字母。</li>\n<li>{m,}: 表示m到无限多个字符。</li>\n<li>**: 当前目录下的所有子目录。</li>\n</ul>\n<p>:help pattern得到更多帮助。</p>\n<hr>\n<h1 id=\"8-排版\"><a href=\"#8-排版\" class=\"headerlink\" title=\"8. 排版\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id78\" target=\"_blank\" rel=\"noopener\">8. 排版</a></h1><h2 id=\"8-1-基本排版\"><a href=\"#8-1-基本排版\" class=\"headerlink\" title=\"8.1 基本排版\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id79\" target=\"_blank\" rel=\"noopener\">8.1 基本排版</a></h2><ul>\n<li>&lt;&lt; 向左缩进一个shiftwidth</li>\n<li>&gt;&gt; 向右缩进一个shiftwidth</li>\n<li>:ce(nter) 本行文字居中</li>\n<li>:le(ft) 本行文字靠左</li>\n<li>:ri(ght) 本行文字靠右</li>\n<li>gq 对选中的文字重排，即对过长的文字进行断行</li>\n<li>gqq 重排当前行</li>\n<li>gqnq 重排n行</li>\n<li>gqap 重排当前段</li>\n<li>gqnap 重排n段</li>\n<li>gqnj 重排当前行和下面n行</li>\n<li>gqQ 重排当前段对文章末尾</li>\n<li>J 拼接当前行和下一行</li>\n<li>gJ 同 J ，不过合并后不留空格。</li>\n</ul>\n<h2 id=\"8-2-拼写检查\"><a href=\"#8-2-拼写检查\" class=\"headerlink\" title=\"8.2 拼写检查\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id80\" target=\"_blank\" rel=\"noopener\">8.2 拼写检查</a></h2><ul>\n<li>:set spell－开启拼写检查功能</li>\n<li>:set nospell－关闭拼写检查功能</li>\n<li>]s－移到下一个拼写错误的单词</li>\n<li>[s－作用与上一命令类似，但它是从相反方向进行搜索</li>\n<li>z=－显示一个有关拼写错误单词的列表，可从中选择</li>\n<li>zg－告诉拼写检查器该单词是拼写正确的</li>\n<li>zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的</li>\n</ul>\n<h2 id=\"8-3-统计字数\"><a href=\"#8-3-统计字数\" class=\"headerlink\" title=\"8.3 统计字数\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id81\" target=\"_blank\" rel=\"noopener\">8.3 统计字数</a></h2><p>g ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。</p>\n<hr>\n<h1 id=\"9-编辑多个文件\"><a href=\"#9-编辑多个文件\" class=\"headerlink\" title=\"9. 编辑多个文件\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id82\" target=\"_blank\" rel=\"noopener\">9. 编辑多个文件</a></h1><h2 id=\"9-1-一次编辑多个文件\"><a href=\"#9-1-一次编辑多个文件\" class=\"headerlink\" title=\"9.1 一次编辑多个文件\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id83\" target=\"_blank\" rel=\"noopener\">9.1 一次编辑多个文件</a></h2><p>我们可以一次打开多个文件，如</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi a.txt b.txt c.txt</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>使用:next(:n)编辑下一个文件。</li>\n<li>:2n 编辑下2个文件。</li>\n<li>使用:previous或:N编辑上一个文件。</li>\n<li>使用:wnext，保存当前文件，并编辑下一个文件。</li>\n<li>使用:wprevious，保存当前文件，并编辑上一个文件。</li>\n<li>使用:args 显示文件列表。</li>\n<li>:n filenames或:args filenames 指定新的文件列表。</li>\n<li>vi -o filenames 在水平分割的多个窗口中编辑多个文件。</li>\n<li>vi -O filenames 在垂直分割的多个窗口中编辑多个文件。</li>\n</ul>\n<h2 id=\"9-2-多标签编辑\"><a href=\"#9-2-多标签编辑\" class=\"headerlink\" title=\"9.2 多标签编辑\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id84\" target=\"_blank\" rel=\"noopener\">9.2 多标签编辑</a></h2><ul>\n<li>vim -p files: 打开多个文件，每个文件占用一个标签页。</li>\n<li>:tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li>\n<li>^w gf – 在新的标签页里打开光标下路径指定的文件。</li>\n<li>:tabn – 切换到下一个标签。Control + PageDown，也可以。</li>\n<li>:tabp – 切换到上一个标签。Control + PageUp，也可以。</li>\n<li>[n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。</li>\n<li>:tab split – 将当前缓冲区的内容在新页签中打开。</li>\n<li>:tabc[lose] – 关闭当前的标签页。</li>\n<li>:tabo[nly] – 关闭其它的标签页。</li>\n<li>:tabs – 列出所有的标签页和它们包含的窗口。</li>\n<li>:tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</li>\n</ul>\n<h2 id=\"9-3-缓冲区\"><a href=\"#9-3-缓冲区\" class=\"headerlink\" title=\"9.3 缓冲区\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id85\" target=\"_blank\" rel=\"noopener\">9.3 缓冲区</a></h2><ul>\n<li>:buffers或:ls或:files 显示缓冲区列表。</li>\n<li>ctrl+^：在最近两个缓冲区间切换。</li>\n<li>:bn – 下一个缓冲区。</li>\n<li>:bp – 上一个缓冲区。</li>\n<li>:bl – 最后一个缓冲区。</li>\n<li>:b[n]或:[n]b – 切换到第n个缓冲区。</li>\n<li>:nbw(ipeout) – 彻底删除第n个缓冲区。</li>\n<li>:nbd(elete) – 删除第n个缓冲区，并未真正删除，还在unlisted列表中。</li>\n<li>:ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li>\n</ul>\n<h1 id=\"10-分屏编辑\"><a href=\"#10-分屏编辑\" class=\"headerlink\" title=\"10. 分屏编辑\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id86\" target=\"_blank\" rel=\"noopener\">10. 分屏编辑</a></h1><ul>\n<li>vim -o file1 file2:水平分割窗口，同时打开file1和file2</li>\n<li>vim -O file1 file2:垂直分割窗口，同时打开file1和file2</li>\n</ul>\n<h2 id=\"10-1-水平分割\"><a href=\"#10-1-水平分割\" class=\"headerlink\" title=\"10.1 水平分割\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id87\" target=\"_blank\" rel=\"noopener\">10.1 水平分割</a></h2><ul>\n<li>:split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。</li>\n<li>:split filename – 水平分割窗口，并在新窗口中显示另一个文件。</li>\n<li>:nsplit(:nsp) – 水平分割出一个n行高的窗口。</li>\n<li>:[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N)</li>\n<li>ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li>\n<li>C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。</li>\n</ul>\n<h2 id=\"10-2-垂直分割\"><a href=\"#10-2-垂直分割\" class=\"headerlink\" title=\"10.2 垂直分割\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id88\" target=\"_blank\" rel=\"noopener\">10.2 垂直分割</a></h2><ul>\n<li>:vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V)</li>\n<li>:[N]vne[w] – 垂直分割出一个新窗口。</li>\n<li>:vertical 水平分割的命令： 相应的垂直分割。</li>\n</ul>\n<h2 id=\"10-3-关闭子窗口\"><a href=\"#10-3-关闭子窗口\" class=\"headerlink\" title=\"10.3 关闭子窗口\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id89\" target=\"_blank\" rel=\"noopener\">10.3 关闭子窗口</a></h2><ul>\n<li>:qall – 关闭所有窗口，退出vim。</li>\n<li>:wall – 保存所有修改过的窗口。</li>\n<li>:only – 只保留当前窗口，关闭其它窗口。(CTRL-W o)</li>\n<li>:close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )</li>\n</ul>\n<h2 id=\"10-4-调整窗口大小\"><a href=\"#10-4-调整窗口大小\" class=\"headerlink\" title=\"10.4 调整窗口大小\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id90\" target=\"_blank\" rel=\"noopener\">10.4 调整窗口大小</a></h2><ul>\n<li>ctrl+w + –当前窗口增高一行。也可以用n增高n行。</li>\n<li>ctrl+w - –当前窗口减小一行。也可以用n减小n行。</li>\n<li>ctrl+w _ –当前窗口扩展到尽可能的大。也可以用n设定行数。</li>\n<li>:resize n – 当前窗口n行高。</li>\n<li>ctrl+w = – 所有窗口同样高度。</li>\n<li>n ctrl+w _ – 当前窗口的高度设定为n行。</li>\n<li>ctrl+w &lt; –当前窗口减少一列。也可以用n减少n列。</li>\n<li>ctrl+w &gt; –当前窗口增宽一列。也可以用n增宽n列。</li>\n<li>ctrl+w | –当前窗口尽可能的宽。也可以用n设定列数。</li>\n</ul>\n<h2 id=\"10-5-切换和移动窗口\"><a href=\"#10-5-切换和移动窗口\" class=\"headerlink\" title=\"10.5 切换和移动窗口\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id91\" target=\"_blank\" rel=\"noopener\">10.5 切换和移动窗口</a></h2><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p>\n<ul>\n<li>ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。</li>\n<li>ctrl+w p: 切换到前一个窗口。</li>\n<li>ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。</li>\n<li>ctrl+w t(b):切换到最上（下）面的窗口。<BR></li>\n<li>ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。</li>\n<li>ctrl+w r：旋转窗口的位置。</li>\n<li>ctrl+w T: 将当前的窗口移动到新的标签页上。</li>\n</ul>\n<h1 id=\"11-快速编辑\"><a href=\"#11-快速编辑\" class=\"headerlink\" title=\"11. 快速编辑\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id92\" target=\"_blank\" rel=\"noopener\">11. 快速编辑</a></h1><h2 id=\"11-1-改变大小写\"><a href=\"#11-1-改变大小写\" class=\"headerlink\" title=\"11.1 改变大小写\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id93\" target=\"_blank\" rel=\"noopener\">11.1 改变大小写</a></h2><ul>\n<li>~: 反转光标所在字符的大小写。</li>\n<li>可视模式下的U或u：把选中的文本变为大写或小写。</li>\n<li>gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。</li>\n</ul>\n<h2 id=\"11-2-替换（normal模式）\"><a href=\"#11-2-替换（normal模式）\" class=\"headerlink\" title=\"11.2 替换（normal模式）\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id94\" target=\"_blank\" rel=\"noopener\">11.2 替换（normal模式）</a></h2><ul>\n<li>r: 替换光标处的字符，同样支持汉字。</li>\n<li>R: 进入替换模式，按esc回到正常模式。</li>\n</ul>\n<h2 id=\"11-3-撤消与重做（normal模式）\"><a href=\"#11-3-撤消与重做（normal模式）\" class=\"headerlink\" title=\"11.3 撤消与重做（normal模式）\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id95\" target=\"_blank\" rel=\"noopener\">11.3 撤消与重做（normal模式）</a></h2><ul>\n<li>[n] u: 取消一(n)个改动。</li>\n<li>:undo 5 – 撤销5个改变。</li>\n<li>:undolist – 你的撤销历史。</li>\n<li>ctrl + r: 重做最后的改动。</li>\n<li>U: 取消当前行中所有的改动。</li>\n<li>:earlier 4m – 回到4分钟前</li>\n<li>:later 55s – 前进55秒</li>\n</ul>\n<h2 id=\"11-4-宏\"><a href=\"#11-4-宏\" class=\"headerlink\" title=\"11.4 宏\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id96\" target=\"_blank\" rel=\"noopener\">11.4 宏</a></h2><ul>\n<li>. –重复上一个编辑动作</li>\n<li>qa：开始录制宏a（键盘操作记录）</li>\n<li>q：停止录制</li>\n<li>@a：播放宏a</li>\n</ul>\n<h1 id=\"12-编辑特殊文件\"><a href=\"#12-编辑特殊文件\" class=\"headerlink\" title=\"12. 编辑特殊文件\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id97\" target=\"_blank\" rel=\"noopener\">12. 编辑特殊文件</a></h1><h2 id=\"12-1-文件加解密\"><a href=\"#12-1-文件加解密\" class=\"headerlink\" title=\"12.1 文件加解密\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id98\" target=\"_blank\" rel=\"noopener\">12.1 文件加解密</a></h2><ul>\n<li>vim -x file: 开始编辑一个加密的文件。</li>\n<li>:X – 为当前文件设置密码。</li>\n<li>:set key= – 去除文件的密码。</li>\n</ul>\n<p><a href=\"http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html\" target=\"_blank\" rel=\"noopener\">这里是</a> 滇狐总结的比较高级的vi技巧。</p>\n<h2 id=\"12-2-文件的编码\"><a href=\"#12-2-文件的编码\" class=\"headerlink\" title=\"12.2 文件的编码\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id99\" target=\"_blank\" rel=\"noopener\">12.2 文件的编码</a></h2><ul>\n<li>:e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。</li>\n<li>:w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。</li>\n<li>:set fenc或:set fileencoding，查看当前文件的编码。</li>\n<li>在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。</li>\n</ul>\n<p>让vim 正确处理文件格式和文件编码，有赖于 <a href=\"http://www.cnblogs.com/jiqingwu/admin/vimrc.html\" target=\"_blank\" rel=\"noopener\">~/.vimrc的正确配置</a></p>\n<h2 id=\"12-3-文件格式\"><a href=\"#12-3-文件格式\" class=\"headerlink\" title=\"12.3 文件格式\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id100\" target=\"_blank\" rel=\"noopener\">12.3 文件格式</a></h2><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p>\n<ul>\n<li>:e ++ff=dos filename, 让vim用dos格式打开这个文件。</li>\n<li>:w ++ff=mac filename, 以mac格式存储这个文件。</li>\n<li>:set ff，显示当前文件的格式。</li>\n<li>在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。</li>\n</ul>\n<h1 id=\"13-编程辅助\"><a href=\"#13-编程辅助\" class=\"headerlink\" title=\"13. 编程辅助\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id101\" target=\"_blank\" rel=\"noopener\">13. 编程辅助</a></h1><h2 id=\"13-1-一些按键\"><a href=\"#13-1-一些按键\" class=\"headerlink\" title=\"13.1 一些按键\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id102\" target=\"_blank\" rel=\"noopener\">13.1 一些按键</a></h2><ul>\n<li>gd: 跳转到局部变量的定义处；</li>\n<li>gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；</li>\n<li>g;: 上一个修改过的地方；</li>\n<li>g,: 下一个修改过的地方；</li>\n<li>[[: 跳转到上一个函数块开始，需要有单独一行的{。</li>\n<li>]]: 跳转到下一个函数块开始，需要有单独一行的{。</li>\n<li>[]: 跳转到上一个函数块结束，需要有单独一行的}。</li>\n<li>][: 跳转到下一个函数块结束，需要有单独一行的}。</li>\n<li>[{: 跳转到当前块开始处；</li>\n<li>]}: 跳转到当前块结束处；</li>\n<li>[/: 跳转到当前注释块开始处；</li>\n<li>]/: 跳转到当前注释块结束处；</li>\n<li>%: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。</li>\n</ul>\n<p>下面的括号匹配对编程很实用的。</p>\n<ul>\n<li>ci’, di’, yi’：修改、剪切或复制’之间的内容。</li>\n<li>ca’, da’, ya’：修改、剪切或复制’之间的内容，包含’。</li>\n<li>ci”, di”, yi”：修改、剪切或复制”之间的内容。</li>\n<li>ca”, da”, ya”：修改、剪切或复制”之间的内容，包含”。</li>\n<li>ci(, di(, yi(：修改、剪切或复制()之间的内容。</li>\n<li>ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。</li>\n<li>ci[, di[, yi[：修改、剪切或复制[]之间的内容。</li>\n<li>ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。</li>\n<li>ci{, di{, yi{：修改、剪切或复制{}之间的内容。</li>\n<li>ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。</li>\n<li>ci&lt;, di&lt;, yi&lt;：修改、剪切或复制&lt;&gt;之间的内容。</li>\n<li>ca&lt;, da&lt;, ya&lt;：修改、剪切或复制&lt;&gt;之间的内容，包含&lt;&gt;。</li>\n</ul>\n<h2 id=\"13-2-ctags\"><a href=\"#13-2-ctags\" class=\"headerlink\" title=\"13.2 ctags\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id103\" target=\"_blank\" rel=\"noopener\">13.2 ctags</a></h2><ul>\n<li>ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags</li>\n<li>:set tags=path/tags – 告诉ctags使用哪个tag文件</li>\n<li>:tag xyz – 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t</li>\n<li>:stag xyz – 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口</li>\n<li>:ptag xyz – 在预览窗口中打开xyz的定义，热键是C-w }。</li>\n<li>:pclose – 关闭预览窗口。热键是C-w z。</li>\n<li>:pedit abc.h – 在预览窗口中编辑abc.h</li>\n<li>:psearch abc – 搜索当前文件和当前文件include的文件，显示包含abc的行。</li>\n</ul>\n<p>有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p>\n<ul>\n<li>:[n]tnext – 下一[n]个匹配。</li>\n<li>:[n]tprev – 上一[n]个匹配。</li>\n<li>:tfirst – 第一个匹配</li>\n<li>:tlast – 最后一个匹配</li>\n<li>:tselect tagname – 打开选择列表</li>\n</ul>\n<p>tab键补齐</p>\n<ul>\n<li>:tag xyz<tab> – 补齐以xyz开头的tag名，继续按tab键，会显示其他的。</li>\n<li>:tag /xyz<tab> – 会用名字中含有xyz的tag名补全。</li>\n</ul>\n<h2 id=\"13-3-cscope\"><a href=\"#13-3-cscope\" class=\"headerlink\" title=\"13.3 cscope\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id104\" target=\"_blank\" rel=\"noopener\">13.3 cscope</a></h2><ul>\n<li>cscope -Rbq: 生成cscope.out文件</li>\n<li>:cs add /path/to/cscope.out /your/work/dir</li>\n<li>:cs find c func – 查找func在哪些地方被调用</li>\n<li>:cw – 打开quickfix窗口查看结果</li>\n</ul>\n<h2 id=\"13-4-gtags\"><a href=\"#13-4-gtags\" class=\"headerlink\" title=\"13.4 gtags\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id105\" target=\"_blank\" rel=\"noopener\">13.4 gtags</a></h2><p>Gtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。</p>\n<ul>\n<li>:Gtags funcname 定位到 funcname 的定义处。</li>\n<li>:Gtags -r funcname 查询 funcname被引用的地方。</li>\n<li>:Gtags -s symbol 定位 symbol 出现的地方。</li>\n<li>:Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。</li>\n<li>:Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。</li>\n<li>:Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示vm目录下的文件。</li>\n</ul>\n<h2 id=\"13-5-编译\"><a href=\"#13-5-编译\" class=\"headerlink\" title=\"13.5 编译\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id106\" target=\"_blank\" rel=\"noopener\">13.5 编译</a></h2><p>vim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。</p>\n<p>如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.java文件，你可以这样设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set makeprg&#x3D;javac\\ abc.java</span><br></pre></td></tr></table></figure>\n\n<p>然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:setl efm&#x3D;%A%f:%l:\\ %m,%-Z%p^,%-C%.%#</span><br></pre></td></tr></table></figure>\n\n<p>%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。</p>\n<h2 id=\"13-6-快速修改窗口\"><a href=\"#13-6-快速修改窗口\" class=\"headerlink\" title=\"13.6 快速修改窗口\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id107\" target=\"_blank\" rel=\"noopener\">13.6 快速修改窗口</a></h2><p>其实是quickfix插件提供的功能， 对编译调试程序非常有用 :)</p>\n<ul>\n<li>:copen – 打开快速修改窗口。</li>\n<li>:cclose – 关闭快速修改窗口。</li>\n</ul>\n<p>快速修改窗口在make程序时非常有用，当make之后：</p>\n<ul>\n<li>:cl – 在快速修改窗口中列出错误。</li>\n<li>:cn – 定位到下一个错误。</li>\n<li>:cp – 定位到上一个错误。</li>\n<li>:cr – 定位到第一个错误。</li>\n</ul>\n<h2 id=\"13-7-自动补全\"><a href=\"#13-7-自动补全\" class=\"headerlink\" title=\"13.7 自动补全\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id108\" target=\"_blank\" rel=\"noopener\">13.7 自动补全</a></h2><ul>\n<li>C-x C-s – 拼写建议。</li>\n<li>C-x C-v – 补全vim选项和命令。</li>\n<li>C-x C-l – 整行补全。</li>\n<li>C-x C-f – 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。</li>\n<li>C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。</li>\n<li>C-x C-o – 编程时可以补全关键字和函数名啊。</li>\n<li>C-x C-i – 根据头文件内关键字补全。</li>\n<li>C-x C-d – 补全宏定义。</li>\n<li>C-x C-n – 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。</li>\n</ul>\n<p>当弹出补全菜单后：</p>\n<ul>\n<li>C-p 向前切换成员；</li>\n<li>C-n 向后切换成员；</li>\n<li>C-e 退出下拉菜单，并退回到原来录入的文字；</li>\n<li>C-y 退出下拉菜单，并接受当前选项。</li>\n</ul>\n<h2 id=\"13-8-多行缩进缩出\"><a href=\"#13-8-多行缩进缩出\" class=\"headerlink\" title=\"13.8 多行缩进缩出\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id109\" target=\"_blank\" rel=\"noopener\">13.8 多行缩进缩出</a></h2><ul>\n<li>正常模式下，按两下&gt;;光标所在行会缩进。</li>\n<li>如果先按了n，再按两下&gt;;，光标以下的n行会缩进。</li>\n<li>对应的，按两下&lt;;，光标所在行会缩出。</li>\n<li>如果在编辑代码文件，可以用=进行调整。</li>\n<li>在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。</li>\n<li>或者n =，调整n行代码的缩排。</li>\n</ul>\n<h2 id=\"13-9-折叠\"><a href=\"#13-9-折叠\" class=\"headerlink\" title=\"13.9 折叠\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id110\" target=\"_blank\" rel=\"noopener\">13.9 折叠</a></h2><ul>\n<li>zf – 创建折叠的命令，可以在一个可视区域上使用该命令；</li>\n<li>zd – 删除当前行的折叠；</li>\n<li>zD – 删除当前行的折叠；</li>\n<li>zfap – 折叠光标所在的段；</li>\n<li>zo – 打开折叠的文本；</li>\n<li>zc – 收起折叠；</li>\n<li>za – 打开/关闭当前折叠；</li>\n<li>zr – 打开嵌套的折行；</li>\n<li>zm – 收起嵌套的折行；</li>\n<li>zR (zO) – 打开所有折行；</li>\n<li>zM (zC) – 收起所有折行；</li>\n<li>zj – 跳到下一个折叠处；</li>\n<li>zk – 跳到上一个折叠处；</li>\n<li>zi – enable/disable fold;</li>\n</ul>\n<h1 id=\"14-命令行\"><a href=\"#14-命令行\" class=\"headerlink\" title=\"14. 命令行\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id111\" target=\"_blank\" rel=\"noopener\">14. 命令行</a></h1><p>normal模式下按:进入命令行模式</p>\n<h2 id=\"14-1-命令行模式下的快捷键：\"><a href=\"#14-1-命令行模式下的快捷键：\" class=\"headerlink\" title=\"14.1 命令行模式下的快捷键：\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id112\" target=\"_blank\" rel=\"noopener\">14.1 命令行模式下的快捷键：</a></h2><ul>\n<li>上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。</li>\n<li>左右方向键：左/右移一个字符。</li>\n<li>C-w： 向前删除一个单词。</li>\n<li>C-h： 向前删除一个字符，等同于Backspace。</li>\n<li>C-u： 从当前位置移动到命令行开头。</li>\n<li>C-b： 移动到命令行开头。</li>\n<li>C-e： 移动到命令行末尾。</li>\n<li>Shift-Left： 左移一个单词。</li>\n<li>Shift-Right： 右移一个单词。</li>\n<li>@： 重复上一次的冒号命令。</li>\n<li>q： 正常模式下，q然后按’:’，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。</li>\n<li>q/和q? 可以打开查找历史记录。</li>\n</ul>\n<h2 id=\"14-2-执行外部命令\"><a href=\"#14-2-执行外部命令\" class=\"headerlink\" title=\"14.2 执行外部命令\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id113\" target=\"_blank\" rel=\"noopener\">14.2 执行外部命令</a></h2><ul>\n<li>:! cmd 执行外部命令。</li>\n<li>:!! 执行上一次的外部命令。</li>\n<li>:sh 调用shell，用exit返回vim。</li>\n<li>:r !cmd 将命令的返回结果插入文件当前位置。</li>\n<li>:m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。</li>\n</ul>\n<h1 id=\"15-其它\"><a href=\"#15-其它\" class=\"headerlink\" title=\"15. 其它\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id114\" target=\"_blank\" rel=\"noopener\">15. 其它</a></h1><h2 id=\"15-1-工作目录\"><a href=\"#15-1-工作目录\" class=\"headerlink\" title=\"15.1 工作目录\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id115\" target=\"_blank\" rel=\"noopener\">15.1 工作目录</a></h2><ul>\n<li>:pwd 显示vim的工作目录。</li>\n<li>:cd path 改变vim的工作目录。</li>\n<li>:set autochdir 可以让vim 根据编辑的文件自动切换工作目录。</li>\n</ul>\n<h2 id=\"15-2-一些快捷键（收集中）\"><a href=\"#15-2-一些快捷键（收集中）\" class=\"headerlink\" title=\"15.2 一些快捷键（收集中）\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id116\" target=\"_blank\" rel=\"noopener\">15.2 一些快捷键（收集中）</a></h2><ul>\n<li>K: 打开光标所在词的manpage。</li>\n<li>*: 向下搜索光标所在词。</li>\n<li>g*: 同上，但部分符合即可。</li>\n<li>#: 向上搜索光标所在词。</li>\n<li>g#: 同上，但部分符合即可。</li>\n<li>g C-g: 统计全文或统计部分的字数。</li>\n</ul>\n<h2 id=\"15-3-在线帮助\"><a href=\"#15-3-在线帮助\" class=\"headerlink\" title=\"15.3 在线帮助\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id117\" target=\"_blank\" rel=\"noopener\">15.3 在线帮助</a></h2><ul>\n<li>:h(elp)或F1 打开总的帮助。</li>\n<li>:help user-manual 打开用户手册。</li>\n<li>命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li>\n<li>:helptags somepath 为somepath中的文档生成索引。</li>\n<li>:helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。</li>\n<li>Ctrl+] 跳转到tag主题，Ctrl+t 跳回。</li>\n<li>:ver 显示版本信息。</li>\n</ul>\n<h2 id=\"15-4-一些小功能\"><a href=\"#15-4-一些小功能\" class=\"headerlink\" title=\"15.4 一些小功能\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id118\" target=\"_blank\" rel=\"noopener\">15.4 一些小功能</a></h2><ul>\n<li>简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><em>经使用了两年多的Vim，手册也翻过一遍。虽然现在不怎么用vim了，曾经的笔记还是贴出来，与喜欢vim的朋友分享。</em></p>","more":"<h1 id=\"1-关于Vim\"><a href=\"#1-关于Vim\" class=\"headerlink\" title=\"1. 关于Vim\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id59\" target=\"_blank\" rel=\"noopener\">1. 关于Vim</a></h1><p>vim是我最喜欢的编辑器，也是linux下第二强大的编辑器。 虽然emacs是公认的世界第一，我认为使用emacs并没有使用vi进行编辑来得高效。 如果是初学vi，运行一下vimtutor是个聪明的决定。 （如果你的系统环境不是中文，而你想使用中文的vimtutor，就运行vimtutor zh）</p>\n<h2 id=\"1-1-Vim的几种模式\"><a href=\"#1-1-Vim的几种模式\" class=\"headerlink\" title=\"1.1 Vim的几种模式\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id60\" target=\"_blank\" rel=\"noopener\">1.1 Vim的几种模式</a></h2><ul>\n<li>正常模式：可以使用快捷键命令，或按:输入命令行。</li>\n<li>插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。</li>\n<li>可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。</li>\n<li>替换模式：正常模式下，按R进入。</li>\n</ul>\n<h1 id=\"2-启动Vim\"><a href=\"#2-启动Vim\" class=\"headerlink\" title=\"2. 启动Vim\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id61\" target=\"_blank\" rel=\"noopener\">2. 启动Vim</a></h1><ul>\n<li>vim -c cmd file: 在打开文件前，先执行指定的命令；</li>\n<li>vim -r file: 恢复上次异常退出的文件；</li>\n<li>vim -R file: 以只读的方式打开文件，但可以强制保存；</li>\n<li>vim -M file: 以只读的方式打开文件，不可以强制保存；</li>\n<li>vim -y num file: 将编辑窗口的大小设为num行；</li>\n<li>vim + file: 从文件的末尾开始；</li>\n<li>vim +num file: 从第num行开始；</li>\n<li>vim +/string file: 打开file，并将光标停留在第一个找到的string上。</li>\n<li>vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</li>\n</ul>\n<h1 id=\"3-文档操作\"><a href=\"#3-文档操作\" class=\"headerlink\" title=\"3. 文档操作\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id62\" target=\"_blank\" rel=\"noopener\">3. 文档操作</a></h1><ul>\n<li>:e file –关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。</li>\n<li>:e! file –放弃对当前文件的修改，编辑新的文件。</li>\n<li>:e+file – 开始新的文件，并从文件尾开始编辑。</li>\n<li>:e+n file – 开始新的文件，并从第n行开始编辑。</li>\n<li>:enew –编译一个未命名的新文档。(CTRL-W n)</li>\n<li>:e – 重新加载当前文档。</li>\n<li>:e! – 重新加载当前文档，并丢弃已做的改动。</li>\n<li>:e#或ctrl+^ – 回到刚才编辑的文件，很实用。</li>\n<li>:f或ctrl+g – 显示文档名，是否修改，和光标位置。</li>\n<li>:f filename – 改变编辑的文件名，这时再保存相当于另存为。</li>\n<li>gf – 打开以光标所在字符串为文件名的文件。</li>\n<li>:w – 保存修改。</li>\n<li>:n1,n2w filename – 选择性保存从某n1行到另n2行的内容。</li>\n<li>:wq – 保存并退出。</li>\n<li>ZZ – 保存并退出。</li>\n<li>:x – 保存并退出。</li>\n<li>:q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)</li>\n<li>:saveas newfilename – 另存为</li>\n<li>:browse e – 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：<ul>\n<li>:set browsedir=last – 用上次访问过的目录（默认）；</li>\n<li>:set browsedir=buffer – 用当前文件所在目录；</li>\n<li>:set browsedir=current – 用当前工作目录；</li>\n</ul>\n</li>\n<li>:Sex – 水平分割一个窗口，浏览文件系统；</li>\n<li>:Vex – 垂直分割一个窗口，浏览文件系统；</li>\n</ul>\n<h1 id=\"4-光标的移动\"><a href=\"#4-光标的移动\" class=\"headerlink\" title=\"4. 光标的移动\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id63\" target=\"_blank\" rel=\"noopener\">4. 光标的移动</a></h1><h2 id=\"4-1-基本移动\"><a href=\"#4-1-基本移动\" class=\"headerlink\" title=\"4.1 基本移动\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id64\" target=\"_blank\" rel=\"noopener\">4.1 基本移动</a></h2><p>以下移动都是在normal模式下。</p>\n<ul>\n<li>h或退格: 左移一个字符；</li>\n<li>l或空格: 右移一个字符；</li>\n<li>j: 下移一行；</li>\n<li>k: 上移一行；</li>\n<li>gj: 移动到一段内的下一行；</li>\n<li>gk: 移动到一段内的上一行；</li>\n<li>+或Enter: 把光标移至下一行第一个非空白字符。</li>\n<li>-: 把光标移至上一行第一个非空白字符。</li>\n<li>w: 前移一个单词，光标停在下一个单词开头；</li>\n<li>W: 移动下一个单词开头，但忽略一些标点；</li>\n<li>e: 前移一个单词，光标停在下一个单词末尾；</li>\n<li>E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</li>\n<li>b: 后移一个单词，光标停在上一个单词开头；</li>\n<li>B: 移动到上一个单词开头，忽略一些标点；</li>\n<li>ge: 后移一个单词，光标停在上一个单词末尾；</li>\n<li>gE: 同 ge ，不过‘单词’包含单词相邻的标点。</li>\n<li>(: 前移1句。</li>\n<li>): 后移1句。</li>\n<li>{: 前移1段。</li>\n<li>}: 后移1段。</li>\n<li>fc: 把光标移到同一行的下一个c字符处</li>\n<li>Fc: 把光标移到同一行的上一个c字符处</li>\n<li>tc: 把光标移到同一行的下一个c字符前</li>\n<li>Tc: 把光标移到同一行的上一个c字符后</li>\n<li>;: 配合f &amp; t使用，重复一次</li>\n<li>,: 配合f &amp; t使用，反向重复一次</li>\n</ul>\n<p>上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</p>\n<ul>\n<li>0: 移动到行首。</li>\n<li>g0: 移到光标所在屏幕行行首。</li>\n<li>^: 移动到本行第一个非空白字符。</li>\n<li>g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。</li>\n<li>$: 移动到行尾。</li>\n<li>g$: 移动光标所在屏幕行行尾。</li>\n<li>n|: 把光标移到递n列上。</li>\n<li>nG: 到文件第n行。</li>\n<li>:n<cr> 移动到第n行。</li>\n<li>:$<cr> 移动到最后一行。</li>\n<li>H: 把光标移到屏幕最顶端一行。</li>\n<li>M: 把光标移到屏幕中间一行。</li>\n<li>L: 把光标移到屏幕最底端一行。</li>\n<li>gg: 到文件头部。</li>\n<li>G: 到文件尾部。</li>\n</ul>\n<h2 id=\"4-2-翻屏\"><a href=\"#4-2-翻屏\" class=\"headerlink\" title=\"4.2 翻屏\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id65\" target=\"_blank\" rel=\"noopener\">4.2 翻屏</a></h2><ul>\n<li>ctrl+f: 下翻一屏。</li>\n<li>ctrl+b: 上翻一屏。</li>\n<li>ctrl+d: 下翻半屏。</li>\n<li>ctrl+u: 上翻半屏。</li>\n<li>ctrl+e: 向下滚动一行。</li>\n<li>ctrl+y: 向上滚动一行。</li>\n<li>n%: 到文件n%的位置。</li>\n<li>zz: 将当前行移动到屏幕中央。</li>\n<li>zt: 将当前行移动到屏幕顶端。</li>\n<li>zb: 将当前行移动到屏幕底端。</li>\n</ul>\n<h2 id=\"4-3-标记\"><a href=\"#4-3-标记\" class=\"headerlink\" title=\"4.3 标记\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id66\" target=\"_blank\" rel=\"noopener\">4.3 标记</a></h2><p>使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 <em>后退</em> 和 <em>前进</em> 。</p>\n<ul>\n<li>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。</li>\n<li>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li>\n<li>`{a-z}: 移动到标记位置。</li>\n<li>‘{a-z}: 移动到标记行的行首。</li>\n<li>`{0-9}：回到上[2-10]次关闭vim时最后离开的位置。</li>\n<li><code>: 移动到上次编辑的位置。&#39;&#39;也可以，不过</code>精确到列，而’’精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</li>\n<li>`”: 移动到上次离开的地方。</li>\n<li>`.: 移动到最后改动的地方。</li>\n<li>:marks 显示所有标记。</li>\n<li>:delmarks a b – 删除标记a和b。</li>\n<li>:delmarks a-c – 删除标记a、b和c。</li>\n<li>:delmarks a c-f – 删除标记a、c、d、e、f。</li>\n<li>:delmarks! – 删除当前缓冲区的所有标记。</li>\n<li>:help mark-motions 查看更多关于mark的知识。</li>\n</ul>\n<h1 id=\"5-插入文本\"><a href=\"#5-插入文本\" class=\"headerlink\" title=\"5. 插入文本\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id67\" target=\"_blank\" rel=\"noopener\">5. 插入文本</a></h1><h2 id=\"5-1-基本插入\"><a href=\"#5-1-基本插入\" class=\"headerlink\" title=\"5.1 基本插入\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id68\" target=\"_blank\" rel=\"noopener\">5.1 基本插入</a></h2><ul>\n<li>i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+<esc>就插入了36个+组成的分割线。</li>\n<li>I: 在当前行第一个非空字符前插入；</li>\n<li>gI: 在当前行第一列插入；</li>\n<li>a: 在光标后插入；</li>\n<li>A: 在当前行最后插入；</li>\n<li>o: 在下面新建一行插入；</li>\n<li>O: 在上面新建一行插入；</li>\n<li>:r filename在当前位置插入另一个文件的内容。</li>\n<li>:[n]r filename在第n行插入另一个文件的内容。</li>\n<li>:r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。</li>\n</ul>\n<h2 id=\"5-2-改写插入\"><a href=\"#5-2-改写插入\" class=\"headerlink\" title=\"5.2 改写插入\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id69\" target=\"_blank\" rel=\"noopener\">5.2 改写插入</a></h2><ul>\n<li>c[n]w: 改写光标后1(n)个词。</li>\n<li>c[n]l: 改写光标后n个字母。</li>\n<li>c[n]h: 改写光标前n个字母。</li>\n<li>[n]cc: 修改当前[n]行。</li>\n<li>[n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。</li>\n<li>[n]S: 删除指定数目的行，并以所输入文本代替之。</li>\n</ul>\n<p>注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。</p>\n<h1 id=\"6-剪切复制和寄存器\"><a href=\"#6-剪切复制和寄存器\" class=\"headerlink\" title=\"6. 剪切复制和寄存器\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id70\" target=\"_blank\" rel=\"noopener\">6. 剪切复制和寄存器</a></h1><h2 id=\"6-1-剪切和复制、粘贴\"><a href=\"#6-1-剪切和复制、粘贴\" class=\"headerlink\" title=\"6.1 剪切和复制、粘贴\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id71\" target=\"_blank\" rel=\"noopener\">6.1 剪切和复制、粘贴</a></h2><ul>\n<li>[n]x: 剪切光标右边n个字符，相当于d[n]l。</li>\n<li>[n]X: 剪切光标左边n个字符，相当于d[n]h。</li>\n<li>y: 复制在可视模式下选中的文本。</li>\n<li>yy or Y: 复制整行文本。</li>\n<li>y[n]w: 复制一(n)个词。</li>\n<li>y[n]l: 复制光标右边1(n)个字符。</li>\n<li>y[n]h: 复制光标左边1(n)个字符。</li>\n<li>y$: 从光标当前位置复制到行尾。</li>\n<li>y0: 从光标当前位置复制到行首。</li>\n<li>:m,ny<cr> 复制m行到n行的内容。</li>\n<li>y1G或ygg: 复制光标以上的所有行。</li>\n<li>yG: 复制光标以下的所有行。</li>\n<li>yaw和yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。</li>\n<li>d: 删除（剪切）在可视模式下选中的文本。</li>\n<li>d$ or D: 删除（剪切）当前位置到行尾的内容。</li>\n<li>d[n]w: 删除（剪切）1(n)个单词</li>\n<li>d[n]l: 删除（剪切）光标右边1(n)个字符。</li>\n<li>d[n]h: 删除（剪切）光标左边1(n)个字符。</li>\n<li>d0: 删除（剪切）当前位置到行首的内容</li>\n<li>[n] dd: 删除（剪切）1(n)行。</li>\n<li>:m,nd<cr> 剪切m行到n行的内容。</li>\n<li>d1G或dgg: 剪切光标以上的所有行。</li>\n<li>dG: 剪切光标以下的所有行。</li>\n<li>daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li>\n<li>d/f<cr>：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。</li>\n<li>p: 在光标之后粘贴。</li>\n<li>P: 在光标之前粘贴。</li>\n</ul>\n<h2 id=\"6-2-文本对象\"><a href=\"#6-2-文本对象\" class=\"headerlink\" title=\"6.2 文本对象\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id72\" target=\"_blank\" rel=\"noopener\">6.2 文本对象</a></h2><ul>\n<li>aw：一个词</li>\n<li>as：一句。</li>\n<li>ap：一段。</li>\n<li>ab：一块（包含在圆括号中的）。</li>\n</ul>\n<p>y, d, c, v都可以跟文本对象。</p>\n<h2 id=\"6-3-寄存器\"><a href=\"#6-3-寄存器\" class=\"headerlink\" title=\"6.3 寄存器\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id73\" target=\"_blank\" rel=\"noopener\">6.3 寄存器</a></h2><ul>\n<li>a-z：都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。</li>\n<li>A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如”Ayy把当前行的内容追加到a寄存器中。</li>\n<li>:reg 显示所有寄存器的内容。</li>\n<li>“”：不加寄存器索引时，默认使用的寄存器。</li>\n<li>“<em>：当前选择缓冲区，”</em>yy把当前行的内容放入当前选择缓冲区。</li>\n<li>“+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。</li>\n</ul>\n<h1 id=\"7-查找与替换\"><a href=\"#7-查找与替换\" class=\"headerlink\" title=\"7. 查找与替换\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id74\" target=\"_blank\" rel=\"noopener\">7. 查找与替换</a></h1><h2 id=\"7-1-查找\"><a href=\"#7-1-查找\" class=\"headerlink\" title=\"7.1 查找\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id75\" target=\"_blank\" rel=\"noopener\">7.1 查找</a></h2><ul>\n<li>/something: 在后面的文本中查找something。</li>\n<li>?something: 在前面的文本中查找something。</li>\n<li>/pattern/+number: 将光标停在包含pattern的行后面第number行上。</li>\n<li>/pattern/-number: 将光标停在包含pattern的行前面第number行上。</li>\n<li>n: 向后查找下一个。</li>\n<li>N: 向前查找下一个。</li>\n</ul>\n<p>可以用grep或vimgrep查找一个模式都在哪些地方出现过，</p>\n<p>其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。</p>\n<p>用法为： :vim[grep]/pattern/[g] [j] files</p>\n<p>g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</p>\n<p>j的含义是grep结束后，结果停在第j项，默认是停在第一项。</p>\n<p>vimgrep前面可以加数字限定搜索结果的上限，如</p>\n<p>:1vim/pattern/ % 只查找那个模式在本文件中的第一个出现。</p>\n<p>其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。</p>\n<p>比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：</p>\n<p>:vim/^d{1,}./ %</p>\n<p>然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，</p>\n<p>就更像个目录了。</p>\n<h2 id=\"7-2-替换\"><a href=\"#7-2-替换\" class=\"headerlink\" title=\"7.2 替换\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id76\" target=\"_blank\" rel=\"noopener\">7.2 替换</a></h2><ul>\n<li>:s/old/new - 用new替换当前行第一个old。</li>\n<li>:s/old/new/g - 用new替换当前行所有的old。</li>\n<li>:n1,n2s/old/new/g - 用new替换文件n1行到n2行所有的old。</li>\n<li>:%s/old/new/g - 用new替换文件中所有的old。</li>\n<li>:%s/^/xxx/g - 在每一行的行首插入xxx，^表示行首。</li>\n<li>:%s/$/xxx/g - 在每一行的行尾插入xxx，$表示行尾。</li>\n<li>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。</li>\n</ul>\n<p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，</p>\n<p>语法为 :[range]g/pattern/command</p>\n<p>例如 :%g/^ xyz/normal dd。</p>\n<p>表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。</p>\n<p>关于range的规定为：</p>\n<ul>\n<li>如果不指定range，则表示当前行。</li>\n<li>m,n: 从m行到n行。</li>\n<li>0: 最开始一行（可能是这样）。</li>\n<li>$: 最后一行</li>\n<li>.: 当前行</li>\n<li>%: 所有行</li>\n</ul>\n<h2 id=\"7-3-正则表达式\"><a href=\"#7-3-正则表达式\" class=\"headerlink\" title=\"7.3 正则表达式\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id77\" target=\"_blank\" rel=\"noopener\">7.3 正则表达式</a></h2><p>高级的查找替换就要用到正则表达式。</p>\n<ul>\n<li>\\d: 表示十进制数（我猜的）</li>\n<li>\\s: 表示空格</li>\n<li>\\S: 非空字符</li>\n<li>\\a: 英文字母</li>\n<li>|: 表示 或</li>\n<li>.: 表示.</li>\n<li>{m,n}: 表示m到n个字符。这要和 \\s与\\a等连用，如 \\a{m,n} 表示m 到n个英文字母。</li>\n<li>{m,}: 表示m到无限多个字符。</li>\n<li>**: 当前目录下的所有子目录。</li>\n</ul>\n<p>:help pattern得到更多帮助。</p>\n<hr>\n<h1 id=\"8-排版\"><a href=\"#8-排版\" class=\"headerlink\" title=\"8. 排版\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id78\" target=\"_blank\" rel=\"noopener\">8. 排版</a></h1><h2 id=\"8-1-基本排版\"><a href=\"#8-1-基本排版\" class=\"headerlink\" title=\"8.1 基本排版\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id79\" target=\"_blank\" rel=\"noopener\">8.1 基本排版</a></h2><ul>\n<li>&lt;&lt; 向左缩进一个shiftwidth</li>\n<li>&gt;&gt; 向右缩进一个shiftwidth</li>\n<li>:ce(nter) 本行文字居中</li>\n<li>:le(ft) 本行文字靠左</li>\n<li>:ri(ght) 本行文字靠右</li>\n<li>gq 对选中的文字重排，即对过长的文字进行断行</li>\n<li>gqq 重排当前行</li>\n<li>gqnq 重排n行</li>\n<li>gqap 重排当前段</li>\n<li>gqnap 重排n段</li>\n<li>gqnj 重排当前行和下面n行</li>\n<li>gqQ 重排当前段对文章末尾</li>\n<li>J 拼接当前行和下一行</li>\n<li>gJ 同 J ，不过合并后不留空格。</li>\n</ul>\n<h2 id=\"8-2-拼写检查\"><a href=\"#8-2-拼写检查\" class=\"headerlink\" title=\"8.2 拼写检查\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id80\" target=\"_blank\" rel=\"noopener\">8.2 拼写检查</a></h2><ul>\n<li>:set spell－开启拼写检查功能</li>\n<li>:set nospell－关闭拼写检查功能</li>\n<li>]s－移到下一个拼写错误的单词</li>\n<li>[s－作用与上一命令类似，但它是从相反方向进行搜索</li>\n<li>z=－显示一个有关拼写错误单词的列表，可从中选择</li>\n<li>zg－告诉拼写检查器该单词是拼写正确的</li>\n<li>zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的</li>\n</ul>\n<h2 id=\"8-3-统计字数\"><a href=\"#8-3-统计字数\" class=\"headerlink\" title=\"8.3 统计字数\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id81\" target=\"_blank\" rel=\"noopener\">8.3 统计字数</a></h2><p>g ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。</p>\n<hr>\n<h1 id=\"9-编辑多个文件\"><a href=\"#9-编辑多个文件\" class=\"headerlink\" title=\"9. 编辑多个文件\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id82\" target=\"_blank\" rel=\"noopener\">9. 编辑多个文件</a></h1><h2 id=\"9-1-一次编辑多个文件\"><a href=\"#9-1-一次编辑多个文件\" class=\"headerlink\" title=\"9.1 一次编辑多个文件\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id83\" target=\"_blank\" rel=\"noopener\">9.1 一次编辑多个文件</a></h2><p>我们可以一次打开多个文件，如</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi a.txt b.txt c.txt</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>使用:next(:n)编辑下一个文件。</li>\n<li>:2n 编辑下2个文件。</li>\n<li>使用:previous或:N编辑上一个文件。</li>\n<li>使用:wnext，保存当前文件，并编辑下一个文件。</li>\n<li>使用:wprevious，保存当前文件，并编辑上一个文件。</li>\n<li>使用:args 显示文件列表。</li>\n<li>:n filenames或:args filenames 指定新的文件列表。</li>\n<li>vi -o filenames 在水平分割的多个窗口中编辑多个文件。</li>\n<li>vi -O filenames 在垂直分割的多个窗口中编辑多个文件。</li>\n</ul>\n<h2 id=\"9-2-多标签编辑\"><a href=\"#9-2-多标签编辑\" class=\"headerlink\" title=\"9.2 多标签编辑\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id84\" target=\"_blank\" rel=\"noopener\">9.2 多标签编辑</a></h2><ul>\n<li>vim -p files: 打开多个文件，每个文件占用一个标签页。</li>\n<li>:tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li>\n<li>^w gf – 在新的标签页里打开光标下路径指定的文件。</li>\n<li>:tabn – 切换到下一个标签。Control + PageDown，也可以。</li>\n<li>:tabp – 切换到上一个标签。Control + PageUp，也可以。</li>\n<li>[n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。</li>\n<li>:tab split – 将当前缓冲区的内容在新页签中打开。</li>\n<li>:tabc[lose] – 关闭当前的标签页。</li>\n<li>:tabo[nly] – 关闭其它的标签页。</li>\n<li>:tabs – 列出所有的标签页和它们包含的窗口。</li>\n<li>:tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</li>\n</ul>\n<h2 id=\"9-3-缓冲区\"><a href=\"#9-3-缓冲区\" class=\"headerlink\" title=\"9.3 缓冲区\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id85\" target=\"_blank\" rel=\"noopener\">9.3 缓冲区</a></h2><ul>\n<li>:buffers或:ls或:files 显示缓冲区列表。</li>\n<li>ctrl+^：在最近两个缓冲区间切换。</li>\n<li>:bn – 下一个缓冲区。</li>\n<li>:bp – 上一个缓冲区。</li>\n<li>:bl – 最后一个缓冲区。</li>\n<li>:b[n]或:[n]b – 切换到第n个缓冲区。</li>\n<li>:nbw(ipeout) – 彻底删除第n个缓冲区。</li>\n<li>:nbd(elete) – 删除第n个缓冲区，并未真正删除，还在unlisted列表中。</li>\n<li>:ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li>\n</ul>\n<h1 id=\"10-分屏编辑\"><a href=\"#10-分屏编辑\" class=\"headerlink\" title=\"10. 分屏编辑\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id86\" target=\"_blank\" rel=\"noopener\">10. 分屏编辑</a></h1><ul>\n<li>vim -o file1 file2:水平分割窗口，同时打开file1和file2</li>\n<li>vim -O file1 file2:垂直分割窗口，同时打开file1和file2</li>\n</ul>\n<h2 id=\"10-1-水平分割\"><a href=\"#10-1-水平分割\" class=\"headerlink\" title=\"10.1 水平分割\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id87\" target=\"_blank\" rel=\"noopener\">10.1 水平分割</a></h2><ul>\n<li>:split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。</li>\n<li>:split filename – 水平分割窗口，并在新窗口中显示另一个文件。</li>\n<li>:nsplit(:nsp) – 水平分割出一个n行高的窗口。</li>\n<li>:[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N)</li>\n<li>ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li>\n<li>C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。</li>\n</ul>\n<h2 id=\"10-2-垂直分割\"><a href=\"#10-2-垂直分割\" class=\"headerlink\" title=\"10.2 垂直分割\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id88\" target=\"_blank\" rel=\"noopener\">10.2 垂直分割</a></h2><ul>\n<li>:vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V)</li>\n<li>:[N]vne[w] – 垂直分割出一个新窗口。</li>\n<li>:vertical 水平分割的命令： 相应的垂直分割。</li>\n</ul>\n<h2 id=\"10-3-关闭子窗口\"><a href=\"#10-3-关闭子窗口\" class=\"headerlink\" title=\"10.3 关闭子窗口\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id89\" target=\"_blank\" rel=\"noopener\">10.3 关闭子窗口</a></h2><ul>\n<li>:qall – 关闭所有窗口，退出vim。</li>\n<li>:wall – 保存所有修改过的窗口。</li>\n<li>:only – 只保留当前窗口，关闭其它窗口。(CTRL-W o)</li>\n<li>:close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )</li>\n</ul>\n<h2 id=\"10-4-调整窗口大小\"><a href=\"#10-4-调整窗口大小\" class=\"headerlink\" title=\"10.4 调整窗口大小\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id90\" target=\"_blank\" rel=\"noopener\">10.4 调整窗口大小</a></h2><ul>\n<li>ctrl+w + –当前窗口增高一行。也可以用n增高n行。</li>\n<li>ctrl+w - –当前窗口减小一行。也可以用n减小n行。</li>\n<li>ctrl+w _ –当前窗口扩展到尽可能的大。也可以用n设定行数。</li>\n<li>:resize n – 当前窗口n行高。</li>\n<li>ctrl+w = – 所有窗口同样高度。</li>\n<li>n ctrl+w _ – 当前窗口的高度设定为n行。</li>\n<li>ctrl+w &lt; –当前窗口减少一列。也可以用n减少n列。</li>\n<li>ctrl+w &gt; –当前窗口增宽一列。也可以用n增宽n列。</li>\n<li>ctrl+w | –当前窗口尽可能的宽。也可以用n设定列数。</li>\n</ul>\n<h2 id=\"10-5-切换和移动窗口\"><a href=\"#10-5-切换和移动窗口\" class=\"headerlink\" title=\"10.5 切换和移动窗口\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id91\" target=\"_blank\" rel=\"noopener\">10.5 切换和移动窗口</a></h2><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p>\n<ul>\n<li>ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。</li>\n<li>ctrl+w p: 切换到前一个窗口。</li>\n<li>ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。</li>\n<li>ctrl+w t(b):切换到最上（下）面的窗口。<BR></li>\n<li>ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。</li>\n<li>ctrl+w r：旋转窗口的位置。</li>\n<li>ctrl+w T: 将当前的窗口移动到新的标签页上。</li>\n</ul>\n<h1 id=\"11-快速编辑\"><a href=\"#11-快速编辑\" class=\"headerlink\" title=\"11. 快速编辑\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id92\" target=\"_blank\" rel=\"noopener\">11. 快速编辑</a></h1><h2 id=\"11-1-改变大小写\"><a href=\"#11-1-改变大小写\" class=\"headerlink\" title=\"11.1 改变大小写\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id93\" target=\"_blank\" rel=\"noopener\">11.1 改变大小写</a></h2><ul>\n<li>~: 反转光标所在字符的大小写。</li>\n<li>可视模式下的U或u：把选中的文本变为大写或小写。</li>\n<li>gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。</li>\n</ul>\n<h2 id=\"11-2-替换（normal模式）\"><a href=\"#11-2-替换（normal模式）\" class=\"headerlink\" title=\"11.2 替换（normal模式）\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id94\" target=\"_blank\" rel=\"noopener\">11.2 替换（normal模式）</a></h2><ul>\n<li>r: 替换光标处的字符，同样支持汉字。</li>\n<li>R: 进入替换模式，按esc回到正常模式。</li>\n</ul>\n<h2 id=\"11-3-撤消与重做（normal模式）\"><a href=\"#11-3-撤消与重做（normal模式）\" class=\"headerlink\" title=\"11.3 撤消与重做（normal模式）\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id95\" target=\"_blank\" rel=\"noopener\">11.3 撤消与重做（normal模式）</a></h2><ul>\n<li>[n] u: 取消一(n)个改动。</li>\n<li>:undo 5 – 撤销5个改变。</li>\n<li>:undolist – 你的撤销历史。</li>\n<li>ctrl + r: 重做最后的改动。</li>\n<li>U: 取消当前行中所有的改动。</li>\n<li>:earlier 4m – 回到4分钟前</li>\n<li>:later 55s – 前进55秒</li>\n</ul>\n<h2 id=\"11-4-宏\"><a href=\"#11-4-宏\" class=\"headerlink\" title=\"11.4 宏\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id96\" target=\"_blank\" rel=\"noopener\">11.4 宏</a></h2><ul>\n<li>. –重复上一个编辑动作</li>\n<li>qa：开始录制宏a（键盘操作记录）</li>\n<li>q：停止录制</li>\n<li>@a：播放宏a</li>\n</ul>\n<h1 id=\"12-编辑特殊文件\"><a href=\"#12-编辑特殊文件\" class=\"headerlink\" title=\"12. 编辑特殊文件\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id97\" target=\"_blank\" rel=\"noopener\">12. 编辑特殊文件</a></h1><h2 id=\"12-1-文件加解密\"><a href=\"#12-1-文件加解密\" class=\"headerlink\" title=\"12.1 文件加解密\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id98\" target=\"_blank\" rel=\"noopener\">12.1 文件加解密</a></h2><ul>\n<li>vim -x file: 开始编辑一个加密的文件。</li>\n<li>:X – 为当前文件设置密码。</li>\n<li>:set key= – 去除文件的密码。</li>\n</ul>\n<p><a href=\"http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html\" target=\"_blank\" rel=\"noopener\">这里是</a> 滇狐总结的比较高级的vi技巧。</p>\n<h2 id=\"12-2-文件的编码\"><a href=\"#12-2-文件的编码\" class=\"headerlink\" title=\"12.2 文件的编码\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id99\" target=\"_blank\" rel=\"noopener\">12.2 文件的编码</a></h2><ul>\n<li>:e ++enc=utf8 filename, 让vim用utf-8的编码打开这个文件。</li>\n<li>:w ++enc=gbk，不管当前文件什么编码，把它转存成gbk编码。</li>\n<li>:set fenc或:set fileencoding，查看当前文件的编码。</li>\n<li>在vimrc中添加set fileencoding=ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。</li>\n</ul>\n<p>让vim 正确处理文件格式和文件编码，有赖于 <a href=\"http://www.cnblogs.com/jiqingwu/admin/vimrc.html\" target=\"_blank\" rel=\"noopener\">~/.vimrc的正确配置</a></p>\n<h2 id=\"12-3-文件格式\"><a href=\"#12-3-文件格式\" class=\"headerlink\" title=\"12.3 文件格式\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id100\" target=\"_blank\" rel=\"noopener\">12.3 文件格式</a></h2><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p>\n<ul>\n<li>:e ++ff=dos filename, 让vim用dos格式打开这个文件。</li>\n<li>:w ++ff=mac filename, 以mac格式存储这个文件。</li>\n<li>:set ff，显示当前文件的格式。</li>\n<li>在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。</li>\n</ul>\n<h1 id=\"13-编程辅助\"><a href=\"#13-编程辅助\" class=\"headerlink\" title=\"13. 编程辅助\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id101\" target=\"_blank\" rel=\"noopener\">13. 编程辅助</a></h1><h2 id=\"13-1-一些按键\"><a href=\"#13-1-一些按键\" class=\"headerlink\" title=\"13.1 一些按键\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id102\" target=\"_blank\" rel=\"noopener\">13.1 一些按键</a></h2><ul>\n<li>gd: 跳转到局部变量的定义处；</li>\n<li>gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；</li>\n<li>g;: 上一个修改过的地方；</li>\n<li>g,: 下一个修改过的地方；</li>\n<li>[[: 跳转到上一个函数块开始，需要有单独一行的{。</li>\n<li>]]: 跳转到下一个函数块开始，需要有单独一行的{。</li>\n<li>[]: 跳转到上一个函数块结束，需要有单独一行的}。</li>\n<li>][: 跳转到下一个函数块结束，需要有单独一行的}。</li>\n<li>[{: 跳转到当前块开始处；</li>\n<li>]}: 跳转到当前块结束处；</li>\n<li>[/: 跳转到当前注释块开始处；</li>\n<li>]/: 跳转到当前注释块结束处；</li>\n<li>%: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。</li>\n</ul>\n<p>下面的括号匹配对编程很实用的。</p>\n<ul>\n<li>ci’, di’, yi’：修改、剪切或复制’之间的内容。</li>\n<li>ca’, da’, ya’：修改、剪切或复制’之间的内容，包含’。</li>\n<li>ci”, di”, yi”：修改、剪切或复制”之间的内容。</li>\n<li>ca”, da”, ya”：修改、剪切或复制”之间的内容，包含”。</li>\n<li>ci(, di(, yi(：修改、剪切或复制()之间的内容。</li>\n<li>ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。</li>\n<li>ci[, di[, yi[：修改、剪切或复制[]之间的内容。</li>\n<li>ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。</li>\n<li>ci{, di{, yi{：修改、剪切或复制{}之间的内容。</li>\n<li>ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。</li>\n<li>ci&lt;, di&lt;, yi&lt;：修改、剪切或复制&lt;&gt;之间的内容。</li>\n<li>ca&lt;, da&lt;, ya&lt;：修改、剪切或复制&lt;&gt;之间的内容，包含&lt;&gt;。</li>\n</ul>\n<h2 id=\"13-2-ctags\"><a href=\"#13-2-ctags\" class=\"headerlink\" title=\"13.2 ctags\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id103\" target=\"_blank\" rel=\"noopener\">13.2 ctags</a></h2><ul>\n<li>ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags</li>\n<li>:set tags=path/tags – 告诉ctags使用哪个tag文件</li>\n<li>:tag xyz – 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t</li>\n<li>:stag xyz – 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口</li>\n<li>:ptag xyz – 在预览窗口中打开xyz的定义，热键是C-w }。</li>\n<li>:pclose – 关闭预览窗口。热键是C-w z。</li>\n<li>:pedit abc.h – 在预览窗口中编辑abc.h</li>\n<li>:psearch abc – 搜索当前文件和当前文件include的文件，显示包含abc的行。</li>\n</ul>\n<p>有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p>\n<ul>\n<li>:[n]tnext – 下一[n]个匹配。</li>\n<li>:[n]tprev – 上一[n]个匹配。</li>\n<li>:tfirst – 第一个匹配</li>\n<li>:tlast – 最后一个匹配</li>\n<li>:tselect tagname – 打开选择列表</li>\n</ul>\n<p>tab键补齐</p>\n<ul>\n<li>:tag xyz<tab> – 补齐以xyz开头的tag名，继续按tab键，会显示其他的。</li>\n<li>:tag /xyz<tab> – 会用名字中含有xyz的tag名补全。</li>\n</ul>\n<h2 id=\"13-3-cscope\"><a href=\"#13-3-cscope\" class=\"headerlink\" title=\"13.3 cscope\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id104\" target=\"_blank\" rel=\"noopener\">13.3 cscope</a></h2><ul>\n<li>cscope -Rbq: 生成cscope.out文件</li>\n<li>:cs add /path/to/cscope.out /your/work/dir</li>\n<li>:cs find c func – 查找func在哪些地方被调用</li>\n<li>:cw – 打开quickfix窗口查看结果</li>\n</ul>\n<h2 id=\"13-4-gtags\"><a href=\"#13-4-gtags\" class=\"headerlink\" title=\"13.4 gtags\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id105\" target=\"_blank\" rel=\"noopener\">13.4 gtags</a></h2><p>Gtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。</p>\n<ul>\n<li>:Gtags funcname 定位到 funcname 的定义处。</li>\n<li>:Gtags -r funcname 查询 funcname被引用的地方。</li>\n<li>:Gtags -s symbol 定位 symbol 出现的地方。</li>\n<li>:Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。</li>\n<li>:Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。</li>\n<li>:Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P /vm/ 显示vm目录下的文件。</li>\n</ul>\n<h2 id=\"13-5-编译\"><a href=\"#13-5-编译\" class=\"headerlink\" title=\"13.5 编译\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id106\" target=\"_blank\" rel=\"noopener\">13.5 编译</a></h2><p>vim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。</p>\n<p>如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.java文件，你可以这样设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set makeprg&#x3D;javac\\ abc.java</span><br></pre></td></tr></table></figure>\n\n<p>然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:setl efm&#x3D;%A%f:%l:\\ %m,%-Z%p^,%-C%.%#</span><br></pre></td></tr></table></figure>\n\n<p>%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。</p>\n<h2 id=\"13-6-快速修改窗口\"><a href=\"#13-6-快速修改窗口\" class=\"headerlink\" title=\"13.6 快速修改窗口\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id107\" target=\"_blank\" rel=\"noopener\">13.6 快速修改窗口</a></h2><p>其实是quickfix插件提供的功能， 对编译调试程序非常有用 :)</p>\n<ul>\n<li>:copen – 打开快速修改窗口。</li>\n<li>:cclose – 关闭快速修改窗口。</li>\n</ul>\n<p>快速修改窗口在make程序时非常有用，当make之后：</p>\n<ul>\n<li>:cl – 在快速修改窗口中列出错误。</li>\n<li>:cn – 定位到下一个错误。</li>\n<li>:cp – 定位到上一个错误。</li>\n<li>:cr – 定位到第一个错误。</li>\n</ul>\n<h2 id=\"13-7-自动补全\"><a href=\"#13-7-自动补全\" class=\"headerlink\" title=\"13.7 自动补全\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id108\" target=\"_blank\" rel=\"noopener\">13.7 自动补全</a></h2><ul>\n<li>C-x C-s – 拼写建议。</li>\n<li>C-x C-v – 补全vim选项和命令。</li>\n<li>C-x C-l – 整行补全。</li>\n<li>C-x C-f – 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。</li>\n<li>C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。</li>\n<li>C-x C-o – 编程时可以补全关键字和函数名啊。</li>\n<li>C-x C-i – 根据头文件内关键字补全。</li>\n<li>C-x C-d – 补全宏定义。</li>\n<li>C-x C-n – 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。</li>\n</ul>\n<p>当弹出补全菜单后：</p>\n<ul>\n<li>C-p 向前切换成员；</li>\n<li>C-n 向后切换成员；</li>\n<li>C-e 退出下拉菜单，并退回到原来录入的文字；</li>\n<li>C-y 退出下拉菜单，并接受当前选项。</li>\n</ul>\n<h2 id=\"13-8-多行缩进缩出\"><a href=\"#13-8-多行缩进缩出\" class=\"headerlink\" title=\"13.8 多行缩进缩出\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id109\" target=\"_blank\" rel=\"noopener\">13.8 多行缩进缩出</a></h2><ul>\n<li>正常模式下，按两下&gt;;光标所在行会缩进。</li>\n<li>如果先按了n，再按两下&gt;;，光标以下的n行会缩进。</li>\n<li>对应的，按两下&lt;;，光标所在行会缩出。</li>\n<li>如果在编辑代码文件，可以用=进行调整。</li>\n<li>在可视模式下，选择要调整的代码块，按=，代码会按书写规则缩排好。</li>\n<li>或者n =，调整n行代码的缩排。</li>\n</ul>\n<h2 id=\"13-9-折叠\"><a href=\"#13-9-折叠\" class=\"headerlink\" title=\"13.9 折叠\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id110\" target=\"_blank\" rel=\"noopener\">13.9 折叠</a></h2><ul>\n<li>zf – 创建折叠的命令，可以在一个可视区域上使用该命令；</li>\n<li>zd – 删除当前行的折叠；</li>\n<li>zD – 删除当前行的折叠；</li>\n<li>zfap – 折叠光标所在的段；</li>\n<li>zo – 打开折叠的文本；</li>\n<li>zc – 收起折叠；</li>\n<li>za – 打开/关闭当前折叠；</li>\n<li>zr – 打开嵌套的折行；</li>\n<li>zm – 收起嵌套的折行；</li>\n<li>zR (zO) – 打开所有折行；</li>\n<li>zM (zC) – 收起所有折行；</li>\n<li>zj – 跳到下一个折叠处；</li>\n<li>zk – 跳到上一个折叠处；</li>\n<li>zi – enable/disable fold;</li>\n</ul>\n<h1 id=\"14-命令行\"><a href=\"#14-命令行\" class=\"headerlink\" title=\"14. 命令行\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id111\" target=\"_blank\" rel=\"noopener\">14. 命令行</a></h1><p>normal模式下按:进入命令行模式</p>\n<h2 id=\"14-1-命令行模式下的快捷键：\"><a href=\"#14-1-命令行模式下的快捷键：\" class=\"headerlink\" title=\"14.1 命令行模式下的快捷键：\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id112\" target=\"_blank\" rel=\"noopener\">14.1 命令行模式下的快捷键：</a></h2><ul>\n<li>上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。</li>\n<li>左右方向键：左/右移一个字符。</li>\n<li>C-w： 向前删除一个单词。</li>\n<li>C-h： 向前删除一个字符，等同于Backspace。</li>\n<li>C-u： 从当前位置移动到命令行开头。</li>\n<li>C-b： 移动到命令行开头。</li>\n<li>C-e： 移动到命令行末尾。</li>\n<li>Shift-Left： 左移一个单词。</li>\n<li>Shift-Right： 右移一个单词。</li>\n<li>@： 重复上一次的冒号命令。</li>\n<li>q： 正常模式下，q然后按’:’，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。</li>\n<li>q/和q? 可以打开查找历史记录。</li>\n</ul>\n<h2 id=\"14-2-执行外部命令\"><a href=\"#14-2-执行外部命令\" class=\"headerlink\" title=\"14.2 执行外部命令\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id113\" target=\"_blank\" rel=\"noopener\">14.2 执行外部命令</a></h2><ul>\n<li>:! cmd 执行外部命令。</li>\n<li>:!! 执行上一次的外部命令。</li>\n<li>:sh 调用shell，用exit返回vim。</li>\n<li>:r !cmd 将命令的返回结果插入文件当前位置。</li>\n<li>:m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。</li>\n</ul>\n<h1 id=\"15-其它\"><a href=\"#15-其它\" class=\"headerlink\" title=\"15. 其它\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id114\" target=\"_blank\" rel=\"noopener\">15. 其它</a></h1><h2 id=\"15-1-工作目录\"><a href=\"#15-1-工作目录\" class=\"headerlink\" title=\"15.1 工作目录\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id115\" target=\"_blank\" rel=\"noopener\">15.1 工作目录</a></h2><ul>\n<li>:pwd 显示vim的工作目录。</li>\n<li>:cd path 改变vim的工作目录。</li>\n<li>:set autochdir 可以让vim 根据编辑的文件自动切换工作目录。</li>\n</ul>\n<h2 id=\"15-2-一些快捷键（收集中）\"><a href=\"#15-2-一些快捷键（收集中）\" class=\"headerlink\" title=\"15.2 一些快捷键（收集中）\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id116\" target=\"_blank\" rel=\"noopener\">15.2 一些快捷键（收集中）</a></h2><ul>\n<li>K: 打开光标所在词的manpage。</li>\n<li>*: 向下搜索光标所在词。</li>\n<li>g*: 同上，但部分符合即可。</li>\n<li>#: 向上搜索光标所在词。</li>\n<li>g#: 同上，但部分符合即可。</li>\n<li>g C-g: 统计全文或统计部分的字数。</li>\n</ul>\n<h2 id=\"15-3-在线帮助\"><a href=\"#15-3-在线帮助\" class=\"headerlink\" title=\"15.3 在线帮助\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id117\" target=\"_blank\" rel=\"noopener\">15.3 在线帮助</a></h2><ul>\n<li>:h(elp)或F1 打开总的帮助。</li>\n<li>:help user-manual 打开用户手册。</li>\n<li>命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li>\n<li>:helptags somepath 为somepath中的文档生成索引。</li>\n<li>:helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。</li>\n<li>Ctrl+] 跳转到tag主题，Ctrl+t 跳回。</li>\n<li>:ver 显示版本信息。</li>\n</ul>\n<h2 id=\"15-4-一些小功能\"><a href=\"#15-4-一些小功能\" class=\"headerlink\" title=\"15.4 一些小功能\"></a><a href=\"http://www.cnblogs.com/jiqingwu/archive/2012/06/14/vim_notes.html#id118\" target=\"_blank\" rel=\"noopener\">15.4 一些小功能</a></h2><ul>\n<li>简单计算器: 在插入模式下，输入C-r =，然后输入表达式，就能在 光标处得到计算结果。</li>\n</ul>"},{"title":"【栈和队列】合法括号","date":"2020-02-04T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n注意空字符串可被认为是有效字符串。\n\n```\n示例 1:\n\n输入: \"()\"\n输出: true\n示例 2:\n\n输入: \"()[]{}\"\n输出: true\n示例 3:\n\n输入: \"(]\"\n输出: false\n示例 4:\n\n输入: \"([)]\"\n输出: false\n示例 5:\n\n输入: \"{[]}\"\n输出: true\n```\n\n\n\n## 代码\n\n``` go\nfunc isValid(s string) bool {\n  size := len(s)\n  stack := make([]byte, size)\n  top   := 0\n  for i := 0; i < size; i++ {\n    c := s[i]\n    switch c {\n      case ')', ']', '}':\n      if top > 0 && stack[top - 1] == c {\n        top --\n      } else {\n        return false\n      }\n      case '(': \n      stack[top] = c + 1 // ( + 1 =)\n      top ++ \n      case '[', '{':\n      stack[top] = c + 2 // [ + 2 =]\n      top ++ \n      default: \n      return false\n    }\n  }\n  return top == 0\n}\n```\n\n\n\n## 解题思路\n\n检测到左括号，就将对应的括号压入\n\n检测到右括号，就将对应的括号去掉，如果没有，则返回false","source":"_posts/刷题心得/栈和队列/合法括号.md","raw":"---\ntitle: 【栈和队列】合法括号\ndate: 2020-02-05\ntags:\n- 算法\n- 栈\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n注意空字符串可被认为是有效字符串。\n\n```\n示例 1:\n\n输入: \"()\"\n输出: true\n示例 2:\n\n输入: \"()[]{}\"\n输出: true\n示例 3:\n\n输入: \"(]\"\n输出: false\n示例 4:\n\n输入: \"([)]\"\n输出: false\n示例 5:\n\n输入: \"{[]}\"\n输出: true\n```\n\n\n\n## 代码\n\n``` go\nfunc isValid(s string) bool {\n  size := len(s)\n  stack := make([]byte, size)\n  top   := 0\n  for i := 0; i < size; i++ {\n    c := s[i]\n    switch c {\n      case ')', ']', '}':\n      if top > 0 && stack[top - 1] == c {\n        top --\n      } else {\n        return false\n      }\n      case '(': \n      stack[top] = c + 1 // ( + 1 =)\n      top ++ \n      case '[', '{':\n      stack[top] = c + 2 // [ + 2 =]\n      top ++ \n      default: \n      return false\n    }\n  }\n  return top == 0\n}\n```\n\n\n\n## 解题思路\n\n检测到左括号，就将对应的括号压入\n\n检测到右括号，就将对应的括号去掉，如果没有，则返回false","slug":"刷题心得/栈和队列/合法括号","published":1,"updated":"2020-02-05T02:12:20.225Z","_id":"ck68nkriu0000ou8ngc0b3gu4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;()&quot;</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">示例 3:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;(]&quot;</span><br><span class=\"line\">输出: false</span><br><span class=\"line\">示例 4:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;([)]&quot;</span><br><span class=\"line\">输出: false</span><br><span class=\"line\">示例 5:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;&#123;[]&#125;&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  size := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">  stack := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size)</span><br><span class=\"line\">  top   := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; size; i++ &#123;</span><br><span class=\"line\">    c := s[i]</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> c &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">')'</span>, <span class=\"string\">']'</span>, <span class=\"string\">'&#125;'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> top &gt; <span class=\"number\">0</span> &amp;&amp; stack[top - <span class=\"number\">1</span>] == c &#123;</span><br><span class=\"line\">        top --</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'('</span>: </span><br><span class=\"line\">      stack[top] = c + <span class=\"number\">1</span> <span class=\"comment\">// ( + 1 =)</span></span><br><span class=\"line\">      top ++ </span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'['</span>, <span class=\"string\">'&#123;'</span>:</span><br><span class=\"line\">      stack[top] = c + <span class=\"number\">2</span> <span class=\"comment\">// [ + 2 =]</span></span><br><span class=\"line\">      top ++ </span><br><span class=\"line\">      <span class=\"keyword\">default</span>: </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> top == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>检测到左括号，就将对应的括号压入</p>\n<p>检测到右括号，就将对应的括号去掉，如果没有，则返回false</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;()&quot;</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">示例 3:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;(]&quot;</span><br><span class=\"line\">输出: false</span><br><span class=\"line\">示例 4:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;([)]&quot;</span><br><span class=\"line\">输出: false</span><br><span class=\"line\">示例 5:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: &quot;&#123;[]&#125;&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  size := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">  stack := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, size)</span><br><span class=\"line\">  top   := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; size; i++ &#123;</span><br><span class=\"line\">    c := s[i]</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> c &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">')'</span>, <span class=\"string\">']'</span>, <span class=\"string\">'&#125;'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> top &gt; <span class=\"number\">0</span> &amp;&amp; stack[top - <span class=\"number\">1</span>] == c &#123;</span><br><span class=\"line\">        top --</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'('</span>: </span><br><span class=\"line\">      stack[top] = c + <span class=\"number\">1</span> <span class=\"comment\">// ( + 1 =)</span></span><br><span class=\"line\">      top ++ </span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'['</span>, <span class=\"string\">'&#123;'</span>:</span><br><span class=\"line\">      stack[top] = c + <span class=\"number\">2</span> <span class=\"comment\">// [ + 2 =]</span></span><br><span class=\"line\">      top ++ </span><br><span class=\"line\">      <span class=\"keyword\">default</span>: </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> top == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>检测到左括号，就将对应的括号压入</p>\n<p>检测到右括号，就将对应的括号去掉，如果没有，则返回false</p>\n"},{"title":"【链表和数组】环形链表","date":"2020-02-03T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个链表，判断链表中是否有环。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n \n\n### 示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n### 示例 2：\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n### 示例 3：\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n进阶：\n\n你能用 O(1)（即，常量）内存解决此问题吗？\n\n[\n\\141. 环形链表 - 力扣（LeetCode）](https://leetcode-cn.com/problems/linked-list-cycle/)\n\n<!-- more -->\n\n## 代码\n\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc hasCycle(head *ListNode) bool {\n  if head == nil {\n    return false\n  }\n  slow, fast := head, head.Next\n  for fast != nil && fast.Next != nil && slow != fast {\n    slow, fast = slow.Next, fast.Next.Next\n  }\n  return slow == fast\n}\n```\n\n## 解题思路\n\n如果快慢指针能相遇，则存在环","source":"_posts/刷题心得/链表和数组/环形链表.md","raw":"---\ntitle: 【链表和数组】环形链表\ndate: 2020-02-04 \ntags:\n- 算法\n- 链表\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\n给定一个链表，判断链表中是否有环。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n \n\n### 示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n### 示例 2：\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n### 示例 3：\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n进阶：\n\n你能用 O(1)（即，常量）内存解决此问题吗？\n\n[\n\\141. 环形链表 - 力扣（LeetCode）](https://leetcode-cn.com/problems/linked-list-cycle/)\n\n<!-- more -->\n\n## 代码\n\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc hasCycle(head *ListNode) bool {\n  if head == nil {\n    return false\n  }\n  slow, fast := head, head.Next\n  for fast != nil && fast.Next != nil && slow != fast {\n    slow, fast = slow.Next, fast.Next.Next\n  }\n  return slow == fast\n}\n```\n\n## 解题思路\n\n如果快慢指针能相遇，则存在环","slug":"刷题心得/链表和数组/环形链表","published":1,"updated":"2020-02-04T03:30:42.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck68nkrj80007ou8n07j5enpf","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个链表，判断链表中是否有环。</p>\n<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>\n<h3 id=\"示例-1：\"><a href=\"#示例-1：\" class=\"headerlink\" title=\"示例 1：\"></a>示例 1：</h3><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>\n<h3 id=\"示例-2：\"><a href=\"#示例-2：\" class=\"headerlink\" title=\"示例 2：\"></a>示例 2：</h3><p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>\n<h3 id=\"示例-3：\"><a href=\"#示例-3：\" class=\"headerlink\" title=\"示例 3：\"></a>示例 3：</h3><p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>\n<p>进阶：</p>\n<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\"><br>\\141. 环形链表 - 力扣（LeetCode）</a></p>\n<a id=\"more\"></a>\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasCycle</span><span class=\"params\">(head *ListNode)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  slow, fast := head, head.Next</span><br><span class=\"line\">  <span class=\"keyword\">for</span> fast != <span class=\"literal\">nil</span> &amp;&amp; fast.Next != <span class=\"literal\">nil</span> &amp;&amp; slow != fast &#123;</span><br><span class=\"line\">    slow, fast = slow.Next, fast.Next.Next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> slow == fast</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>如果快慢指针能相遇，则存在环</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个链表，判断链表中是否有环。</p>\n<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>\n<h3 id=\"示例-1：\"><a href=\"#示例-1：\" class=\"headerlink\" title=\"示例 1：\"></a>示例 1：</h3><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>\n<h3 id=\"示例-2：\"><a href=\"#示例-2：\" class=\"headerlink\" title=\"示例 2：\"></a>示例 2：</h3><p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>\n<h3 id=\"示例-3：\"><a href=\"#示例-3：\" class=\"headerlink\" title=\"示例 3：\"></a>示例 3：</h3><p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>\n<p>进阶：</p>\n<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\"><br>\\141. 环形链表 - 力扣（LeetCode）</a></p>","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasCycle</span><span class=\"params\">(head *ListNode)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  slow, fast := head, head.Next</span><br><span class=\"line\">  <span class=\"keyword\">for</span> fast != <span class=\"literal\">nil</span> &amp;&amp; fast.Next != <span class=\"literal\">nil</span> &amp;&amp; slow != fast &#123;</span><br><span class=\"line\">    slow, fast = slow.Next, fast.Next.Next</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> slow == fast</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>如果快慢指针能相遇，则存在环</p>"},{"title":"【链表和数组】K个一组反转链表","date":"2020-02-03T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\n\nk 是一个正整数，它的值小于或等于链表的长度。\n\n如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n示例 :\n\n给定这个链表：1->2->3->4->5\n\n当 k = 2 时，应当返回: 2->1->4->3->5\n\n当 k = 3 时，应当返回: 3->2->1->4->5\n\n说明 :\n\n你的算法只能使用常数的额外空间。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\nhttps://leetcode-cn.com/problems/reverse-nodes-in-k-group/\n\n## 代码\n\n``` go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    \n}\n```\n\n","source":"_posts/刷题心得/链表和数组/K个一组反转链表.md","raw":"---\ntitle: 【链表和数组】K个一组反转链表\ndate: 2020-02-04 \ntags:\n- 算法\n- 链表\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\n给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\n\nk 是一个正整数，它的值小于或等于链表的长度。\n\n如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n\n示例 :\n\n给定这个链表：1->2->3->4->5\n\n当 k = 2 时，应当返回: 2->1->4->3->5\n\n当 k = 3 时，应当返回: 3->2->1->4->5\n\n说明 :\n\n你的算法只能使用常数的额外空间。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\nhttps://leetcode-cn.com/problems/reverse-nodes-in-k-group/\n\n## 代码\n\n``` go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    \n}\n```\n\n","slug":"刷题心得/链表和数组/K个一组反转链表","published":1,"updated":"2020-02-04T04:21:52.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck68nkrj80008ou8n65gq9e8s","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>\n<p>k 是一个正整数，它的值小于或等于链表的长度。</p>\n<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n<p>示例 :</p>\n<p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>\n<p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>\n<p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>\n<p>说明 :</p>\n<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n<p><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(head *ListNode, k <span class=\"keyword\">int</span>)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>\n<p>k 是一个正整数，它的值小于或等于链表的长度。</p>\n<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n<p>示例 :</p>\n<p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>\n<p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>\n<p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>\n<p>说明 :</p>\n<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n<p><a href=\"https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseKGroup</span><span class=\"params\">(head *ListNode, k <span class=\"keyword\">int</span>)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【链表和数组】反转链表","date":"2020-02-03T16:00:00.000Z","_content":"\n\n\n## 反转一个单链表。\n\n示例:\n\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n进阶:\n你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n[\n\\206. 反转链表 - 力扣（LeetCode）](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n<!-- more -->\n\n## 解题思路\n\n新建一个空节点 作为反转后的串的顶部节点\n\n遍历每个节点 并执行以下操作\n\n- 临时变量存储next的值\n- head的next指向prev\n- prev 指向当前的head\n- head指向下一个节点\n\n## 代码\n\n``` Go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseList(head *ListNode) *ListNode {\n  var prev *ListNode\n  for head != nil {\n    temp := head.Next\n    head.Next = prev\n    prev = head\n    head = temp\n  }\n  return prev\n}\n```\n\n","source":"_posts/刷题心得/链表和数组/反转链表.md","raw":"---\ntitle: 【链表和数组】反转链表\ndate: 2020-02-04 \ntags:\n- 算法\n- 链表\ncategories:\n- 刷题心得\n---\n\n\n\n## 反转一个单链表。\n\n示例:\n\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n进阶:\n你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n[\n\\206. 反转链表 - 力扣（LeetCode）](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n<!-- more -->\n\n## 解题思路\n\n新建一个空节点 作为反转后的串的顶部节点\n\n遍历每个节点 并执行以下操作\n\n- 临时变量存储next的值\n- head的next指向prev\n- prev 指向当前的head\n- head指向下一个节点\n\n## 代码\n\n``` Go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseList(head *ListNode) *ListNode {\n  var prev *ListNode\n  for head != nil {\n    temp := head.Next\n    head.Next = prev\n    prev = head\n    head = temp\n  }\n  return prev\n}\n```\n\n","slug":"刷题心得/链表和数组/反转链表","published":1,"updated":"2020-02-04T03:08:21.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck68nkrj9000aou8n6193021y","content":"<h2 id=\"反转一个单链表。\"><a href=\"#反转一个单链表。\" class=\"headerlink\" title=\"反转一个单链表。\"></a>反转一个单链表。</h2><p>示例:</p>\n<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>\n<p><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener\"><br>\\206. 反转链表 - 力扣（LeetCode）</a></p>\n<a id=\"more\"></a>\n\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>新建一个空节点 作为反转后的串的顶部节点</p>\n<p>遍历每个节点 并执行以下操作</p>\n<ul>\n<li>临时变量存储next的值</li>\n<li>head的next指向prev</li>\n<li>prev 指向当前的head</li>\n<li>head指向下一个节点</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseList</span><span class=\"params\">(head *ListNode)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prev *ListNode</span><br><span class=\"line\">  <span class=\"keyword\">for</span> head != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    temp := head.Next</span><br><span class=\"line\">    head.Next = prev</span><br><span class=\"line\">    prev = head</span><br><span class=\"line\">    head = temp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"反转一个单链表。\"><a href=\"#反转一个单链表。\" class=\"headerlink\" title=\"反转一个单链表。\"></a>反转一个单链表。</h2><p>示例:</p>\n<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>\n<p><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener\"><br>\\206. 反转链表 - 力扣（LeetCode）</a></p>","more":"<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>新建一个空节点 作为反转后的串的顶部节点</p>\n<p>遍历每个节点 并执行以下操作</p>\n<ul>\n<li>临时变量存储next的值</li>\n<li>head的next指向prev</li>\n<li>prev 指向当前的head</li>\n<li>head指向下一个节点</li>\n</ul>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseList</span><span class=\"params\">(head *ListNode)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prev *ListNode</span><br><span class=\"line\">  <span class=\"keyword\">for</span> head != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    temp := head.Next</span><br><span class=\"line\">    head.Next = prev</span><br><span class=\"line\">    prev = head</span><br><span class=\"line\">    head = temp</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"【链表和数组】两两交换链表中的节点","date":"2020-02-03T16:00:00.000Z","_content":"\n\n\n## 两两交换链表中的节点\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n \n\n示例:\n\n```\n给定 1->2->3->4, 你应该返回 2->1->4->3.\n```\n\n[\n\\24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n<!-- more -->\n\n## 代码\n\n``` go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n  if head == nil || head.Next == nil {\n    return head\n  }\n  newHead := head.Next\n  head.Next = swapPairs(newHead.Next)\n  newHead.Next = head\n  return newHead\n}\nfunc swapPairs(head *ListNode) *ListNode {\n  if head == nil || head.Next == nil {\n    return head\n  }\n  var prev,prev.Next *ListNode\n  for head != nil && head.Next != nil {\n    prev.Next := head.Next\n    head.Next = prev.Next\n    prev.Next.Next = head\n  }\n  if head != nil {\n    prev.Next = head\n  }\n}\n```\n\n\n\n## 思路\n\n本题采用递归的解法\n\n首先对特殊情况进行处理\n\n其次交换当前两个节点的位置，并对之后的节点进行处理\n\n返回结果","source":"_posts/刷题心得/链表和数组/两两交换链表中的节点.md","raw":"---\ntitle: 【链表和数组】两两交换链表中的节点\ndate: 2020-02-04 \ntags:\n- 算法\n- 链表\ncategories:\n- 刷题心得\n---\n\n\n\n## 两两交换链表中的节点\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n \n\n示例:\n\n```\n给定 1->2->3->4, 你应该返回 2->1->4->3.\n```\n\n[\n\\24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n<!-- more -->\n\n## 代码\n\n``` go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc swapPairs(head *ListNode) *ListNode {\n  if head == nil || head.Next == nil {\n    return head\n  }\n  newHead := head.Next\n  head.Next = swapPairs(newHead.Next)\n  newHead.Next = head\n  return newHead\n}\nfunc swapPairs(head *ListNode) *ListNode {\n  if head == nil || head.Next == nil {\n    return head\n  }\n  var prev,prev.Next *ListNode\n  for head != nil && head.Next != nil {\n    prev.Next := head.Next\n    head.Next = prev.Next\n    prev.Next.Next = head\n  }\n  if head != nil {\n    prev.Next = head\n  }\n}\n```\n\n\n\n## 思路\n\n本题采用递归的解法\n\n首先对特殊情况进行处理\n\n其次交换当前两个节点的位置，并对之后的节点进行处理\n\n返回结果","slug":"刷题心得/链表和数组/两两交换链表中的节点","published":1,"updated":"2020-02-04T03:09:01.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck68nkrja000bou8ncn08f32i","content":"<h2 id=\"两两交换链表中的节点\"><a href=\"#两两交换链表中的节点\" class=\"headerlink\" title=\"两两交换链表中的节点\"></a>两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>\n<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"noopener\"><br>\\24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p>\n<a id=\"more\"></a>\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapPairs</span><span class=\"params\">(head *ListNode)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  newHead := head.Next</span><br><span class=\"line\">  head.Next = swapPairs(newHead.Next)</span><br><span class=\"line\">  newHead.Next = head</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newHead</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapPairs</span><span class=\"params\">(head *ListNode)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prev,prev.Next *ListNode</span><br><span class=\"line\">  <span class=\"keyword\">for</span> head != <span class=\"literal\">nil</span> &amp;&amp; head.Next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    prev.Next := head.Next</span><br><span class=\"line\">    head.Next = prev.Next</span><br><span class=\"line\">    prev.Next.Next = head</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> head != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    prev.Next = head</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>本题采用递归的解法</p>\n<p>首先对特殊情况进行处理</p>\n<p>其次交换当前两个节点的位置，并对之后的节点进行处理</p>\n<p>返回结果</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"两两交换链表中的节点\"><a href=\"#两两交换链表中的节点\" class=\"headerlink\" title=\"两两交换链表中的节点\"></a>两两交换链表中的节点</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>\n<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"noopener\"><br>\\24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p>","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapPairs</span><span class=\"params\">(head *ListNode)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  newHead := head.Next</span><br><span class=\"line\">  head.Next = swapPairs(newHead.Next)</span><br><span class=\"line\">  newHead.Next = head</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newHead</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapPairs</span><span class=\"params\">(head *ListNode)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> head</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prev,prev.Next *ListNode</span><br><span class=\"line\">  <span class=\"keyword\">for</span> head != <span class=\"literal\">nil</span> &amp;&amp; head.Next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    prev.Next := head.Next</span><br><span class=\"line\">    head.Next = prev.Next</span><br><span class=\"line\">    prev.Next.Next = head</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> head != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    prev.Next = head</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>本题采用递归的解法</p>\n<p>首先对特殊情况进行处理</p>\n<p>其次交换当前两个节点的位置，并对之后的节点进行处理</p>\n<p>返回结果</p>"},{"title":"【链表和数组】环形链表2","date":"2020-02-03T16:00:00.000Z","_content":"\n\n\n## 题目\n\n\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n说明：不允许修改给定的链表。\n\n \n\n示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：tail connects to node index 1\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n输入：head = [1,2], pos = 0\n输出：tail connects to node index 0\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n输入：head = [1], pos = -1\n输出：no cycle\n解释：链表中没有环。\n\n\n\n进阶：\n你是否可以不用额外空间解决此题？\n\n<!-- more -->\n\n## 代码\n\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n  if head == nil || head.Next == nil {\n\t\treturn nil\n\t}\n\n\tslow, fast := head.Next, head.Next.Next\n\tfor fast != nil && fast.Next != nil && slow != fast {\n\t\tslow, fast = slow.Next, fast.Next.Next\n\t}\n\n\tif slow != fast {\n\t\treturn nil\n\t}\n\n\tfor slow != head {\n\t\tslow, head = slow.Next, head.Next\n\t}\n\treturn slow\n}\n```\n\n## 解题思路\n\n如果快慢指针能相遇，则存在环","source":"_posts/刷题心得/链表和数组/环形链表2.md","raw":"---\ntitle: 【链表和数组】环形链表2\ndate: 2020-02-04 \ntags:\n- 算法\n- 链表\ncategories:\n- 刷题心得\n\n---\n\n\n\n## 题目\n\n\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n\n说明：不允许修改给定的链表。\n\n \n\n示例 1：\n\n输入：head = [3,2,0,-4], pos = 1\n输出：tail connects to node index 1\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n输入：head = [1,2], pos = 0\n输出：tail connects to node index 0\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n输入：head = [1], pos = -1\n输出：no cycle\n解释：链表中没有环。\n\n\n\n进阶：\n你是否可以不用额外空间解决此题？\n\n<!-- more -->\n\n## 代码\n\n```go\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc detectCycle(head *ListNode) *ListNode {\n  if head == nil || head.Next == nil {\n\t\treturn nil\n\t}\n\n\tslow, fast := head.Next, head.Next.Next\n\tfor fast != nil && fast.Next != nil && slow != fast {\n\t\tslow, fast = slow.Next, fast.Next.Next\n\t}\n\n\tif slow != fast {\n\t\treturn nil\n\t}\n\n\tfor slow != head {\n\t\tslow, head = slow.Next, head.Next\n\t}\n\treturn slow\n}\n```\n\n## 解题思路\n\n如果快慢指针能相遇，则存在环","slug":"刷题心得/链表和数组/环形链表2","published":1,"updated":"2020-02-04T04:06:40.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck68nkrjb000dou8nbm9ma4ko","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>\n<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>\n<p>说明：不允许修改给定的链表。</p>\n<p>示例 1：</p>\n<p>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>\n<p>示例 2：</p>\n<p>输入：head = [1,2], pos = 0<br>输出：tail connects to node index 0<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>\n<p>示例 3：</p>\n<p>输入：head = [1], pos = -1<br>输出：no cycle<br>解释：链表中没有环。</p>\n<p>进阶：<br>你是否可以不用额外空间解决此题？</p>\n<a id=\"more\"></a>\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">detectCycle</span><span class=\"params\">(head *ListNode)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tslow, fast := head.Next, head.Next.Next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> fast != <span class=\"literal\">nil</span> &amp;&amp; fast.Next != <span class=\"literal\">nil</span> &amp;&amp; slow != fast &#123;</span><br><span class=\"line\">\t\tslow, fast = slow.Next, fast.Next.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> slow != fast &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> slow != head &#123;</span><br><span class=\"line\">\t\tslow, head = slow.Next, head.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> slow</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>如果快慢指针能相遇，则存在环</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>\n<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>\n<p>说明：不允许修改给定的链表。</p>\n<p>示例 1：</p>\n<p>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>\n<p>示例 2：</p>\n<p>输入：head = [1,2], pos = 0<br>输出：tail connects to node index 0<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>\n<p>示例 3：</p>\n<p>输入：head = [1], pos = -1<br>输出：no cycle<br>解释：链表中没有环。</p>\n<p>进阶：<br>你是否可以不用额外空间解决此题？</p>","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * type ListNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Next *ListNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">detectCycle</span><span class=\"params\">(head *ListNode)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tslow, fast := head.Next, head.Next.Next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> fast != <span class=\"literal\">nil</span> &amp;&amp; fast.Next != <span class=\"literal\">nil</span> &amp;&amp; slow != fast &#123;</span><br><span class=\"line\">\t\tslow, fast = slow.Next, fast.Next.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> slow != fast &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> slow != head &#123;</span><br><span class=\"line\">\t\tslow, head = slow.Next, head.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> slow</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>如果快慢指针能相遇，则存在环</p>"},{"title":"【位运算】位一的个数","date":"2020-02-10T16:00:00.000Z","_content":"\n\n\n## 题目\n\n编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。\n\n```\n示例 1：\n\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n示例 2：\n\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n示例 3：\n\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n```\n\n \n\n\n提示：\n\n请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n\n\n\n\n\n\n### 代码\n\n``` go\nfunc hammingWeight(num uint32) int {\n  var count int\n  for num != 0 {\n    count ++\n    num = num & (num -1)\n  }\n  return count\n}\n\nfunc hammingWeight(num uint32) int {\n \n}\n```\n\n\n\n\n\n\n\n\n\n### 解题思路\n\n####  x = x >> 1 x = x % 2\n\n#### x & (x-1) 去掉最后一个1","source":"_posts/刷题心得/位运算/位一的个数.md","raw":"---\ntitle: 【位运算】位一的个数\ndate: 2020-02-11\ntags:\n- 算法\n- 位运算\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\n编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。\n\n```\n示例 1：\n\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n示例 2：\n\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n示例 3：\n\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n```\n\n \n\n\n提示：\n\n请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n\n\n\n\n\n\n### 代码\n\n``` go\nfunc hammingWeight(num uint32) int {\n  var count int\n  for num != 0 {\n    count ++\n    num = num & (num -1)\n  }\n  return count\n}\n\nfunc hammingWeight(num uint32) int {\n \n}\n```\n\n\n\n\n\n\n\n\n\n### 解题思路\n\n####  x = x >> 1 x = x % 2\n\n#### x & (x-1) 去掉最后一个1","slug":"刷题心得/位运算/位一的个数","published":1,"updated":"2020-02-12T03:15:11.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2ttf0004mn8n0lsw1z9l","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：00000000000000000000000000001011</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：00000000000000000000000010000000</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：11111111111111111111111111111101</span><br><span class=\"line\">输出：31</span><br><span class=\"line\">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>提示：</p>\n<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(num <span class=\"keyword\">uint32</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> count <span class=\"keyword\">int</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> num != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    count ++</span><br><span class=\"line\">    num = num &amp; (num <span class=\"number\">-1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> count</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(num <span class=\"keyword\">uint32</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h4 id=\"x-x-gt-gt-1-x-x-2\"><a href=\"#x-x-gt-gt-1-x-x-2\" class=\"headerlink\" title=\"x = x &gt;&gt; 1 x = x % 2\"></a>x = x &gt;&gt; 1 x = x % 2</h4><h4 id=\"x-amp-x-1-去掉最后一个1\"><a href=\"#x-amp-x-1-去掉最后一个1\" class=\"headerlink\" title=\"x &amp; (x-1) 去掉最后一个1\"></a>x &amp; (x-1) 去掉最后一个1</h4>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：00000000000000000000000000001011</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：00000000000000000000000010000000</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：11111111111111111111111111111101</span><br><span class=\"line\">输出：31</span><br><span class=\"line\">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>提示：</p>\n<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(num <span class=\"keyword\">uint32</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> count <span class=\"keyword\">int</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> num != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    count ++</span><br><span class=\"line\">    num = num &amp; (num <span class=\"number\">-1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> count</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(num <span class=\"keyword\">uint32</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h4 id=\"x-x-gt-gt-1-x-x-2\"><a href=\"#x-x-gt-gt-1-x-x-2\" class=\"headerlink\" title=\"x = x &gt;&gt; 1 x = x % 2\"></a>x = x &gt;&gt; 1 x = x % 2</h4><h4 id=\"x-amp-x-1-去掉最后一个1\"><a href=\"#x-amp-x-1-去掉最后一个1\" class=\"headerlink\" title=\"x &amp; (x-1) 去掉最后一个1\"></a>x &amp; (x-1) 去掉最后一个1</h4>"},{"title":"【位运算】比特位计数","date":"2020-02-10T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。\n\n```\n示例 1:\n\n输入: 2\n输出: [0,1,1]\n示例 2:\n\n输入: 5\n输出: [0,1,1,2,1,2]\n进阶:\n```\n\n\n\n给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？\n要求算法的空间复杂度为O(n)。\n你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。\n\n\n\n### 代码\n\n``` go\nfunc countBits(num int) []int {\n  res := make([]int, num + 1)\n  for i := 1; i<num+1; i ++ {\n    res[i] += res[i&(i-1)] + 1\n  }\n  return res\n}\n```\n\n\n\n### 解题思路\n\n","source":"_posts/刷题心得/位运算/比特位计数.md","raw":"---\ntitle: 【位运算】比特位计数\ndate: 2020-02-11\ntags:\n- 算法\n- 位运算\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\n给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。\n\n```\n示例 1:\n\n输入: 2\n输出: [0,1,1]\n示例 2:\n\n输入: 5\n输出: [0,1,1,2,1,2]\n进阶:\n```\n\n\n\n给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？\n要求算法的空间复杂度为O(n)。\n你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。\n\n\n\n### 代码\n\n``` go\nfunc countBits(num int) []int {\n  res := make([]int, num + 1)\n  for i := 1; i<num+1; i ++ {\n    res[i] += res[i&(i-1)] + 1\n  }\n  return res\n}\n```\n\n\n\n### 解题思路\n\n","slug":"刷题心得/位运算/比特位计数","published":1,"updated":"2020-02-12T03:41:38.701Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2ttf0005mn8ng1pke3lf","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 2</span><br><span class=\"line\">输出: [0,1,1]</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 5</span><br><span class=\"line\">输出: [0,1,1,2,1,2]</span><br><span class=\"line\">进阶:</span><br></pre></td></tr></table></figure>\n\n\n\n<p>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？<br>要求算法的空间复杂度为O(n)。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countBits</span><span class=\"params\">(num <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  res := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, num + <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i&lt;num+<span class=\"number\">1</span>; i ++ &#123;</span><br><span class=\"line\">    res[i] += res[i&amp;(i<span class=\"number\">-1</span>)] + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 2</span><br><span class=\"line\">输出: [0,1,1]</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 5</span><br><span class=\"line\">输出: [0,1,1,2,1,2]</span><br><span class=\"line\">进阶:</span><br></pre></td></tr></table></figure>\n\n\n\n<p>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？<br>要求算法的空间复杂度为O(n)。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countBits</span><span class=\"params\">(num <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  res := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, num + <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i&lt;num+<span class=\"number\">1</span>; i ++ &#123;</span><br><span class=\"line\">    res[i] += res[i&amp;(i<span class=\"number\">-1</span>)] + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3>"},{"title":"【剪枝】n皇后","date":"2020-02-09T16:00:00.000Z","_content":"\n\n\n## 题目\n\nn 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n\n\n上图为 8 皇后问题的一种解法。\n\n给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\n\n示例:\n\n```\n输入: 4\n输出: [\n [\".Q..\",  // 解法 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // 解法 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n解释: 4 皇后问题存在两个不同的解法。\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nunc solveNQueens(n int) [][]string {\n\tif n == 0 {\n\t\treturn [][]string{}\n\t}\n\n\tcols := make([]bool, n)\n\t// 记录 '\\' 方向的对角线的占用情况\n\td1 := make([]bool, 2*n)\n\t// 记录 '/' 方向的对角线的占用情况\n\td2 := make([]bool, 2*n)\n\n\tboard := make([]string, n)\n\n\tres := [][]string{}\n\n\tdfs(0, cols, d1, d2, board, &res)\n\n\treturn res\n}\n\nfunc dfs(r int, cols, d1, d2 []bool, board []string, res *[][]string) {\n\n\tif r == len(board) {\n\t\ttmp := make([]string, len(board))\n\t\tcopy(tmp, board)\n\t\t*res = append(*res, tmp)\n\t\treturn\n\t}\n\n\tn := len(board)\n\n\tfor c := 0; c < len(board); c++ {\n\t\t// 把棋盘想象成\n\t\t//   以左上角为坐标原点 [0,0]\n\t\t//   C 轴正方向向右\n\t\t//   R 轴正方向向下\n\t\t// 的坐标系。\n\t\t// 这样的话，每个格子就都有了自己的坐标值 [c,r]\n\t\t//\n\t\t// 对于 '\\' 方向的斜线而言\n\t\t//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r-c 的结果相同，\n\t\t//   不同斜线上 r-c 的结果不同。\n\t\t//   所以可以用 r-c 代表不同的 '\\' 方向的斜线的编号。\n\t\t//   但是 r-c 有可能是负值，无法作为切片的索引值\n\t\t//   所以 +n，可知 r-c+n >= 0\n\t\t//   所以，使用 r-c+n 作为 '\\' 方向斜线切片的索引值。\n\t\t// 对于 '/' 方向的斜线而言\n\t\t//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r+c 的结果相同，\n\t\t//   不同斜线上 r+c 的结果不同。\n\t\t//   所以可以用 r+c 代表不同的 '/' 方向的斜线的编号。\n\t\t//   所以，使用 r+c 作为 '/' 方向斜线切片的索引值。\n\t\tid1 := r - c + n\n\t\tid2 := r + c\n\t\tif !cols[c] && !d1[id1] && !d2[id2] {\n\t\t\tb := make([]byte, n)\n\t\t\tfor i := range b {\n\t\t\t\tb[i] = '.'\n\t\t\t}\n\t\t\tb[c] = 'Q'\n\t\t\tboard[r] = string(b)\n\t\t\t// 标记占用\n\t\t\tcols[c], d1[id1], d2[id2] = true, true, true\n\n\t\t\tdfs(r+1, cols, d1, d2, board, res)\n\n\t\t\t// 解除标记\n\t\t\tcols[c], d1[id1], d2[id2] = false, false, false\n\t\t}\n\t}\n}\n```\n\n\n\n### 解题思路\n\n","source":"_posts/刷题心得/剪枝/n皇后.md","raw":"---\ntitle: 【剪枝】n皇后\ndate: 2020-02-10\ntags:\n- 算法\n- 剪枝\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\nn 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n\n\n上图为 8 皇后问题的一种解法。\n\n给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\n\n示例:\n\n```\n输入: 4\n输出: [\n [\".Q..\",  // 解法 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // 解法 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n解释: 4 皇后问题存在两个不同的解法。\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nunc solveNQueens(n int) [][]string {\n\tif n == 0 {\n\t\treturn [][]string{}\n\t}\n\n\tcols := make([]bool, n)\n\t// 记录 '\\' 方向的对角线的占用情况\n\td1 := make([]bool, 2*n)\n\t// 记录 '/' 方向的对角线的占用情况\n\td2 := make([]bool, 2*n)\n\n\tboard := make([]string, n)\n\n\tres := [][]string{}\n\n\tdfs(0, cols, d1, d2, board, &res)\n\n\treturn res\n}\n\nfunc dfs(r int, cols, d1, d2 []bool, board []string, res *[][]string) {\n\n\tif r == len(board) {\n\t\ttmp := make([]string, len(board))\n\t\tcopy(tmp, board)\n\t\t*res = append(*res, tmp)\n\t\treturn\n\t}\n\n\tn := len(board)\n\n\tfor c := 0; c < len(board); c++ {\n\t\t// 把棋盘想象成\n\t\t//   以左上角为坐标原点 [0,0]\n\t\t//   C 轴正方向向右\n\t\t//   R 轴正方向向下\n\t\t// 的坐标系。\n\t\t// 这样的话，每个格子就都有了自己的坐标值 [c,r]\n\t\t//\n\t\t// 对于 '\\' 方向的斜线而言\n\t\t//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r-c 的结果相同，\n\t\t//   不同斜线上 r-c 的结果不同。\n\t\t//   所以可以用 r-c 代表不同的 '\\' 方向的斜线的编号。\n\t\t//   但是 r-c 有可能是负值，无法作为切片的索引值\n\t\t//   所以 +n，可知 r-c+n >= 0\n\t\t//   所以，使用 r-c+n 作为 '\\' 方向斜线切片的索引值。\n\t\t// 对于 '/' 方向的斜线而言\n\t\t//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r+c 的结果相同，\n\t\t//   不同斜线上 r+c 的结果不同。\n\t\t//   所以可以用 r+c 代表不同的 '/' 方向的斜线的编号。\n\t\t//   所以，使用 r+c 作为 '/' 方向斜线切片的索引值。\n\t\tid1 := r - c + n\n\t\tid2 := r + c\n\t\tif !cols[c] && !d1[id1] && !d2[id2] {\n\t\t\tb := make([]byte, n)\n\t\t\tfor i := range b {\n\t\t\t\tb[i] = '.'\n\t\t\t}\n\t\t\tb[c] = 'Q'\n\t\t\tboard[r] = string(b)\n\t\t\t// 标记占用\n\t\t\tcols[c], d1[id1], d2[id2] = true, true, true\n\n\t\t\tdfs(r+1, cols, d1, d2, board, res)\n\n\t\t\t// 解除标记\n\t\t\tcols[c], d1[id1], d2[id2] = false, false, false\n\t\t}\n\t}\n}\n```\n\n\n\n### 解题思路\n\n","slug":"刷题心得/剪枝/n皇后","published":1,"updated":"2020-02-12T02:14:46.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2ttp0007mn8ndfhh73b6","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n<p>上图为 8 皇后问题的一种解法。</p>\n<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>\n<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 4</span><br><span class=\"line\">输出: [</span><br><span class=\"line\"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class=\"line\">  &quot;...Q&quot;,</span><br><span class=\"line\">  &quot;Q...&quot;,</span><br><span class=\"line\">  &quot;..Q.&quot;],</span><br><span class=\"line\"></span><br><span class=\"line\"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class=\"line\">  &quot;Q...&quot;,</span><br><span class=\"line\">  &quot;...Q&quot;,</span><br><span class=\"line\">  &quot;.Q..&quot;]</span><br><span class=\"line\">]</span><br><span class=\"line\">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unc solveNQueens(n <span class=\"keyword\">int</span>) [][]<span class=\"keyword\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> [][]<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcols := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, n)</span><br><span class=\"line\">\t<span class=\"comment\">// 记录 '\\' 方向的对角线的占用情况</span></span><br><span class=\"line\">\td1 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, <span class=\"number\">2</span>*n)</span><br><span class=\"line\">\t<span class=\"comment\">// 记录 '/' 方向的对角线的占用情况</span></span><br><span class=\"line\">\td2 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, <span class=\"number\">2</span>*n)</span><br><span class=\"line\"></span><br><span class=\"line\">\tboard := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, n)</span><br><span class=\"line\"></span><br><span class=\"line\">\tres := [][]<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdfs(<span class=\"number\">0</span>, cols, d1, d2, board, &amp;res)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(r <span class=\"keyword\">int</span>, cols, d1, d2 []<span class=\"keyword\">bool</span>, board []<span class=\"keyword\">string</span>, res *[][]<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r == <span class=\"built_in\">len</span>(board) &#123;</span><br><span class=\"line\">\t\ttmp := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"built_in\">len</span>(board))</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(tmp, board)</span><br><span class=\"line\">\t\t*res = <span class=\"built_in\">append</span>(*res, tmp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(board)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> c := <span class=\"number\">0</span>; c &lt; <span class=\"built_in\">len</span>(board); c++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 把棋盘想象成</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   以左上角为坐标原点 [0,0]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   C 轴正方向向右</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   R 轴正方向向下</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 的坐标系。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 这样的话，每个格子就都有了自己的坐标值 [c,r]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 对于 '\\' 方向的斜线而言</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r-c 的结果相同，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   不同斜线上 r-c 的结果不同。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以可以用 r-c 代表不同的 '\\' 方向的斜线的编号。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   但是 r-c 有可能是负值，无法作为切片的索引值</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以 +n，可知 r-c+n &gt;= 0</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以，使用 r-c+n 作为 '\\' 方向斜线切片的索引值。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 对于 '/' 方向的斜线而言</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r+c 的结果相同，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   不同斜线上 r+c 的结果不同。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以可以用 r+c 代表不同的 '/' 方向的斜线的编号。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以，使用 r+c 作为 '/' 方向斜线切片的索引值。</span></span><br><span class=\"line\">\t\tid1 := r - c + n</span><br><span class=\"line\">\t\tid2 := r + c</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2] &#123;</span><br><span class=\"line\">\t\t\tb := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> b &#123;</span><br><span class=\"line\">\t\t\t\tb[i] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tb[c] = <span class=\"string\">'Q'</span></span><br><span class=\"line\">\t\t\tboard[r] = <span class=\"keyword\">string</span>(b)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 标记占用</span></span><br><span class=\"line\">\t\t\tcols[c], d1[id1], d2[id2] = <span class=\"literal\">true</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tdfs(r+<span class=\"number\">1</span>, cols, d1, d2, board, res)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 解除标记</span></span><br><span class=\"line\">\t\t\tcols[c], d1[id1], d2[id2] = <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n<p>上图为 8 皇后问题的一种解法。</p>\n<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>\n<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 4</span><br><span class=\"line\">输出: [</span><br><span class=\"line\"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class=\"line\">  &quot;...Q&quot;,</span><br><span class=\"line\">  &quot;Q...&quot;,</span><br><span class=\"line\">  &quot;..Q.&quot;],</span><br><span class=\"line\"></span><br><span class=\"line\"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class=\"line\">  &quot;Q...&quot;,</span><br><span class=\"line\">  &quot;...Q&quot;,</span><br><span class=\"line\">  &quot;.Q..&quot;]</span><br><span class=\"line\">]</span><br><span class=\"line\">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unc solveNQueens(n <span class=\"keyword\">int</span>) [][]<span class=\"keyword\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> [][]<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcols := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, n)</span><br><span class=\"line\">\t<span class=\"comment\">// 记录 '\\' 方向的对角线的占用情况</span></span><br><span class=\"line\">\td1 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, <span class=\"number\">2</span>*n)</span><br><span class=\"line\">\t<span class=\"comment\">// 记录 '/' 方向的对角线的占用情况</span></span><br><span class=\"line\">\td2 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, <span class=\"number\">2</span>*n)</span><br><span class=\"line\"></span><br><span class=\"line\">\tboard := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, n)</span><br><span class=\"line\"></span><br><span class=\"line\">\tres := [][]<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdfs(<span class=\"number\">0</span>, cols, d1, d2, board, &amp;res)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(r <span class=\"keyword\">int</span>, cols, d1, d2 []<span class=\"keyword\">bool</span>, board []<span class=\"keyword\">string</span>, res *[][]<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r == <span class=\"built_in\">len</span>(board) &#123;</span><br><span class=\"line\">\t\ttmp := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"built_in\">len</span>(board))</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(tmp, board)</span><br><span class=\"line\">\t\t*res = <span class=\"built_in\">append</span>(*res, tmp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(board)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> c := <span class=\"number\">0</span>; c &lt; <span class=\"built_in\">len</span>(board); c++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 把棋盘想象成</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   以左上角为坐标原点 [0,0]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   C 轴正方向向右</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   R 轴正方向向下</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 的坐标系。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 这样的话，每个格子就都有了自己的坐标值 [c,r]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 对于 '\\' 方向的斜线而言</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r-c 的结果相同，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   不同斜线上 r-c 的结果不同。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以可以用 r-c 代表不同的 '\\' 方向的斜线的编号。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   但是 r-c 有可能是负值，无法作为切片的索引值</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以 +n，可知 r-c+n &gt;= 0</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以，使用 r-c+n 作为 '\\' 方向斜线切片的索引值。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 对于 '/' 方向的斜线而言</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r+c 的结果相同，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   不同斜线上 r+c 的结果不同。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以可以用 r+c 代表不同的 '/' 方向的斜线的编号。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以，使用 r+c 作为 '/' 方向斜线切片的索引值。</span></span><br><span class=\"line\">\t\tid1 := r - c + n</span><br><span class=\"line\">\t\tid2 := r + c</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2] &#123;</span><br><span class=\"line\">\t\t\tb := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> b &#123;</span><br><span class=\"line\">\t\t\t\tb[i] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tb[c] = <span class=\"string\">'Q'</span></span><br><span class=\"line\">\t\t\tboard[r] = <span class=\"keyword\">string</span>(b)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 标记占用</span></span><br><span class=\"line\">\t\t\tcols[c], d1[id1], d2[id2] = <span class=\"literal\">true</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tdfs(r+<span class=\"number\">1</span>, cols, d1, d2, board, res)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 解除标记</span></span><br><span class=\"line\">\t\t\tcols[c], d1[id1], d2[id2] = <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3>"},{"ååtitle":"【哈希表】有效的字母异位词","date":"2020-02-06T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n\n示例 1:\n\n```\n输入: s = \"anagram\", t = \"nagaram\"\n输出: true\n```\n\n示例 2:\n\n```\n输入: s = \"rat\", t = \"car\"\n输出: false\n```\n\n说明:\n你可以假设字符串只包含小写字母。\n\n## 代码\n\n``` go\nfunc isAnagram(s string, t string) bool {\n  if len(s) != len(t) {\n    return false\n  }\n  sr := []rune{s}\n  tr := []rune{t}\n  rec := make(map[rune]int, len(s))\n  for i:=0; i<len(s); i++ {\n    rec[sr[i]] ++\n    rec[tr[i]] --\n  }\n  for \n}\n```\n\n\n\n","source":"_posts/刷题心得/哈希表/异位词.md","raw":"---\nååtitle: 【哈希表】有效的字母异位词\ndate: 2020-02-07\ntags:\n- 算法\n- 哈希表\ncategories:\n- 刷题心得\n\n\n\n\n---\n\n\n\n## 题目\n\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n\n示例 1:\n\n```\n输入: s = \"anagram\", t = \"nagaram\"\n输出: true\n```\n\n示例 2:\n\n```\n输入: s = \"rat\", t = \"car\"\n输出: false\n```\n\n说明:\n你可以假设字符串只包含小写字母。\n\n## 代码\n\n``` go\nfunc isAnagram(s string, t string) bool {\n  if len(s) != len(t) {\n    return false\n  }\n  sr := []rune{s}\n  tr := []rune{t}\n  rec := make(map[rune]int, len(s))\n  for i:=0; i<len(s); i++ {\n    rec[sr[i]] ++\n    rec[tr[i]] --\n  }\n  for \n}\n```\n\n\n\n","slug":"刷题心得/哈希表/异位词","published":1,"updated":"2020-02-07T02:27:49.649Z","title":"刷题心得/哈希表/异位词","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2ttq0008mn8nahzycueq","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n\n<p>说明:<br>你可以假设字符串只包含小写字母。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isAnagram</span><span class=\"params\">(s <span class=\"keyword\">string</span>, t <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) != <span class=\"built_in\">len</span>(t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sr := []<span class=\"keyword\">rune</span>&#123;s&#125;</span><br><span class=\"line\">  tr := []<span class=\"keyword\">rune</span>&#123;t&#125;</span><br><span class=\"line\">  rec := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">rune</span>]<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">    rec[sr[i]] ++</span><br><span class=\"line\">    rec[tr[i]] --</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n\n<p>说明:<br>你可以假设字符串只包含小写字母。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isAnagram</span><span class=\"params\">(s <span class=\"keyword\">string</span>, t <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) != <span class=\"built_in\">len</span>(t) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sr := []<span class=\"keyword\">rune</span>&#123;s&#125;</span><br><span class=\"line\">  tr := []<span class=\"keyword\">rune</span>&#123;t&#125;</span><br><span class=\"line\">  rec := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">rune</span>]<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(s))</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">    rec[sr[i]] ++</span><br><span class=\"line\">    rec[tr[i]] --</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"【二分法】求平方根","date":"2020-02-10T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n```\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n```\n\n\n\n\n\n### 代码\n\n``` go\nfunc searchInsert(nums []int, target int) int {\n  if len(nums) == 0 {\n    return 0\n  }\n  l,r := 0,len(nums)-1\n  if nums[r] < target {\n    return r + 1\n  }\n  for l < r {\n    mid := (l + r) / 2\n    if target == nums[mid] {\n      return mid\n    }\n    if target < nums[mid] {\n      r = mid\n    }\n    if target > nums[mid] {\n      l = mid + 1\n    }\n  }\n  \n  return l\n}\n```\n\n\n\n\n\n``` go\nfunc searchInsert(nums []int, target int) int {\n\t// 没有把i放入for语句中\n\t// 是为了兼容，len(nums) == 0 和 target > nums[len(nums)-1]两种情况\n\ti := 0\n\n\tfor i < len(nums) && nums[i] <= target {\n\t\t// 相等的时候，直接返回\n\t\tif nums[i] == target {\n\t\t\treturn i\n\t\t}\n\n\t\t// 否则，就去检查下一个\n\t\ti++\n\t}\n\n\treturn i\n}\n```\n\n\n\n### 解题思路\n\n","source":"_posts/刷题心得/二分法/求平方根.md","raw":"---\ntitle: 【二分法】求平方根\ndate: 2020-02-11\ntags:\n- 算法\n- 二分法\ncategories:\n- 刷题心得\n\n---\n\n\n\n## 题目\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n```\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n```\n\n\n\n\n\n### 代码\n\n``` go\nfunc searchInsert(nums []int, target int) int {\n  if len(nums) == 0 {\n    return 0\n  }\n  l,r := 0,len(nums)-1\n  if nums[r] < target {\n    return r + 1\n  }\n  for l < r {\n    mid := (l + r) / 2\n    if target == nums[mid] {\n      return mid\n    }\n    if target < nums[mid] {\n      r = mid\n    }\n    if target > nums[mid] {\n      l = mid + 1\n    }\n  }\n  \n  return l\n}\n```\n\n\n\n\n\n``` go\nfunc searchInsert(nums []int, target int) int {\n\t// 没有把i放入for语句中\n\t// 是为了兼容，len(nums) == 0 和 target > nums[len(nums)-1]两种情况\n\ti := 0\n\n\tfor i < len(nums) && nums[i] <= target {\n\t\t// 相等的时候，直接返回\n\t\tif nums[i] == target {\n\t\t\treturn i\n\t\t}\n\n\t\t// 否则，就去检查下一个\n\t\ti++\n\t}\n\n\treturn i\n}\n```\n\n\n\n### 解题思路\n\n","slug":"刷题心得/二分法/求平方根","published":1,"updated":"2020-02-12T02:38:32.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2ttq000amn8nelo246dm","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n<p>你可以假设数组中无重复元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,3,5,6], 5</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,3,5,6], 2</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">示例 3:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,3,5,6], 7</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">示例 4:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,3,5,6], 0</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchInsert</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>, target <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nums) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  l,r := <span class=\"number\">0</span>,<span class=\"built_in\">len</span>(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> nums[r] &lt; target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> l &lt; r &#123;</span><br><span class=\"line\">    mid := (l + r) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> target == nums[mid] &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> target &lt; nums[mid] &#123;</span><br><span class=\"line\">      r = mid</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> target &gt; nums[mid] &#123;</span><br><span class=\"line\">      l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchInsert</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>, target <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 没有把i放入for语句中</span></span><br><span class=\"line\">\t<span class=\"comment\">// 是为了兼容，len(nums) == 0 和 target &gt; nums[len(nums)-1]两种情况</span></span><br><span class=\"line\">\ti := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i &lt; <span class=\"built_in\">len</span>(nums) &amp;&amp; nums[i] &lt;= target &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 相等的时候，直接返回</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[i] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 否则，就去检查下一个</span></span><br><span class=\"line\">\t\ti++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n<p>你可以假设数组中无重复元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,3,5,6], 5</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,3,5,6], 2</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">示例 3:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,3,5,6], 7</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">示例 4:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [1,3,5,6], 0</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchInsert</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>, target <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nums) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  l,r := <span class=\"number\">0</span>,<span class=\"built_in\">len</span>(nums)<span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> nums[r] &lt; target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> l &lt; r &#123;</span><br><span class=\"line\">    mid := (l + r) / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> target == nums[mid] &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> target &lt; nums[mid] &#123;</span><br><span class=\"line\">      r = mid</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> target &gt; nums[mid] &#123;</span><br><span class=\"line\">      l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchInsert</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>, target <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 没有把i放入for语句中</span></span><br><span class=\"line\">\t<span class=\"comment\">// 是为了兼容，len(nums) == 0 和 target &gt; nums[len(nums)-1]两种情况</span></span><br><span class=\"line\">\ti := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i &lt; <span class=\"built_in\">len</span>(nums) &amp;&amp; nums[i] &lt;= target &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 相等的时候，直接返回</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[i] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 否则，就去检查下一个</span></span><br><span class=\"line\">\t\ti++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3>"},{"title":"【位运算】2的幂","date":"2020-02-10T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个整数，编写一个函数来判断它是否是 2 的幂次方。\n\n```\n示例 1:\n\n输入: 1\n输出: true\n解释: 20 = 1\n示例 2:\n\n输入: 16\n输出: true\n解释: 24 = 16\n示例 3:\n\n输入: 218\n输出: false\n\n```\n\n\n\n\n\n### 代码\n\n``` go\nfunc isPowerOfTwo(n int) bool {\n  if n == 0 {\n      return true\n  }\n  return n & (n-1) == 0   \n}\n```\n\n\n\n### 解题思路\n\n#### mod\n\n\n\n#### log2 = int\n\n\n\n####位运算\n\nn&(n-1)","source":"_posts/刷题心得/位运算/2的幂.md","raw":"---\ntitle: 【位运算】2的幂\ndate: 2020-02-11\ntags:\n- 算法\n- 位运算\ncategories:\n- 刷题心得\n\n---\n\n\n\n## 题目\n\n给定一个整数，编写一个函数来判断它是否是 2 的幂次方。\n\n```\n示例 1:\n\n输入: 1\n输出: true\n解释: 20 = 1\n示例 2:\n\n输入: 16\n输出: true\n解释: 24 = 16\n示例 3:\n\n输入: 218\n输出: false\n\n```\n\n\n\n\n\n### 代码\n\n``` go\nfunc isPowerOfTwo(n int) bool {\n  if n == 0 {\n      return true\n  }\n  return n & (n-1) == 0   \n}\n```\n\n\n\n### 解题思路\n\n#### mod\n\n\n\n#### log2 = int\n\n\n\n####位运算\n\nn&(n-1)","slug":"刷题心得/位运算/2的幂","published":1,"updated":"2020-02-12T03:23:10.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tts000emn8nc759hbmx","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 1</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 20 &#x3D; 1</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 16</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 24 &#x3D; 16</span><br><span class=\"line\">示例 3:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 218</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n &amp; (n<span class=\"number\">-1</span>) == <span class=\"number\">0</span>   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h4 id=\"mod\"><a href=\"#mod\" class=\"headerlink\" title=\"mod\"></a>mod</h4><h4 id=\"log2-int\"><a href=\"#log2-int\" class=\"headerlink\" title=\"log2 = int\"></a>log2 = int</h4><p>####位运算</p>\n<p>n&amp;(n-1)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 1</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 20 &#x3D; 1</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 16</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 24 &#x3D; 16</span><br><span class=\"line\">示例 3:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: 218</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n &amp; (n<span class=\"number\">-1</span>) == <span class=\"number\">0</span>   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h4 id=\"mod\"><a href=\"#mod\" class=\"headerlink\" title=\"mod\"></a>mod</h4><h4 id=\"log2-int\"><a href=\"#log2-int\" class=\"headerlink\" title=\"log2 = int\"></a>log2 = int</h4><p>####位运算</p>\n<p>n&amp;(n-1)</p>\n"},{"ååtitle":"【栈和队列】用栈实现队列","date":"2020-02-04T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口中的最大值。\n\n \n\n示例:\n\n```\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n输出: [3,3,5,5,6,7] \n解释: \n\n  滑动窗口的位置                最大值\n\n---------------               -----\n\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n\n\n\n提示：\n\n你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。\n\n \n\n进阶：\n\n你能在线性时间复杂度内解决此题吗？\n\n## 代码\n\n``` go\n// 参看 https://leetcode.com/problems/sliding-window-maximum/discuss/65881/O(n)-solution-in-Java-with-two-simple-pass-in-the-array\nfunc maxSlidingWindow(nums []int, k int) []int {\n\tsize := len(nums)\n\tif k <= 1 {\n\t\treturn nums\n\t}\n\n\tg := k - 1 // 比参考文章的分组少一个，可以减少 max 函数的调用，理论上可以加速。\n\n\tleft := make([]int, size)\n\tfor i := 0; i < size; i++ {\n\t\tif i%g == 0 {\n\t\t\tleft[i] = nums[i]\n\t\t} else {\n\t\t\tleft[i] = max(nums[i], left[i-1])\n\t\t}\n\t}\n\n\tright := make([]int, size)\n\t// size-1 很可能不是那组的最后一个，需要单独列出\n\tright[size-1] = nums[size-1]\n\tfor j := size - 2; j >= 0; j-- {\n\t\tif (j+1)%g == 0 {\n\t\t\tright[j] = nums[j]\n\t\t} else {\n\t\t\tright[j] = max(nums[j], right[j+1])\n\t\t}\n\t}\n\n\tres := make([]int, size-k+1)\n\tfor i := 0; i <= size-k; i++ {\n\t\t// right[i] 中保存了 nums[i:g*(i/g+1)] 中的最大值\n\t\t// left[i+k-1] 中保存了 nums[g*(i/g+1):i+k] 中的最大值\n\t\tres[i] = max(right[i], left[i+k-1])\n\t}\n\n\treturn res\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n```\n\n\n\n","source":"_posts/刷题心得/栈和队列/滑动窗口最大值.md","raw":"---\nååtitle: 【栈和队列】用栈实现队列\ndate: 2020-02-05\ntags:\n- 算法\n- 栈\ncategories:\n- 刷题心得\n\n\n\n---\n\n\n\n## 题目\n\n给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n\n返回滑动窗口中的最大值。\n\n \n\n示例:\n\n```\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n输出: [3,3,5,5,6,7] \n解释: \n\n  滑动窗口的位置                最大值\n\n---------------               -----\n\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n\n\n\n提示：\n\n你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。\n\n \n\n进阶：\n\n你能在线性时间复杂度内解决此题吗？\n\n## 代码\n\n``` go\n// 参看 https://leetcode.com/problems/sliding-window-maximum/discuss/65881/O(n)-solution-in-Java-with-two-simple-pass-in-the-array\nfunc maxSlidingWindow(nums []int, k int) []int {\n\tsize := len(nums)\n\tif k <= 1 {\n\t\treturn nums\n\t}\n\n\tg := k - 1 // 比参考文章的分组少一个，可以减少 max 函数的调用，理论上可以加速。\n\n\tleft := make([]int, size)\n\tfor i := 0; i < size; i++ {\n\t\tif i%g == 0 {\n\t\t\tleft[i] = nums[i]\n\t\t} else {\n\t\t\tleft[i] = max(nums[i], left[i-1])\n\t\t}\n\t}\n\n\tright := make([]int, size)\n\t// size-1 很可能不是那组的最后一个，需要单独列出\n\tright[size-1] = nums[size-1]\n\tfor j := size - 2; j >= 0; j-- {\n\t\tif (j+1)%g == 0 {\n\t\t\tright[j] = nums[j]\n\t\t} else {\n\t\t\tright[j] = max(nums[j], right[j+1])\n\t\t}\n\t}\n\n\tres := make([]int, size-k+1)\n\tfor i := 0; i <= size-k; i++ {\n\t\t// right[i] 中保存了 nums[i:g*(i/g+1)] 中的最大值\n\t\t// left[i+k-1] 中保存了 nums[g*(i/g+1):i+k] 中的最大值\n\t\tres[i] = max(right[i], left[i+k-1])\n\t}\n\n\treturn res\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n```\n\n\n\n","slug":"刷题心得/栈和队列/滑动窗口最大值","published":1,"updated":"2020-02-06T04:01:25.817Z","title":"刷题心得/栈和队列/滑动窗口最大值","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2ttv000hmn8n8y1329u9","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>\n<p>返回滑动窗口中的最大值。</p>\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class=\"line\">输出: [3,3,5,5,6,7] </span><br><span class=\"line\">解释: </span><br><span class=\"line\"></span><br><span class=\"line\">  滑动窗口的位置                最大值</span><br><span class=\"line\"></span><br><span class=\"line\">---------------               -----</span><br><span class=\"line\"></span><br><span class=\"line\">[1  3  -1] -3  5  3  6  7       3</span><br><span class=\"line\"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class=\"line\"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class=\"line\"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class=\"line\"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class=\"line\"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>提示：</p>\n<p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>\n<p>进阶：</p>\n<p>你能在线性时间复杂度内解决此题吗？</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参看 https://leetcode.com/problems/sliding-window-maximum/discuss/65881/O(n)-solution-in-Java-with-two-simple-pass-in-the-array</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxSlidingWindow</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>, k <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> k &lt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nums</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tg := k - <span class=\"number\">1</span> <span class=\"comment\">// 比参考文章的分组少一个，可以减少 max 函数的调用，理论上可以加速。</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tleft := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, size)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; size; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i%g == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tleft[i] = nums[i]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tleft[i] = max(nums[i], left[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tright := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, size)</span><br><span class=\"line\">\t<span class=\"comment\">// size-1 很可能不是那组的最后一个，需要单独列出</span></span><br><span class=\"line\">\tright[size<span class=\"number\">-1</span>] = nums[size<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j := size - <span class=\"number\">2</span>; j &gt;= <span class=\"number\">0</span>; j-- &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j+<span class=\"number\">1</span>)%g == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tright[j] = nums[j]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tright[j] = max(nums[j], right[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tres := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, size-k+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;= size-k; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// right[i] 中保存了 nums[i:g*(i/g+1)] 中的最大值</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// left[i+k-1] 中保存了 nums[g*(i/g+1):i+k] 中的最大值</span></span><br><span class=\"line\">\t\tres[i] = max(right[i], left[i+k<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(a, b <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a &gt; b &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>\n<p>返回滑动窗口中的最大值。</p>\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class=\"line\">输出: [3,3,5,5,6,7] </span><br><span class=\"line\">解释: </span><br><span class=\"line\"></span><br><span class=\"line\">  滑动窗口的位置                最大值</span><br><span class=\"line\"></span><br><span class=\"line\">---------------               -----</span><br><span class=\"line\"></span><br><span class=\"line\">[1  3  -1] -3  5  3  6  7       3</span><br><span class=\"line\"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class=\"line\"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class=\"line\"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class=\"line\"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class=\"line\"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>提示：</p>\n<p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>\n<p>进阶：</p>\n<p>你能在线性时间复杂度内解决此题吗？</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参看 https://leetcode.com/problems/sliding-window-maximum/discuss/65881/O(n)-solution-in-Java-with-two-simple-pass-in-the-array</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxSlidingWindow</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>, k <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> k &lt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nums</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tg := k - <span class=\"number\">1</span> <span class=\"comment\">// 比参考文章的分组少一个，可以减少 max 函数的调用，理论上可以加速。</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tleft := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, size)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; size; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i%g == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tleft[i] = nums[i]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tleft[i] = max(nums[i], left[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tright := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, size)</span><br><span class=\"line\">\t<span class=\"comment\">// size-1 很可能不是那组的最后一个，需要单独列出</span></span><br><span class=\"line\">\tright[size<span class=\"number\">-1</span>] = nums[size<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j := size - <span class=\"number\">2</span>; j &gt;= <span class=\"number\">0</span>; j-- &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j+<span class=\"number\">1</span>)%g == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tright[j] = nums[j]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tright[j] = max(nums[j], right[j+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tres := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, size-k+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;= size-k; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// right[i] 中保存了 nums[i:g*(i/g+1)] 中的最大值</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// left[i+k-1] 中保存了 nums[g*(i/g+1):i+k] 中的最大值</span></span><br><span class=\"line\">\t\tres[i] = max(right[i], left[i+k<span class=\"number\">-1</span>])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(a, b <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a &gt; b &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"ååtitle":"【树】二叉树的层次遍历","date":"2020-02-09T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。\n\n例如:\n\n```\n给定二叉树: [3,9,20,null,null,15,7],\n\n    3\n\n   / \\\n  9  20\n    /  \\\n   15   7\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n```\n\n\n\n\n\n## 代码\n\n``` go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrder(root *TreeNode) [][]int {\n  res := [][]int{}\n  return dfs(root, 0, res)\n}\n\nfunc dfs(root *TreeNode, level int, res [][]int) [][]int {\n  if root == nil {\n    return res\n  }\n  if level >= len(res) {\n    res = append(res, []int{})\n  }\n  res[level] = append(res[level], root.Val)\n  res = dfs(root.Left, level+1, res)\n  res = dfs(root.Right, level+1, res)\n\treturn res\n}\n```\n\n\n\n","source":"_posts/刷题心得/树/二叉树的层次遍历.md","raw":"---\nååtitle: 【树】二叉树的层次遍历\ndate: 2020-02-10\ntags:\n- 算法\n- 树\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\n给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。\n\n例如:\n\n```\n给定二叉树: [3,9,20,null,null,15,7],\n\n    3\n\n   / \\\n  9  20\n    /  \\\n   15   7\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n```\n\n\n\n\n\n## 代码\n\n``` go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrder(root *TreeNode) [][]int {\n  res := [][]int{}\n  return dfs(root, 0, res)\n}\n\nfunc dfs(root *TreeNode, level int, res [][]int) [][]int {\n  if root == nil {\n    return res\n  }\n  if level >= len(res) {\n    res = append(res, []int{})\n  }\n  res[level] = append(res[level], root.Val)\n  res = dfs(root.Left, level+1, res)\n  res = dfs(root.Right, level+1, res)\n\treturn res\n}\n```\n\n\n\n","slug":"刷题心得/树/二叉树的层次遍历","published":1,"updated":"2020-02-26T06:12:33.192Z","title":"刷题心得/树/二叉树的层次遍历","_id":"ck71t2ttw000lmn8naakdgtfc","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class=\"line\"></span><br><span class=\"line\">    3</span><br><span class=\"line\"></span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">返回其层次遍历结果：</span><br><span class=\"line\"></span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [9,20],</span><br><span class=\"line\">  [15,7]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *TreeNode)</span> [][]<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  res := [][]<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dfs(root, <span class=\"number\">0</span>, res)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(root *TreeNode, level <span class=\"keyword\">int</span>, res [][]<span class=\"keyword\">int</span>)</span> [][]<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> level &gt;= <span class=\"built_in\">len</span>(res) &#123;</span><br><span class=\"line\">    res = <span class=\"built_in\">append</span>(res, []<span class=\"keyword\">int</span>&#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res[level] = <span class=\"built_in\">append</span>(res[level], root.Val)</span><br><span class=\"line\">  res = dfs(root.Left, level+<span class=\"number\">1</span>, res)</span><br><span class=\"line\">  res = dfs(root.Right, level+<span class=\"number\">1</span>, res)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>\n<p>例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class=\"line\"></span><br><span class=\"line\">    3</span><br><span class=\"line\"></span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">返回其层次遍历结果：</span><br><span class=\"line\"></span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [9,20],</span><br><span class=\"line\">  [15,7]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *TreeNode)</span> [][]<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  res := [][]<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dfs(root, <span class=\"number\">0</span>, res)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(root *TreeNode, level <span class=\"keyword\">int</span>, res [][]<span class=\"keyword\">int</span>)</span> [][]<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> level &gt;= <span class=\"built_in\">len</span>(res) &#123;</span><br><span class=\"line\">    res = <span class=\"built_in\">append</span>(res, []<span class=\"keyword\">int</span>&#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res[level] = <span class=\"built_in\">append</span>(res[level], root.Val)</span><br><span class=\"line\">  res = dfs(root.Left, level+<span class=\"number\">1</span>, res)</span><br><span class=\"line\">  res = dfs(root.Right, level+<span class=\"number\">1</span>, res)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"ååtitle":"【栈和队列】第K大元素","date":"2020-02-04T16:00:00.000Z","_content":"\n\n\n## 题目\n\n设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。\n\n你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。\n\n示例:\n\n```java\nint k = 3;\nint[] arr = [4,5,8,2];\nKthLargest kthLargest = new KthLargest(3, arr);\nkthLargest.add(3);   // returns 4\nkthLargest.add(5);   // returns 5\nkthLargest.add(10);  // returns 5\nkthLargest.add(9);   // returns 8\nkthLargest.add(4);   // returns 8\n```\n\n\n\n说明:\n你可以假设 nums 的长度≥ k-1 且k ≥ 1。\n\n\n\n## 代码\n\n``` go\npackage problem0703\n\nimport (\n\t\"container/heap\"\n)\n\n// KthLargest object will be instantiated and called as such:\n// obj := Constructor(k, nums);\n// param_1 := obj.Add(val);\ntype KthLargest struct {\n\tk    int\n\theap intHeap\n}\n\n// Constructor 创建 KthLargest\nfunc Constructor(k int, nums []int) KthLargest {\n\th := intHeap(nums)\n\theap.Init(&h)\n\n\tfor len(h) > k {\n\t\theap.Pop(&h)\n\t}\n\n\treturn KthLargest{\n\t\tk:    k,\n\t\theap: h,\n\t}\n}\n\n// Add 负责添加元素\nfunc (kl *KthLargest) Add(val int) int {\n\theap.Push(&kl.heap, val)\n\n\tif len(kl.heap) > kl.k {\n\t\theap.Pop(&kl.heap)\n\t}\n\n\treturn kl.heap[0]\n}\n\ntype intHeap []int\n\nfunc (h intHeap) Len() int {\n\treturn len(h)\n}\n\nfunc (h intHeap) Less(i, j int) bool {\n\treturn h[i] < h[j]\n}\n\nfunc (h intHeap) Swap(i, j int) {\n\th[i], h[j] = h[j], h[i]\n}\nfunc (h *intHeap) Push(x interface{}) {\n\t// Push 使用 *h，是因为\n\t// Push 增加了 h 的长度\n\t*h = append(*h, x.(int))\n}\n\nfunc (h *intHeap) Pop() interface{} {\n\t// Pop 使用 *h ，是因为\n\t// Pop 减短了 h 的长度\n\tres := (*h)[len(*h)-1]\n\t*h = (*h)[:len(*h)-1]\n\treturn res\n}\n```\n\n\n\n","source":"_posts/刷题心得/栈和队列/第k大元素.md","raw":"---\nååtitle: 【栈和队列】第K大元素\ndate: 2020-02-05\ntags:\n- 算法\n- 队列\ncategories:\n- 刷题心得\n\n\n---\n\n\n\n## 题目\n\n设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。\n\n你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。\n\n示例:\n\n```java\nint k = 3;\nint[] arr = [4,5,8,2];\nKthLargest kthLargest = new KthLargest(3, arr);\nkthLargest.add(3);   // returns 4\nkthLargest.add(5);   // returns 5\nkthLargest.add(10);  // returns 5\nkthLargest.add(9);   // returns 8\nkthLargest.add(4);   // returns 8\n```\n\n\n\n说明:\n你可以假设 nums 的长度≥ k-1 且k ≥ 1。\n\n\n\n## 代码\n\n``` go\npackage problem0703\n\nimport (\n\t\"container/heap\"\n)\n\n// KthLargest object will be instantiated and called as such:\n// obj := Constructor(k, nums);\n// param_1 := obj.Add(val);\ntype KthLargest struct {\n\tk    int\n\theap intHeap\n}\n\n// Constructor 创建 KthLargest\nfunc Constructor(k int, nums []int) KthLargest {\n\th := intHeap(nums)\n\theap.Init(&h)\n\n\tfor len(h) > k {\n\t\theap.Pop(&h)\n\t}\n\n\treturn KthLargest{\n\t\tk:    k,\n\t\theap: h,\n\t}\n}\n\n// Add 负责添加元素\nfunc (kl *KthLargest) Add(val int) int {\n\theap.Push(&kl.heap, val)\n\n\tif len(kl.heap) > kl.k {\n\t\theap.Pop(&kl.heap)\n\t}\n\n\treturn kl.heap[0]\n}\n\ntype intHeap []int\n\nfunc (h intHeap) Len() int {\n\treturn len(h)\n}\n\nfunc (h intHeap) Less(i, j int) bool {\n\treturn h[i] < h[j]\n}\n\nfunc (h intHeap) Swap(i, j int) {\n\th[i], h[j] = h[j], h[i]\n}\nfunc (h *intHeap) Push(x interface{}) {\n\t// Push 使用 *h，是因为\n\t// Push 增加了 h 的长度\n\t*h = append(*h, x.(int))\n}\n\nfunc (h *intHeap) Pop() interface{} {\n\t// Pop 使用 *h ，是因为\n\t// Pop 减短了 h 的长度\n\tres := (*h)[len(*h)-1]\n\t*h = (*h)[:len(*h)-1]\n\treturn res\n}\n```\n\n\n\n","slug":"刷题心得/栈和队列/第k大元素","published":1,"updated":"2020-02-06T03:02:53.598Z","title":"刷题心得/栈和队列/第k大元素","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2ttx000omn8ngdalhe78","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p>\n<p>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。</p>\n<p>示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> k = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">KthLargest kthLargest = <span class=\"keyword\">new</span> KthLargest(<span class=\"number\">3</span>, arr);</span><br><span class=\"line\">kthLargest.add(<span class=\"number\">3</span>);   <span class=\"comment\">// returns 4</span></span><br><span class=\"line\">kthLargest.add(<span class=\"number\">5</span>);   <span class=\"comment\">// returns 5</span></span><br><span class=\"line\">kthLargest.add(<span class=\"number\">10</span>);  <span class=\"comment\">// returns 5</span></span><br><span class=\"line\">kthLargest.add(<span class=\"number\">9</span>);   <span class=\"comment\">// returns 8</span></span><br><span class=\"line\">kthLargest.add(<span class=\"number\">4</span>);   <span class=\"comment\">// returns 8</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>说明:<br>你可以假设 nums 的长度≥ k-1 且k ≥ 1。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> problem0703</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"container/heap\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// KthLargest object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\">// obj := Constructor(k, nums);</span></span><br><span class=\"line\"><span class=\"comment\">// param_1 := obj.Add(val);</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> KthLargest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tk    <span class=\"keyword\">int</span></span><br><span class=\"line\">\theap intHeap</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Constructor 创建 KthLargest</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(k <span class=\"keyword\">int</span>, nums []<span class=\"keyword\">int</span>)</span> <span class=\"title\">KthLargest</span></span> &#123;</span><br><span class=\"line\">\th := intHeap(nums)</span><br><span class=\"line\">\theap.Init(&amp;h)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(h) &gt; k &#123;</span><br><span class=\"line\">\t\theap.Pop(&amp;h)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> KthLargest&#123;</span><br><span class=\"line\">\t\tk:    k,</span><br><span class=\"line\">\t\theap: h,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add 负责添加元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *KthLargest)</span> <span class=\"title\">Add</span><span class=\"params\">(val <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\theap.Push(&amp;kl.heap, val)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(kl.heap) &gt; kl.k &#123;</span><br><span class=\"line\">\t\theap.Pop(&amp;kl.heap)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> kl.heap[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> intHeap []<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h intHeap)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(h)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h intHeap)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h[i] &lt; h[j]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h intHeap)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\th[i], h[j] = h[j], h[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *intHeap)</span> <span class=\"title\">Push</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Push 使用 *h，是因为</span></span><br><span class=\"line\">\t<span class=\"comment\">// Push 增加了 h 的长度</span></span><br><span class=\"line\">\t*h = <span class=\"built_in\">append</span>(*h, x.(<span class=\"keyword\">int</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *intHeap)</span> <span class=\"title\">Pop</span><span class=\"params\">()</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Pop 使用 *h ，是因为</span></span><br><span class=\"line\">\t<span class=\"comment\">// Pop 减短了 h 的长度</span></span><br><span class=\"line\">\tres := (*h)[<span class=\"built_in\">len</span>(*h)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t*h = (*h)[:<span class=\"built_in\">len</span>(*h)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p>\n<p>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。</p>\n<p>示例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> k = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">KthLargest kthLargest = <span class=\"keyword\">new</span> KthLargest(<span class=\"number\">3</span>, arr);</span><br><span class=\"line\">kthLargest.add(<span class=\"number\">3</span>);   <span class=\"comment\">// returns 4</span></span><br><span class=\"line\">kthLargest.add(<span class=\"number\">5</span>);   <span class=\"comment\">// returns 5</span></span><br><span class=\"line\">kthLargest.add(<span class=\"number\">10</span>);  <span class=\"comment\">// returns 5</span></span><br><span class=\"line\">kthLargest.add(<span class=\"number\">9</span>);   <span class=\"comment\">// returns 8</span></span><br><span class=\"line\">kthLargest.add(<span class=\"number\">4</span>);   <span class=\"comment\">// returns 8</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>说明:<br>你可以假设 nums 的长度≥ k-1 且k ≥ 1。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> problem0703</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"container/heap\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// KthLargest object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\">// obj := Constructor(k, nums);</span></span><br><span class=\"line\"><span class=\"comment\">// param_1 := obj.Add(val);</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> KthLargest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tk    <span class=\"keyword\">int</span></span><br><span class=\"line\">\theap intHeap</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Constructor 创建 KthLargest</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(k <span class=\"keyword\">int</span>, nums []<span class=\"keyword\">int</span>)</span> <span class=\"title\">KthLargest</span></span> &#123;</span><br><span class=\"line\">\th := intHeap(nums)</span><br><span class=\"line\">\theap.Init(&amp;h)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(h) &gt; k &#123;</span><br><span class=\"line\">\t\theap.Pop(&amp;h)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> KthLargest&#123;</span><br><span class=\"line\">\t\tk:    k,</span><br><span class=\"line\">\t\theap: h,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add 负责添加元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(kl *KthLargest)</span> <span class=\"title\">Add</span><span class=\"params\">(val <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\theap.Push(&amp;kl.heap, val)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(kl.heap) &gt; kl.k &#123;</span><br><span class=\"line\">\t\theap.Pop(&amp;kl.heap)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> kl.heap[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> intHeap []<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h intHeap)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(h)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h intHeap)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h[i] &lt; h[j]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h intHeap)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\th[i], h[j] = h[j], h[i]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *intHeap)</span> <span class=\"title\">Push</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Push 使用 *h，是因为</span></span><br><span class=\"line\">\t<span class=\"comment\">// Push 增加了 h 的长度</span></span><br><span class=\"line\">\t*h = <span class=\"built_in\">append</span>(*h, x.(<span class=\"keyword\">int</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *intHeap)</span> <span class=\"title\">Pop</span><span class=\"params\">()</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Pop 使用 *h ，是因为</span></span><br><span class=\"line\">\t<span class=\"comment\">// Pop 减短了 h 的长度</span></span><br><span class=\"line\">\tres := (*h)[<span class=\"built_in\">len</span>(*h)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t*h = (*h)[:<span class=\"built_in\">len</span>(*h)<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"【剪枝】n皇后","date":"2020-02-09T16:00:00.000Z","_content":"\n\n\n## 题目\n\nn 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n\n\n上图为 8 皇后问题的一种解法。\n\n给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\n\n示例:\n\n```\n输入: 4\n输出: [\n [\".Q..\",  // 解法 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // 解法 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n解释: 4 皇后问题存在两个不同的解法。\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nunc solveNQueens(n int) [][]string {\n\tif n == 0 {\n\t\treturn [][]string{}\n\t}\n\n\tcols := make([]bool, n)\n\t// 记录 '\\' 方向的对角线的占用情况\n\td1 := make([]bool, 2*n)\n\t// 记录 '/' 方向的对角线的占用情况\n\td2 := make([]bool, 2*n)\n\n\tboard := make([]string, n)\n\n\tres := [][]string{}\n\n\tdfs(0, cols, d1, d2, board, &res)\n\n\treturn res\n}\n\nfunc dfs(r int, cols, d1, d2 []bool, board []string, res *[][]string) {\n\n\tif r == len(board) {\n\t\ttmp := make([]string, len(board))\n\t\tcopy(tmp, board)\n\t\t*res = append(*res, tmp)\n\t\treturn\n\t}\n\n\tn := len(board)\n\n\tfor c := 0; c < len(board); c++ {\n\t\t// 把棋盘想象成\n\t\t//   以左上角为坐标原点 [0,0]\n\t\t//   C 轴正方向向右\n\t\t//   R 轴正方向向下\n\t\t// 的坐标系。\n\t\t// 这样的话，每个格子就都有了自己的坐标值 [c,r]\n\t\t//\n\t\t// 对于 '\\' 方向的斜线而言\n\t\t//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r-c 的结果相同，\n\t\t//   不同斜线上 r-c 的结果不同。\n\t\t//   所以可以用 r-c 代表不同的 '\\' 方向的斜线的编号。\n\t\t//   但是 r-c 有可能是负值，无法作为切片的索引值\n\t\t//   所以 +n，可知 r-c+n >= 0\n\t\t//   所以，使用 r-c+n 作为 '\\' 方向斜线切片的索引值。\n\t\t// 对于 '/' 方向的斜线而言\n\t\t//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r+c 的结果相同，\n\t\t//   不同斜线上 r+c 的结果不同。\n\t\t//   所以可以用 r+c 代表不同的 '/' 方向的斜线的编号。\n\t\t//   所以，使用 r+c 作为 '/' 方向斜线切片的索引值。\n\t\tid1 := r - c + n\n\t\tid2 := r + c\n\t\tif !cols[c] && !d1[id1] && !d2[id2] {\n\t\t\tb := make([]byte, n)\n\t\t\tfor i := range b {\n\t\t\t\tb[i] = '.'\n\t\t\t}\n\t\t\tb[c] = 'Q'\n\t\t\tboard[r] = string(b)\n\t\t\t// 标记占用\n\t\t\tcols[c], d1[id1], d2[id2] = true, true, true\n\n\t\t\tdfs(r+1, cols, d1, d2, board, res)\n\n\t\t\t// 解除标记\n\t\t\tcols[c], d1[id1], d2[id2] = false, false, false\n\t\t}\n\t}\n}\n```\n\n\n\n### 解题思路\n\n","source":"_posts/刷题心得/剪枝/n皇后2.md","raw":"---\ntitle: 【剪枝】n皇后\ndate: 2020-02-10\ntags:\n- 算法\n- 剪枝\ncategories:\n- 刷题心得\n\n---\n\n\n\n## 题目\n\nn 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n\n\n上图为 8 皇后问题的一种解法。\n\n给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\n\n示例:\n\n```\n输入: 4\n输出: [\n [\".Q..\",  // 解法 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // 解法 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n解释: 4 皇后问题存在两个不同的解法。\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nunc solveNQueens(n int) [][]string {\n\tif n == 0 {\n\t\treturn [][]string{}\n\t}\n\n\tcols := make([]bool, n)\n\t// 记录 '\\' 方向的对角线的占用情况\n\td1 := make([]bool, 2*n)\n\t// 记录 '/' 方向的对角线的占用情况\n\td2 := make([]bool, 2*n)\n\n\tboard := make([]string, n)\n\n\tres := [][]string{}\n\n\tdfs(0, cols, d1, d2, board, &res)\n\n\treturn res\n}\n\nfunc dfs(r int, cols, d1, d2 []bool, board []string, res *[][]string) {\n\n\tif r == len(board) {\n\t\ttmp := make([]string, len(board))\n\t\tcopy(tmp, board)\n\t\t*res = append(*res, tmp)\n\t\treturn\n\t}\n\n\tn := len(board)\n\n\tfor c := 0; c < len(board); c++ {\n\t\t// 把棋盘想象成\n\t\t//   以左上角为坐标原点 [0,0]\n\t\t//   C 轴正方向向右\n\t\t//   R 轴正方向向下\n\t\t// 的坐标系。\n\t\t// 这样的话，每个格子就都有了自己的坐标值 [c,r]\n\t\t//\n\t\t// 对于 '\\' 方向的斜线而言\n\t\t//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r-c 的结果相同，\n\t\t//   不同斜线上 r-c 的结果不同。\n\t\t//   所以可以用 r-c 代表不同的 '\\' 方向的斜线的编号。\n\t\t//   但是 r-c 有可能是负值，无法作为切片的索引值\n\t\t//   所以 +n，可知 r-c+n >= 0\n\t\t//   所以，使用 r-c+n 作为 '\\' 方向斜线切片的索引值。\n\t\t// 对于 '/' 方向的斜线而言\n\t\t//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r+c 的结果相同，\n\t\t//   不同斜线上 r+c 的结果不同。\n\t\t//   所以可以用 r+c 代表不同的 '/' 方向的斜线的编号。\n\t\t//   所以，使用 r+c 作为 '/' 方向斜线切片的索引值。\n\t\tid1 := r - c + n\n\t\tid2 := r + c\n\t\tif !cols[c] && !d1[id1] && !d2[id2] {\n\t\t\tb := make([]byte, n)\n\t\t\tfor i := range b {\n\t\t\t\tb[i] = '.'\n\t\t\t}\n\t\t\tb[c] = 'Q'\n\t\t\tboard[r] = string(b)\n\t\t\t// 标记占用\n\t\t\tcols[c], d1[id1], d2[id2] = true, true, true\n\n\t\t\tdfs(r+1, cols, d1, d2, board, res)\n\n\t\t\t// 解除标记\n\t\t\tcols[c], d1[id1], d2[id2] = false, false, false\n\t\t}\n\t}\n}\n```\n\n\n\n### 解题思路\n\n","slug":"刷题心得/剪枝/n皇后2","published":1,"updated":"2020-02-12T03:44:35.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tty000smn8ncdd5d11g","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n<p>上图为 8 皇后问题的一种解法。</p>\n<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>\n<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 4</span><br><span class=\"line\">输出: [</span><br><span class=\"line\"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class=\"line\">  &quot;...Q&quot;,</span><br><span class=\"line\">  &quot;Q...&quot;,</span><br><span class=\"line\">  &quot;..Q.&quot;],</span><br><span class=\"line\"></span><br><span class=\"line\"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class=\"line\">  &quot;Q...&quot;,</span><br><span class=\"line\">  &quot;...Q&quot;,</span><br><span class=\"line\">  &quot;.Q..&quot;]</span><br><span class=\"line\">]</span><br><span class=\"line\">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unc solveNQueens(n <span class=\"keyword\">int</span>) [][]<span class=\"keyword\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> [][]<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcols := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, n)</span><br><span class=\"line\">\t<span class=\"comment\">// 记录 '\\' 方向的对角线的占用情况</span></span><br><span class=\"line\">\td1 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, <span class=\"number\">2</span>*n)</span><br><span class=\"line\">\t<span class=\"comment\">// 记录 '/' 方向的对角线的占用情况</span></span><br><span class=\"line\">\td2 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, <span class=\"number\">2</span>*n)</span><br><span class=\"line\"></span><br><span class=\"line\">\tboard := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, n)</span><br><span class=\"line\"></span><br><span class=\"line\">\tres := [][]<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdfs(<span class=\"number\">0</span>, cols, d1, d2, board, &amp;res)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(r <span class=\"keyword\">int</span>, cols, d1, d2 []<span class=\"keyword\">bool</span>, board []<span class=\"keyword\">string</span>, res *[][]<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r == <span class=\"built_in\">len</span>(board) &#123;</span><br><span class=\"line\">\t\ttmp := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"built_in\">len</span>(board))</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(tmp, board)</span><br><span class=\"line\">\t\t*res = <span class=\"built_in\">append</span>(*res, tmp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(board)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> c := <span class=\"number\">0</span>; c &lt; <span class=\"built_in\">len</span>(board); c++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 把棋盘想象成</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   以左上角为坐标原点 [0,0]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   C 轴正方向向右</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   R 轴正方向向下</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 的坐标系。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 这样的话，每个格子就都有了自己的坐标值 [c,r]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 对于 '\\' 方向的斜线而言</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r-c 的结果相同，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   不同斜线上 r-c 的结果不同。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以可以用 r-c 代表不同的 '\\' 方向的斜线的编号。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   但是 r-c 有可能是负值，无法作为切片的索引值</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以 +n，可知 r-c+n &gt;= 0</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以，使用 r-c+n 作为 '\\' 方向斜线切片的索引值。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 对于 '/' 方向的斜线而言</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r+c 的结果相同，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   不同斜线上 r+c 的结果不同。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以可以用 r+c 代表不同的 '/' 方向的斜线的编号。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以，使用 r+c 作为 '/' 方向斜线切片的索引值。</span></span><br><span class=\"line\">\t\tid1 := r - c + n</span><br><span class=\"line\">\t\tid2 := r + c</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2] &#123;</span><br><span class=\"line\">\t\t\tb := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> b &#123;</span><br><span class=\"line\">\t\t\t\tb[i] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tb[c] = <span class=\"string\">'Q'</span></span><br><span class=\"line\">\t\t\tboard[r] = <span class=\"keyword\">string</span>(b)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 标记占用</span></span><br><span class=\"line\">\t\t\tcols[c], d1[id1], d2[id2] = <span class=\"literal\">true</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tdfs(r+<span class=\"number\">1</span>, cols, d1, d2, board, res)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 解除标记</span></span><br><span class=\"line\">\t\t\tcols[c], d1[id1], d2[id2] = <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n<p>上图为 8 皇后问题的一种解法。</p>\n<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>\n<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>\n<p>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 4</span><br><span class=\"line\">输出: [</span><br><span class=\"line\"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class=\"line\">  &quot;...Q&quot;,</span><br><span class=\"line\">  &quot;Q...&quot;,</span><br><span class=\"line\">  &quot;..Q.&quot;],</span><br><span class=\"line\"></span><br><span class=\"line\"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class=\"line\">  &quot;Q...&quot;,</span><br><span class=\"line\">  &quot;...Q&quot;,</span><br><span class=\"line\">  &quot;.Q..&quot;]</span><br><span class=\"line\">]</span><br><span class=\"line\">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unc solveNQueens(n <span class=\"keyword\">int</span>) [][]<span class=\"keyword\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> [][]<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcols := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, n)</span><br><span class=\"line\">\t<span class=\"comment\">// 记录 '\\' 方向的对角线的占用情况</span></span><br><span class=\"line\">\td1 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, <span class=\"number\">2</span>*n)</span><br><span class=\"line\">\t<span class=\"comment\">// 记录 '/' 方向的对角线的占用情况</span></span><br><span class=\"line\">\td2 := <span class=\"built_in\">make</span>([]<span class=\"keyword\">bool</span>, <span class=\"number\">2</span>*n)</span><br><span class=\"line\"></span><br><span class=\"line\">\tboard := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, n)</span><br><span class=\"line\"></span><br><span class=\"line\">\tres := [][]<span class=\"keyword\">string</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tdfs(<span class=\"number\">0</span>, cols, d1, d2, board, &amp;res)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(r <span class=\"keyword\">int</span>, cols, d1, d2 []<span class=\"keyword\">bool</span>, board []<span class=\"keyword\">string</span>, res *[][]<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> r == <span class=\"built_in\">len</span>(board) &#123;</span><br><span class=\"line\">\t\ttmp := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"built_in\">len</span>(board))</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(tmp, board)</span><br><span class=\"line\">\t\t*res = <span class=\"built_in\">append</span>(*res, tmp)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tn := <span class=\"built_in\">len</span>(board)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> c := <span class=\"number\">0</span>; c &lt; <span class=\"built_in\">len</span>(board); c++ &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 把棋盘想象成</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   以左上角为坐标原点 [0,0]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   C 轴正方向向右</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   R 轴正方向向下</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 的坐标系。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 这样的话，每个格子就都有了自己的坐标值 [c,r]</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 对于 '\\' 方向的斜线而言</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r-c 的结果相同，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   不同斜线上 r-c 的结果不同。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以可以用 r-c 代表不同的 '\\' 方向的斜线的编号。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   但是 r-c 有可能是负值，无法作为切片的索引值</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以 +n，可知 r-c+n &gt;= 0</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以，使用 r-c+n 作为 '\\' 方向斜线切片的索引值。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 对于 '/' 方向的斜线而言</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   同一个斜线上的格子，利用其坐标 [c,r] 计算 r+c 的结果相同，</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   不同斜线上 r+c 的结果不同。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以可以用 r+c 代表不同的 '/' 方向的斜线的编号。</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//   所以，使用 r+c 作为 '/' 方向斜线切片的索引值。</span></span><br><span class=\"line\">\t\tid1 := r - c + n</span><br><span class=\"line\">\t\tid2 := r + c</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !cols[c] &amp;&amp; !d1[id1] &amp;&amp; !d2[id2] &#123;</span><br><span class=\"line\">\t\t\tb := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> b &#123;</span><br><span class=\"line\">\t\t\t\tb[i] = <span class=\"string\">'.'</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tb[c] = <span class=\"string\">'Q'</span></span><br><span class=\"line\">\t\t\tboard[r] = <span class=\"keyword\">string</span>(b)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 标记占用</span></span><br><span class=\"line\">\t\t\tcols[c], d1[id1], d2[id2] = <span class=\"literal\">true</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tdfs(r+<span class=\"number\">1</span>, cols, d1, d2, board, res)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 解除标记</span></span><br><span class=\"line\">\t\t\tcols[c], d1[id1], d2[id2] = <span class=\"literal\">false</span>, <span class=\"literal\">false</span>, <span class=\"literal\">false</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3>"},{"ååtitle":"【树】二叉树的最大深度","date":"2020-02-09T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n\n```\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最大深度 3 。\n\n```\n\n## 代码\n\n``` go\nfunc maxDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\n\treturn 1 + max(maxDepth(root.Left), maxDepth(root.Right))\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n```\n\n\n\n","source":"_posts/刷题心得/树/二叉树的最大深度.md","raw":"---\nååtitle: 【树】二叉树的最大深度\ndate: 2020-02-10\ntags:\n- 算法\n- 树\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n\n```\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最大深度 3 。\n\n```\n\n## 代码\n\n``` go\nfunc maxDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\n\treturn 1 + max(maxDepth(root.Left), maxDepth(root.Right))\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n```\n\n\n\n","slug":"刷题心得/树/二叉树的最大深度","published":1,"updated":"2020-02-10T03:30:30.218Z","title":"刷题心得/树/二叉树的最大深度","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2ttz000vmn8nhbz79ydz","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p>说明: 叶子节点是指没有子节点的节点。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class=\"line\"></span><br><span class=\"line\">    3</span><br><span class=\"line\"></span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxDepth</span><span class=\"params\">(root *TreeNode)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span> + max(maxDepth(root.Left), maxDepth(root.Right))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(a, b <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a &gt; b &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p>说明: 叶子节点是指没有子节点的节点。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class=\"line\"></span><br><span class=\"line\">    3</span><br><span class=\"line\"></span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxDepth</span><span class=\"params\">(root *TreeNode)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span> + max(maxDepth(root.Left), maxDepth(root.Right))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(a, b <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a &gt; b &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"【栈和队列】用栈实现队列","date":"2020-02-04T16:00:00.000Z","_content":"\n\n\n## 题目\n\n使用栈实现队列的下列操作：\n\npush(x) -- 将一个元素放入队列的尾部。\npop() -- 从队列首部移除元素。\npeek() -- 返回队列首部的元素。\nempty() -- 返回队列是否为空。\n示例:\n\n```\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);  \nqueue.peek();  // 返回 1\nqueue.pop();   // 返回 1\nqueue.empty(); // 返回 false\n```\n\n说明:\n\n你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\n\n\n\n## 代码\n\n``` go\n\n\ntype MyQueue struct {\n    arr []int\n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n    return MyQueue{}\n}\n\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int)  {\n    if this.arr == nil {\n        this.arr = make([]int, 0)\n    }\n    this.arr = append(this.arr, x)\n}\n\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n    if this.arr == nil {\n        this.arr = make([]int, 0)\n        return 0\n    }\n    if len(this.arr) <= 0 {\n        return 0\n    }\n    a := this.arr[0]\n    this.arr = this.arr[1:]\n    return a\n}\n\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n    if this.arr == nil {\n        this.arr = make([]int, 0)\n        return 0\n    }\n    if len(this.arr) <= 0 {\n        return 0\n    }\n    return this.arr[0]\n}\n\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n    if this.arr == nil || len(this.arr) <= 0 {\n        return true\n    }\n    return false\n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */\n\n```\n\n\n\n","source":"_posts/刷题心得/栈和队列/用栈实现队列.md","raw":"---\ntitle: 【栈和队列】用栈实现队列\ndate: 2020-02-05\ntags:\n- 算法\n- 栈\ncategories:\n- 刷题心得\n\n---\n\n\n\n## 题目\n\n使用栈实现队列的下列操作：\n\npush(x) -- 将一个元素放入队列的尾部。\npop() -- 从队列首部移除元素。\npeek() -- 返回队列首部的元素。\nempty() -- 返回队列是否为空。\n示例:\n\n```\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);  \nqueue.peek();  // 返回 1\nqueue.pop();   // 返回 1\nqueue.empty(); // 返回 false\n```\n\n说明:\n\n你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\n\n\n\n## 代码\n\n``` go\n\n\ntype MyQueue struct {\n    arr []int\n}\n\n\n/** Initialize your data structure here. */\nfunc Constructor() MyQueue {\n    return MyQueue{}\n}\n\n\n/** Push element x to the back of queue. */\nfunc (this *MyQueue) Push(x int)  {\n    if this.arr == nil {\n        this.arr = make([]int, 0)\n    }\n    this.arr = append(this.arr, x)\n}\n\n\n/** Removes the element from in front of queue and returns that element. */\nfunc (this *MyQueue) Pop() int {\n    if this.arr == nil {\n        this.arr = make([]int, 0)\n        return 0\n    }\n    if len(this.arr) <= 0 {\n        return 0\n    }\n    a := this.arr[0]\n    this.arr = this.arr[1:]\n    return a\n}\n\n\n/** Get the front element. */\nfunc (this *MyQueue) Peek() int {\n    if this.arr == nil {\n        this.arr = make([]int, 0)\n        return 0\n    }\n    if len(this.arr) <= 0 {\n        return 0\n    }\n    return this.arr[0]\n}\n\n\n/** Returns whether the queue is empty. */\nfunc (this *MyQueue) Empty() bool {\n    if this.arr == nil || len(this.arr) <= 0 {\n        return true\n    }\n    return false\n}\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * obj := Constructor();\n * obj.Push(x);\n * param_2 := obj.Pop();\n * param_3 := obj.Peek();\n * param_4 := obj.Empty();\n */\n\n```\n\n\n\n","slug":"刷题心得/栈和队列/用栈实现队列","published":1,"updated":"2020-02-05T02:58:33.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tu0000zmn8n4gxyg6z1","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>使用栈实现队列的下列操作：</p>\n<p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。<br>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyQueue queue &#x3D; new MyQueue();</span><br><span class=\"line\"></span><br><span class=\"line\">queue.push(1);</span><br><span class=\"line\">queue.push(2);  </span><br><span class=\"line\">queue.peek();  &#x2F;&#x2F; 返回 1</span><br><span class=\"line\">queue.pop();   &#x2F;&#x2F; 返回 1</span><br><span class=\"line\">queue.empty(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>\n\n<p>说明:</p>\n<p>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    arr []<span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">()</span> <span class=\"title\">MyQueue</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyQueue&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span> <span class=\"title\">Push</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.arr == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        this.arr = <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.arr = <span class=\"built_in\">append</span>(this.arr, x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span> <span class=\"title\">Pop</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.arr == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        this.arr = <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.arr) &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a := this.arr[<span class=\"number\">0</span>]</span><br><span class=\"line\">    this.arr = this.arr[<span class=\"number\">1</span>:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span> <span class=\"title\">Peek</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.arr == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        this.arr = <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.arr) &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.arr[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span> <span class=\"title\">Empty</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.arr == <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(this.arr) &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * obj := Constructor();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.Push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_2 := obj.Pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_3 := obj.Peek();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_4 := obj.Empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>使用栈实现队列的下列操作：</p>\n<p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。<br>示例:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyQueue queue &#x3D; new MyQueue();</span><br><span class=\"line\"></span><br><span class=\"line\">queue.push(1);</span><br><span class=\"line\">queue.push(2);  </span><br><span class=\"line\">queue.peek();  &#x2F;&#x2F; 返回 1</span><br><span class=\"line\">queue.pop();   &#x2F;&#x2F; 返回 1</span><br><span class=\"line\">queue.empty(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>\n\n<p>说明:</p>\n<p>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    arr []<span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">()</span> <span class=\"title\">MyQueue</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyQueue&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span> <span class=\"title\">Push</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.arr == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        this.arr = <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.arr = <span class=\"built_in\">append</span>(this.arr, x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span> <span class=\"title\">Pop</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.arr == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        this.arr = <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.arr) &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a := this.arr[<span class=\"number\">0</span>]</span><br><span class=\"line\">    this.arr = this.arr[<span class=\"number\">1</span>:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span> <span class=\"title\">Peek</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.arr == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        this.arr = <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(this.arr) &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.arr[<span class=\"number\">0</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyQueue)</span> <span class=\"title\">Empty</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.arr == <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(this.arr) &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * obj := Constructor();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.Push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_2 := obj.Pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_3 := obj.Peek();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_4 := obj.Empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n\n\n"},{"ååtitle":"【树】验证二叉搜索树","date":"2020-02-07T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\n### 示例 1:\n\n输入:\n\n```\n    2\n   / \\\n  1   3\n输出: true\n```\n\n\n\n### 示例 2:\n\n```\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc isValidBST(root *TreeNode) bool {\n  MIN, MAX := -1<<63, 1<<63-1\n  return recur(root, MIN, MAX)\n}\nfunc recur(root *TreeNode, min,max int) bool {\n  if root == nil {\n    return false\n  }\n  return root.Val > min && root.Val < max &&\n  recur(root.left, min, root.Val) \n  && recur(root.right, root.Val, max)\n}\n```\n\n### 思路\n\n1. 对树进行中序排列 如果最后数组是升序的，即二叉搜索树\n2. 递归的判断树的子节点是不是满足大小范围条件\n\n","source":"_posts/刷题心得/树/验证二叉搜索树.md","raw":"---\nååtitle: 【树】验证二叉搜索树\ndate: 2020-02-08\ntags:\n- 算法\n- 树\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\n### 示例 1:\n\n输入:\n\n```\n    2\n   / \\\n  1   3\n输出: true\n```\n\n\n\n### 示例 2:\n\n```\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc isValidBST(root *TreeNode) bool {\n  MIN, MAX := -1<<63, 1<<63-1\n  return recur(root, MIN, MAX)\n}\nfunc recur(root *TreeNode, min,max int) bool {\n  if root == nil {\n    return false\n  }\n  return root.Val > min && root.Val < max &&\n  recur(root.left, min, root.Val) \n  && recur(root.right, root.Val, max)\n}\n```\n\n### 思路\n\n1. 对树进行中序排列 如果最后数组是升序的，即二叉搜索树\n2. 递归的判断树的子节点是不是满足大小范围条件\n\n","slug":"刷题心得/树/验证二叉搜索树","published":1,"updated":"2020-02-08T04:24:12.558Z","title":"刷题心得/树/验证二叉搜索树","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tu10012mn8n62k3bnj7","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<p>假设一个二叉搜索树具有如下特征：</p>\n<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例 1:\"></a>示例 1:</h3><p>输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    2</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  1   3</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例 2:\"></a>示例 2:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  1   4</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    3   6</span><br><span class=\"line\">输出: false</span><br><span class=\"line\">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class=\"line\">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  MIN, MAX := <span class=\"number\">-1</span>&lt;&lt;<span class=\"number\">63</span>, <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">63</span><span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> recur(root, MIN, MAX)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recur</span><span class=\"params\">(root *TreeNode, min,max <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root.Val &gt; min &amp;&amp; root.Val &lt; max &amp;&amp;</span><br><span class=\"line\">  recur(root.left, min, root.Val) </span><br><span class=\"line\">  &amp;&amp; recur(root.right, root.Val, max)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>对树进行中序排列 如果最后数组是升序的，即二叉搜索树</li>\n<li>递归的判断树的子节点是不是满足大小范围条件</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>\n<p>假设一个二叉搜索树具有如下特征：</p>\n<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例 1:\"></a>示例 1:</h3><p>输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    2</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  1   3</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例 2:\"></a>示例 2:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">    5</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  1   4</span><br><span class=\"line\">     &#x2F; \\</span><br><span class=\"line\">    3   6</span><br><span class=\"line\">输出: false</span><br><span class=\"line\">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class=\"line\">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  MIN, MAX := <span class=\"number\">-1</span>&lt;&lt;<span class=\"number\">63</span>, <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">63</span><span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> recur(root, MIN, MAX)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recur</span><span class=\"params\">(root *TreeNode, min,max <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root.Val &gt; min &amp;&amp; root.Val &lt; max &amp;&amp;</span><br><span class=\"line\">  recur(root.left, min, root.Val) </span><br><span class=\"line\">  &amp;&amp; recur(root.right, root.Val, max)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>对树进行中序排列 如果最后数组是升序的，即二叉搜索树</li>\n<li>递归的判断树的子节点是不是满足大小范围条件</li>\n</ol>\n"},{"title":"【贪心算法】买卖股票的最佳时期2","date":"2020-02-09T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例 1:\n\n```\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n```\n\n\n\n示例 2:\n\n```\n输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n```\n\n\n\n示例 3:\n\n```\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc maxProfit(prices []int) int {\n  profit := 0\n  for i, p := range prices {\n    if i + 1 >= len(prices) {\n      break\n    }\n    if p < prices[i+1] {\n      profit += prices[i+1] - p\n    }\n  }\n  return profit\n}\n```\n\n\n\n### 解题思路\n\n#### 暴力破解\n\n直接循环嵌套\n\n#### map\n\nhash存储每个有多少个元素\n\n#### 排序\n\n拍完序之后遍历个数\n\n#### 分治\n\n分成一半\n\n如果左边的众数等于右边众数的话，则返回该数\n\n否则则判断两个众数哪个更多","source":"_posts/刷题心得/贪心算法/买卖股票的最佳时机.md","raw":"---\ntitle: 【贪心算法】买卖股票的最佳时期2\ndate: 2020-02-10\ntags:\n- 算法\n- 贪心\ncategories:\n- 刷题心得\n\n\n\n---\n\n\n\n## 题目\n\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n示例 1:\n\n```\n输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n```\n\n\n\n示例 2:\n\n```\n输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n```\n\n\n\n示例 3:\n\n```\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc maxProfit(prices []int) int {\n  profit := 0\n  for i, p := range prices {\n    if i + 1 >= len(prices) {\n      break\n    }\n    if p < prices[i+1] {\n      profit += prices[i+1] - p\n    }\n  }\n  return profit\n}\n```\n\n\n\n### 解题思路\n\n#### 暴力破解\n\n直接循环嵌套\n\n#### map\n\nhash存储每个有多少个元素\n\n#### 排序\n\n拍完序之后遍历个数\n\n#### 分治\n\n分成一半\n\n如果左边的众数等于右边众数的话，则返回该数\n\n否则则判断两个众数哪个更多","slug":"刷题心得/贪心算法/买卖股票的最佳时机","published":1,"updated":"2020-02-12T02:14:55.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tu30016mn8n7vyx6jou","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [7,1,5,3,6,4]</span><br><span class=\"line\">输出: 7</span><br><span class=\"line\">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class=\"line\">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [1,2,3,4,5]</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class=\"line\">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class=\"line\">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 3:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [7,6,4,3,1]</span><br><span class=\"line\">输出: 0</span><br><span class=\"line\">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxProfit</span><span class=\"params\">(prices []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  profit := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i, p := <span class=\"keyword\">range</span> prices &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i + <span class=\"number\">1</span> &gt;= <span class=\"built_in\">len</span>(prices) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p &lt; prices[i+<span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">      profit += prices[i+<span class=\"number\">1</span>] - p</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> profit</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h4 id=\"暴力破解\"><a href=\"#暴力破解\" class=\"headerlink\" title=\"暴力破解\"></a>暴力破解</h4><p>直接循环嵌套</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>hash存储每个有多少个元素</p>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><p>拍完序之后遍历个数</p>\n<h4 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h4><p>分成一半</p>\n<p>如果左边的众数等于右边众数的话，则返回该数</p>\n<p>否则则判断两个众数哪个更多</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [7,1,5,3,6,4]</span><br><span class=\"line\">输出: 7</span><br><span class=\"line\">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class=\"line\">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [1,2,3,4,5]</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class=\"line\">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class=\"line\">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 3:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [7,6,4,3,1]</span><br><span class=\"line\">输出: 0</span><br><span class=\"line\">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxProfit</span><span class=\"params\">(prices []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  profit := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i, p := <span class=\"keyword\">range</span> prices &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i + <span class=\"number\">1</span> &gt;= <span class=\"built_in\">len</span>(prices) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p &lt; prices[i+<span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">      profit += prices[i+<span class=\"number\">1</span>] - p</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> profit</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h4 id=\"暴力破解\"><a href=\"#暴力破解\" class=\"headerlink\" title=\"暴力破解\"></a>暴力破解</h4><p>直接循环嵌套</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>hash存储每个有多少个元素</p>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><p>拍完序之后遍历个数</p>\n<h4 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h4><p>分成一半</p>\n<p>如果左边的众数等于右边众数的话，则返回该数</p>\n<p>否则则判断两个众数哪个更多</p>\n"},{"ååtitle":"【树】二叉树的最近公共祖先","date":"2020-02-07T16:00:00.000Z","_content":"\n\n\n## 题目\n\n \n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]\n\n示例 1:\n\n```\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出: 3\n解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\n```\n\n\n\n示例 2:\n\n```\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出: 5\n解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n\tif root == nil ||\n  \t\troot.Val == p ||\n  root.Val == q {\n    return root\n  }\n  l := lowestCommonAncestor(root.Left, p, q)\n  r := lowestCommonAncestor(root.Right, p, q)\n  if l != nil && r != nil {\n    return root\n  }\n  if l == nil {\n    return r\n  }\n  return l\n}\n\n```\n\n### 思路\n\n1. 对树进行中序排列 如果最后数组是升序的，即二叉搜索树\n2. 递归的判断树的子节点是不是满足大小范围条件\n\n","source":"_posts/刷题心得/树/二叉树的最近公共祖先.md","raw":"---\nååtitle: 【树】二叉树的最近公共祖先\ndate: 2020-02-08\ntags:\n- 算法\n- 树\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\n \n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]\n\n示例 1:\n\n```\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出: 3\n解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\n```\n\n\n\n示例 2:\n\n```\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出: 5\n解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n\tif root == nil ||\n  \t\troot.Val == p ||\n  root.Val == q {\n    return root\n  }\n  l := lowestCommonAncestor(root.Left, p, q)\n  r := lowestCommonAncestor(root.Right, p, q)\n  if l != nil && r != nil {\n    return root\n  }\n  if l == nil {\n    return r\n  }\n  return l\n}\n\n```\n\n### 思路\n\n1. 对树进行中序排列 如果最后数组是升序的，即二叉搜索树\n2. 递归的判断树的子节点是不是满足大小范围条件\n\n","slug":"刷题心得/树/二叉树的最近公共祖先","published":1,"updated":"2020-02-08T05:36:40.164Z","title":"刷题心得/树/二叉树的最近公共祖先","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tu30019mn8na5r03513","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class=\"line\">输出: 5</span><br><span class=\"line\">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(root, p, q *TreeNode)</span> *<span class=\"title\">TreeNode</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> ||</span><br><span class=\"line\">  \t\troot.Val == p ||</span><br><span class=\"line\">  root.Val == q &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  l := lowestCommonAncestor(root.Left, p, q)</span><br><span class=\"line\">  r := lowestCommonAncestor(root.Right, p, q)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> l != <span class=\"literal\">nil</span> &amp;&amp; r != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> l == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>对树进行中序排列 如果最后数组是升序的，即二叉搜索树</li>\n<li>递归的判断树的子节点是不是满足大小范围条件</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class=\"line\">输出: 5</span><br><span class=\"line\">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(root, p, q *TreeNode)</span> *<span class=\"title\">TreeNode</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> ||</span><br><span class=\"line\">  \t\troot.Val == p ||</span><br><span class=\"line\">  root.Val == q &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  l := lowestCommonAncestor(root.Left, p, q)</span><br><span class=\"line\">  r := lowestCommonAncestor(root.Right, p, q)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> l != <span class=\"literal\">nil</span> &amp;&amp; r != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> l == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>对树进行中序排列 如果最后数组是升序的，即二叉搜索树</li>\n<li>递归的判断树的子节点是不是满足大小范围条件</li>\n</ol>\n"},{"title":"【字符串】最长无重复子串","date":"2020-02-04T16:00:00.000Z","_content":"\n## 题目\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n\n输入: \"pwwkew\"\n输出: 3\n\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n\n\n## 代码\n\n```go\nfunc lengthOfLongestSubstring(s string) int {\n  \t// 设置一个ascii 数组\n    locations := [256]int{}\n    // 设定初始值 -1\n    for i:=0; i< len(locations); i ++ {\n        locations[i] = -1\n    }\n  \t// 起始位置和最大值\n    start, max := 0,0\n    for i:=0; i<len(s); i++ {\n      \t// 如果上次重复的位置比当前的start要大， 重设起始位置\n        if locations[s[i]] >= start {\n            start = locations[s[i]] + 1\n          // 如果没有重复值， 更新最大值\n        } else if i + 1 - start > max {\n            max = i + 1 - start \n        }\n      \t// 记录该字符上次出现的位置\n        locations[s[i]] = i\n    }  \n    return max  \n}\n```\n\n","source":"_posts/刷题心得/字符串/最长无重复子串.md","raw":"---\ntitle: 【字符串】最长无重复子串\ndate: 2020-02-05\ntags:\n- 算法\n- 字符串\ncategories:\n- 刷题心得\n---\n\n## 题目\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n\n输入: \"pwwkew\"\n输出: 3\n\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n\n\n## 代码\n\n```go\nfunc lengthOfLongestSubstring(s string) int {\n  \t// 设置一个ascii 数组\n    locations := [256]int{}\n    // 设定初始值 -1\n    for i:=0; i< len(locations); i ++ {\n        locations[i] = -1\n    }\n  \t// 起始位置和最大值\n    start, max := 0,0\n    for i:=0; i<len(s); i++ {\n      \t// 如果上次重复的位置比当前的start要大， 重设起始位置\n        if locations[s[i]] >= start {\n            start = locations[s[i]] + 1\n          // 如果没有重复值， 更新最大值\n        } else if i + 1 - start > max {\n            max = i + 1 - start \n        }\n      \t// 记录该字符上次出现的位置\n        locations[s[i]] = i\n    }  \n    return max  \n}\n```\n\n","slug":"刷题心得/字符串/最长无重复子串","published":1,"updated":"2020-02-20T07:16:17.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tu4001cmn8ngntd57hf","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n<p>示例 1:</p>\n<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>\n<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>\n<p>输入: “pwwkew”<br>输出: 3</p>\n<p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 设置一个ascii 数组</span></span><br><span class=\"line\">    locations := [<span class=\"number\">256</span>]<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设定初始值 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(locations); i ++ &#123;</span><br><span class=\"line\">        locations[i] = <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"comment\">// 起始位置和最大值</span></span><br><span class=\"line\">    start, max := <span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 如果上次重复的位置比当前的start要大， 重设起始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> locations[s[i]] &gt;= start &#123;</span><br><span class=\"line\">            start = locations[s[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">          <span class=\"comment\">// 如果没有重复值， 更新最大值</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> i + <span class=\"number\">1</span> - start &gt; max &#123;</span><br><span class=\"line\">            max = i + <span class=\"number\">1</span> - start </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// 记录该字符上次出现的位置</span></span><br><span class=\"line\">        locations[s[i]] = i</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> max  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n<p>示例 1:</p>\n<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>\n<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>\n<p>输入: “pwwkew”<br>输出: 3</p>\n<p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 设置一个ascii 数组</span></span><br><span class=\"line\">    locations := [<span class=\"number\">256</span>]<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 设定初始值 -1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(locations); i ++ &#123;</span><br><span class=\"line\">        locations[i] = <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"comment\">// 起始位置和最大值</span></span><br><span class=\"line\">    start, max := <span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">// 如果上次重复的位置比当前的start要大， 重设起始位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> locations[s[i]] &gt;= start &#123;</span><br><span class=\"line\">            start = locations[s[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">          <span class=\"comment\">// 如果没有重复值， 更新最大值</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> i + <span class=\"number\">1</span> - start &gt; max &#123;</span><br><span class=\"line\">            max = i + <span class=\"number\">1</span> - start </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// 记录该字符上次出现的位置</span></span><br><span class=\"line\">        locations[s[i]] = i</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> max  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"ååtitle":"【树】二叉搜索树的最近公共祖先","date":"2020-02-07T16:00:00.000Z","_content":"\n\n\n## 题目\n\n \n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]\n\n### 示例 1:\n\n```\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n```\n\n\n\n### 示例 2:\n\n```\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n\treturn helper(root, p.Val, q.Val)\n}\n\nfunc helper(root *TreeNode, p, q int) *TreeNode {\n  r := root.Val\n  if p < r && q < r {\n    return helper(root.Left, p, q)\n  } else if p > r && q > r {\n    return helper(root.Right, p, q)\n  }\n  return root\n}\n```\n\n### 思路\n\n1. 对树进行中序排列 如果最后数组是升序的，即二叉搜索树\n2. 递归的判断树的子节点是不是满足大小范围条件\n\n","source":"_posts/刷题心得/树/二叉搜索树的最近公共祖先.md","raw":"---\nååtitle: 【树】二叉搜索树的最近公共祖先\ndate: 2020-02-08\ntags:\n- 算法\n- 树\ncategories:\n- 刷题心得\n---\n\n\n\n## 题目\n\n \n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]\n\n### 示例 1:\n\n```\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n```\n\n\n\n### 示例 2:\n\n```\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n\treturn helper(root, p.Val, q.Val)\n}\n\nfunc helper(root *TreeNode, p, q int) *TreeNode {\n  r := root.Val\n  if p < r && q < r {\n    return helper(root.Left, p, q)\n  } else if p > r && q > r {\n    return helper(root.Right, p, q)\n  }\n  return root\n}\n```\n\n### 思路\n\n1. 对树进行中序排列 如果最后数组是升序的，即二叉搜索树\n2. 递归的判断树的子节点是不是满足大小范围条件\n\n","slug":"刷题心得/树/二叉搜索树的最近公共祖先","published":1,"updated":"2020-02-08T04:24:07.845Z","title":"刷题心得/树/二叉搜索树的最近公共祖先","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tu5001gmn8nejeeeeqm","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例 1:\"></a>示例 1:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class=\"line\">输出: 6 </span><br><span class=\"line\">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例 2:\"></a>示例 2:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(root, p, q *TreeNode)</span> *<span class=\"title\">TreeNode</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> helper(root, p.Val, q.Val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">helper</span><span class=\"params\">(root *TreeNode, p, q <span class=\"keyword\">int</span>)</span> *<span class=\"title\">TreeNode</span></span> &#123;</span><br><span class=\"line\">  r := root.Val</span><br><span class=\"line\">  <span class=\"keyword\">if</span> p &lt; r &amp;&amp; q &lt; r &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(root.Left, p, q)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> p &gt; r &amp;&amp; q &gt; r &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(root.Right, p, q)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>对树进行中序排列 如果最后数组是升序的，即二叉搜索树</li>\n<li>递归的判断树的子节点是不是满足大小范围条件</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>\n<h3 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例 1:\"></a>示例 1:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class=\"line\">输出: 6 </span><br><span class=\"line\">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例 2:\"></a>示例 2:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(root, p, q *TreeNode)</span> *<span class=\"title\">TreeNode</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> helper(root, p.Val, q.Val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">helper</span><span class=\"params\">(root *TreeNode, p, q <span class=\"keyword\">int</span>)</span> *<span class=\"title\">TreeNode</span></span> &#123;</span><br><span class=\"line\">  r := root.Val</span><br><span class=\"line\">  <span class=\"keyword\">if</span> p &lt; r &amp;&amp; q &lt; r &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(root.Left, p, q)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> p &gt; r &amp;&amp; q &gt; r &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper(root.Right, p, q)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> root</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>对树进行中序排列 如果最后数组是升序的，即二叉搜索树</li>\n<li>递归的判断树的子节点是不是满足大小范围条件</li>\n</ol>\n"},{"title":"【递归分治】括号生成","date":"2020-02-09T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\n\n例如，给出 n = 3，生成结果为：\n\n```\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n\n\n```\n\n\n\n## 代码\n\n``` go\nfunc generateParenthesis(n int) []string {\n  res := make([]string, 0, n*n)\n  bytes := make([]byte, 2*n)\n  dfs(n, n, 0, bytes, &res)\n  return res\n}\nfunc dfs(left, right, idx int, bytes []byte, res *[]string) {\n  if left == 0 && right == 0 {\n    *res = append(*res, string(bytes))\n    return \n  }\n  if left > 0 {\n    bytes[idx] = '('\n    dfs(left - 1, right, idx + 1, bytes, res)\n  }\n  if right >0 && right < left {\n    bytes[idx] = ')'\n    dfs(left, right-1, idx+1, bytes, res)\n  }\n}\n```\n\n``` go\nfunc generateParenthesis(n int) []string {\n\tres := make([]string, 0, n*n)\n\tbytes := make([]byte, n*2)\n\tdfs(n, n, 0, bytes, &res)\n\treturn res\n}\n\nfunc dfs(left, right, idx int, bytes []byte, res *[]string) {\n\t// 所有符号都添加完毕\n\tif left == 0 && right == 0 {\n\t\t*res = append(*res, string(bytes))\n\t\treturn\n\t}\n\n\t// \"(\" 不用担心匹配问题，\n\t// 只要 left > 0 就可以直接添加\n\tif left > 0 {\n\t\tbytes[idx] = '('\n\t\tdfs(left-1, right, idx+1, bytes, res)\n\t}\n\n\t// 想要添加 \")\" 时\n\t// 需要 left < right，\n\t// 即在 bytes[:idx] 至少有一个 \"(\" 可以与 这个 \")\" 匹配\n\tif right > 0 && left < right {\n\t\tbytes[idx] = ')'\n\t\tdfs(left, right-1, idx+1, bytes, res)\n\t}\n}\n```\n\n\n\n","source":"_posts/刷题心得/递归分治/括号生成.md","raw":"---\ntitle: 【递归分治】括号生成\ndate: 2020-02-10\ntags:\n- 算法\n- 递归\ncategories:\n- 刷题心得\n\n---\n\n\n\n## 题目\n\n给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\n\n例如，给出 n = 3，生成结果为：\n\n```\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n\n\n```\n\n\n\n## 代码\n\n``` go\nfunc generateParenthesis(n int) []string {\n  res := make([]string, 0, n*n)\n  bytes := make([]byte, 2*n)\n  dfs(n, n, 0, bytes, &res)\n  return res\n}\nfunc dfs(left, right, idx int, bytes []byte, res *[]string) {\n  if left == 0 && right == 0 {\n    *res = append(*res, string(bytes))\n    return \n  }\n  if left > 0 {\n    bytes[idx] = '('\n    dfs(left - 1, right, idx + 1, bytes, res)\n  }\n  if right >0 && right < left {\n    bytes[idx] = ')'\n    dfs(left, right-1, idx+1, bytes, res)\n  }\n}\n```\n\n``` go\nfunc generateParenthesis(n int) []string {\n\tres := make([]string, 0, n*n)\n\tbytes := make([]byte, n*2)\n\tdfs(n, n, 0, bytes, &res)\n\treturn res\n}\n\nfunc dfs(left, right, idx int, bytes []byte, res *[]string) {\n\t// 所有符号都添加完毕\n\tif left == 0 && right == 0 {\n\t\t*res = append(*res, string(bytes))\n\t\treturn\n\t}\n\n\t// \"(\" 不用担心匹配问题，\n\t// 只要 left > 0 就可以直接添加\n\tif left > 0 {\n\t\tbytes[idx] = '('\n\t\tdfs(left-1, right, idx+1, bytes, res)\n\t}\n\n\t// 想要添加 \")\" 时\n\t// 需要 left < right，\n\t// 即在 bytes[:idx] 至少有一个 \"(\" 可以与 这个 \")\" 匹配\n\tif right > 0 && left < right {\n\t\tbytes[idx] = ')'\n\t\tdfs(left, right-1, idx+1, bytes, res)\n\t}\n}\n```\n\n\n\n","slug":"刷题心得/递归分治/括号生成","published":1,"updated":"2020-02-12T02:15:05.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tu6001jmn8n1no525io","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>\n<p>例如，给出 n = 3，生成结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &quot;((()))&quot;,</span><br><span class=\"line\">  &quot;(()())&quot;,</span><br><span class=\"line\">  &quot;(())()&quot;,</span><br><span class=\"line\">  &quot;()(())&quot;,</span><br><span class=\"line\">  &quot;()()()&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  res := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">0</span>, n*n)</span><br><span class=\"line\">  bytes := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">2</span>*n)</span><br><span class=\"line\">  dfs(n, n, <span class=\"number\">0</span>, bytes, &amp;res)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(left, right, idx <span class=\"keyword\">int</span>, bytes []<span class=\"keyword\">byte</span>, res *[]<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> left == <span class=\"number\">0</span> &amp;&amp; right == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    *res = <span class=\"built_in\">append</span>(*res, <span class=\"keyword\">string</span>(bytes))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> left &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    bytes[idx] = <span class=\"string\">'('</span></span><br><span class=\"line\">    dfs(left - <span class=\"number\">1</span>, right, idx + <span class=\"number\">1</span>, bytes, res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> right &gt;<span class=\"number\">0</span> &amp;&amp; right &lt; left &#123;</span><br><span class=\"line\">    bytes[idx] = <span class=\"string\">')'</span></span><br><span class=\"line\">    dfs(left, right<span class=\"number\">-1</span>, idx+<span class=\"number\">1</span>, bytes, res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tres := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">0</span>, n*n)</span><br><span class=\"line\">\tbytes := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n*<span class=\"number\">2</span>)</span><br><span class=\"line\">\tdfs(n, n, <span class=\"number\">0</span>, bytes, &amp;res)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(left, right, idx <span class=\"keyword\">int</span>, bytes []<span class=\"keyword\">byte</span>, res *[]<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 所有符号都添加完毕</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> left == <span class=\"number\">0</span> &amp;&amp; right == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t*res = <span class=\"built_in\">append</span>(*res, <span class=\"keyword\">string</span>(bytes))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// \"(\" 不用担心匹配问题，</span></span><br><span class=\"line\">\t<span class=\"comment\">// 只要 left &gt; 0 就可以直接添加</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> left &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tbytes[idx] = <span class=\"string\">'('</span></span><br><span class=\"line\">\t\tdfs(left<span class=\"number\">-1</span>, right, idx+<span class=\"number\">1</span>, bytes, res)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 想要添加 \")\" 时</span></span><br><span class=\"line\">\t<span class=\"comment\">// 需要 left &lt; right，</span></span><br><span class=\"line\">\t<span class=\"comment\">// 即在 bytes[:idx] 至少有一个 \"(\" 可以与 这个 \")\" 匹配</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> right &gt; <span class=\"number\">0</span> &amp;&amp; left &lt; right &#123;</span><br><span class=\"line\">\t\tbytes[idx] = <span class=\"string\">')'</span></span><br><span class=\"line\">\t\tdfs(left, right<span class=\"number\">-1</span>, idx+<span class=\"number\">1</span>, bytes, res)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>\n<p>例如，给出 n = 3，生成结果为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &quot;((()))&quot;,</span><br><span class=\"line\">  &quot;(()())&quot;,</span><br><span class=\"line\">  &quot;(())()&quot;,</span><br><span class=\"line\">  &quot;()(())&quot;,</span><br><span class=\"line\">  &quot;()()()&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  res := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">0</span>, n*n)</span><br><span class=\"line\">  bytes := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">2</span>*n)</span><br><span class=\"line\">  dfs(n, n, <span class=\"number\">0</span>, bytes, &amp;res)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(left, right, idx <span class=\"keyword\">int</span>, bytes []<span class=\"keyword\">byte</span>, res *[]<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> left == <span class=\"number\">0</span> &amp;&amp; right == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    *res = <span class=\"built_in\">append</span>(*res, <span class=\"keyword\">string</span>(bytes))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> left &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    bytes[idx] = <span class=\"string\">'('</span></span><br><span class=\"line\">    dfs(left - <span class=\"number\">1</span>, right, idx + <span class=\"number\">1</span>, bytes, res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> right &gt;<span class=\"number\">0</span> &amp;&amp; right &lt; left &#123;</span><br><span class=\"line\">    bytes[idx] = <span class=\"string\">')'</span></span><br><span class=\"line\">    dfs(left, right<span class=\"number\">-1</span>, idx+<span class=\"number\">1</span>, bytes, res)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateParenthesis</span><span class=\"params\">(n <span class=\"keyword\">int</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tres := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">0</span>, n*n)</span><br><span class=\"line\">\tbytes := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, n*<span class=\"number\">2</span>)</span><br><span class=\"line\">\tdfs(n, n, <span class=\"number\">0</span>, bytes, &amp;res)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(left, right, idx <span class=\"keyword\">int</span>, bytes []<span class=\"keyword\">byte</span>, res *[]<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 所有符号都添加完毕</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> left == <span class=\"number\">0</span> &amp;&amp; right == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t*res = <span class=\"built_in\">append</span>(*res, <span class=\"keyword\">string</span>(bytes))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// \"(\" 不用担心匹配问题，</span></span><br><span class=\"line\">\t<span class=\"comment\">// 只要 left &gt; 0 就可以直接添加</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> left &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tbytes[idx] = <span class=\"string\">'('</span></span><br><span class=\"line\">\t\tdfs(left<span class=\"number\">-1</span>, right, idx+<span class=\"number\">1</span>, bytes, res)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 想要添加 \")\" 时</span></span><br><span class=\"line\">\t<span class=\"comment\">// 需要 left &lt; right，</span></span><br><span class=\"line\">\t<span class=\"comment\">// 即在 bytes[:idx] 至少有一个 \"(\" 可以与 这个 \")\" 匹配</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> right &gt; <span class=\"number\">0</span> &amp;&amp; left &lt; right &#123;</span><br><span class=\"line\">\t\tbytes[idx] = <span class=\"string\">')'</span></span><br><span class=\"line\">\t\tdfs(left, right<span class=\"number\">-1</span>, idx+<span class=\"number\">1</span>, bytes, res)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"ååtitle":"【递归和分治】求众数","date":"2020-02-08T16:00:00.000Z","_content":"\n\n\n## 题目\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n示例 1:\n\n```\n输入: [3,2,3]\n输出: 3\n```\n\n\n\n示例 2:\n\n```\n输入: [2,2,1,1,1,2,2]\n输出: 2\n\n\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc majorityElement(nums []int) int {\n  x, t := nums[0], 1\n  for i := 1; i < len(nums); i++ {\n    switch {\n      case x == nums[i]:\n      \tt ++\n      case t > 0:\n      \tt --\n      default:\n      \tx = nums[i]\n      \tt = 1\n    }\n  }\n  return x\n}\n```\n\n\n\n### 解题思路\n\n#### 暴力破解\n\n直接循环嵌套\n\n#### map\n\nhash存储每个有多少个元素\n\n#### 排序\n\n拍完序之后遍历个数\n\n#### 分治\n\n分成一半\n\n如果左边的众数等于右边众数的话，则返回该数\n\n否则则判断两个众数哪个更多","source":"_posts/刷题心得/递归分治/求众数.md","raw":"---\nååtitle: 【递归和分治】求众数\ndate: 2020-02-09\ntags:\n- 算法\n- 分治\ncategories:\n- 刷题心得\n\n\n---\n\n\n\n## 题目\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n示例 1:\n\n```\n输入: [3,2,3]\n输出: 3\n```\n\n\n\n示例 2:\n\n```\n输入: [2,2,1,1,1,2,2]\n输出: 2\n\n\n```\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc majorityElement(nums []int) int {\n  x, t := nums[0], 1\n  for i := 1; i < len(nums); i++ {\n    switch {\n      case x == nums[i]:\n      \tt ++\n      case t > 0:\n      \tt --\n      default:\n      \tx = nums[i]\n      \tt = 1\n    }\n  }\n  return x\n}\n```\n\n\n\n### 解题思路\n\n#### 暴力破解\n\n直接循环嵌套\n\n#### map\n\nhash存储每个有多少个元素\n\n#### 排序\n\n拍完序之后遍历个数\n\n#### 分治\n\n分成一半\n\n如果左边的众数等于右边众数的话，则返回该数\n\n否则则判断两个众数哪个更多","slug":"刷题心得/递归分治/求众数","published":1,"updated":"2020-02-09T08:00:17.179Z","title":"刷题心得/递归分治/求众数","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tu7001nmn8n2il985wx","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [3,2,3]</span><br><span class=\"line\">输出: 3</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [2,2,1,1,1,2,2]</span><br><span class=\"line\">输出: 2</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">majorityElement</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  x, t := nums[<span class=\"number\">0</span>], <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> x == nums[i]:</span><br><span class=\"line\">      \tt ++</span><br><span class=\"line\">      <span class=\"keyword\">case</span> t &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">      \tt --</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      \tx = nums[i]</span><br><span class=\"line\">      \tt = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h4 id=\"暴力破解\"><a href=\"#暴力破解\" class=\"headerlink\" title=\"暴力破解\"></a>暴力破解</h4><p>直接循环嵌套</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>hash存储每个有多少个元素</p>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><p>拍完序之后遍历个数</p>\n<h4 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h4><p>分成一半</p>\n<p>如果左边的众数等于右边众数的话，则返回该数</p>\n<p>否则则判断两个众数哪个更多</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [3,2,3]</span><br><span class=\"line\">输出: 3</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [2,2,1,1,1,2,2]</span><br><span class=\"line\">输出: 2</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">majorityElement</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  x, t := nums[<span class=\"number\">0</span>], <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> x == nums[i]:</span><br><span class=\"line\">      \tt ++</span><br><span class=\"line\">      <span class=\"keyword\">case</span> t &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">      \tt --</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      \tx = nums[i]</span><br><span class=\"line\">      \tt = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><h4 id=\"暴力破解\"><a href=\"#暴力破解\" class=\"headerlink\" title=\"暴力破解\"></a>暴力破解</h4><p>直接循环嵌套</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>hash存储每个有多少个元素</p>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><p>拍完序之后遍历个数</p>\n<h4 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h4><p>分成一半</p>\n<p>如果左边的众数等于右边众数的话，则返回该数</p>\n<p>否则则判断两个众数哪个更多</p>\n"},{"title":"【面试复盘】头条面试","date":"2020-02-03T16:00:00.000Z","_content":"\n## 一面\n\n\n\n### 基础知识\n\n#### redis的雪崩、击穿、穿透\n\n#### zookeeper\n\n#### golang里的线程安全map\n\n```\nsync.map\n```\n\n#### redis cluster\n\n\n\n### 算法题\n\n#### 手动实现parseInt\n\n``` go\nfunc parseInt(s string) (i int, err error) {\n  // 去掉空格\n  // 判断为空\n  // 判断第一个字符是否是正负号\n  // 增加时判\n```\n\n\n\n## 二面\n\n\n\n### 业务\n\n\n\n### 算法题\n\n#### 最长无重复子串\n\n``` go\n\nfunc lengthOfLongestSubstring(s string) {\n  location := [256]int{}\n  for i:=range location {\n    location[i] = -1\n  }\n  left, maxLen := 0, 0\n  for i := 0; i< len(s); i++ {\n    if location[i] >= left {\n      left = location[s[i]] + 1\n      \n    } else if i + 1 - left > maxLen {\n      maxLen = i + 1 - left\n    }\n    location[s[i]] = i\n  }\n}\n```\n\n","source":"_posts/面试/复盘/2.13头条面试.md","raw":"---\ntitle: 【面试复盘】头条面试\ndate: 2020-02-04 \ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n## 一面\n\n\n\n### 基础知识\n\n#### redis的雪崩、击穿、穿透\n\n#### zookeeper\n\n#### golang里的线程安全map\n\n```\nsync.map\n```\n\n#### redis cluster\n\n\n\n### 算法题\n\n#### 手动实现parseInt\n\n``` go\nfunc parseInt(s string) (i int, err error) {\n  // 去掉空格\n  // 判断为空\n  // 判断第一个字符是否是正负号\n  // 增加时判\n```\n\n\n\n## 二面\n\n\n\n### 业务\n\n\n\n### 算法题\n\n#### 最长无重复子串\n\n``` go\n\nfunc lengthOfLongestSubstring(s string) {\n  location := [256]int{}\n  for i:=range location {\n    location[i] = -1\n  }\n  left, maxLen := 0, 0\n  for i := 0; i< len(s); i++ {\n    if location[i] >= left {\n      left = location[s[i]] + 1\n      \n    } else if i + 1 - left > maxLen {\n      maxLen = i + 1 - left\n    }\n    location[s[i]] = i\n  }\n}\n```\n\n","slug":"面试/复盘/2.13头条面试","published":1,"updated":"2020-03-26T03:23:38.143Z","_id":"ck71t2tu8001qmn8nc37x7v67","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><h4 id=\"redis的雪崩、击穿、穿透\"><a href=\"#redis的雪崩、击穿、穿透\" class=\"headerlink\" title=\"redis的雪崩、击穿、穿透\"></a>redis的雪崩、击穿、穿透</h4><h4 id=\"zookeeper\"><a href=\"#zookeeper\" class=\"headerlink\" title=\"zookeeper\"></a>zookeeper</h4><h4 id=\"golang里的线程安全map\"><a href=\"#golang里的线程安全map\" class=\"headerlink\" title=\"golang里的线程安全map\"></a>golang里的线程安全map</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync.map</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"redis-cluster\"><a href=\"#redis-cluster\" class=\"headerlink\" title=\"redis cluster\"></a>redis cluster</h4><h3 id=\"算法题\"><a href=\"#算法题\" class=\"headerlink\" title=\"算法题\"></a>算法题</h3><h4 id=\"手动实现parseInt\"><a href=\"#手动实现parseInt\" class=\"headerlink\" title=\"手动实现parseInt\"></a>手动实现parseInt</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parseInt</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(i <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 去掉空格</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断为空</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断第一个字符是否是正负号</span></span><br><span class=\"line\">  <span class=\"comment\">// 增加时判</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><h3 id=\"业务\"><a href=\"#业务\" class=\"headerlink\" title=\"业务\"></a>业务</h3><h3 id=\"算法题-1\"><a href=\"#算法题-1\" class=\"headerlink\" title=\"算法题\"></a>算法题</h3><h4 id=\"最长无重复子串\"><a href=\"#最长无重复子串\" class=\"headerlink\" title=\"最长无重复子串\"></a>最长无重复子串</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  location := [<span class=\"number\">256</span>]<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i:=<span class=\"keyword\">range</span> location &#123;</span><br><span class=\"line\">    location[i] = <span class=\"number\">-1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  left, maxLen := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> location[i] &gt;= left &#123;</span><br><span class=\"line\">      left = location[s[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> i + <span class=\"number\">1</span> - left &gt; maxLen &#123;</span><br><span class=\"line\">      maxLen = i + <span class=\"number\">1</span> - left</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location[s[i]] = i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><h4 id=\"redis的雪崩、击穿、穿透\"><a href=\"#redis的雪崩、击穿、穿透\" class=\"headerlink\" title=\"redis的雪崩、击穿、穿透\"></a>redis的雪崩、击穿、穿透</h4><h4 id=\"zookeeper\"><a href=\"#zookeeper\" class=\"headerlink\" title=\"zookeeper\"></a>zookeeper</h4><h4 id=\"golang里的线程安全map\"><a href=\"#golang里的线程安全map\" class=\"headerlink\" title=\"golang里的线程安全map\"></a>golang里的线程安全map</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync.map</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"redis-cluster\"><a href=\"#redis-cluster\" class=\"headerlink\" title=\"redis cluster\"></a>redis cluster</h4><h3 id=\"算法题\"><a href=\"#算法题\" class=\"headerlink\" title=\"算法题\"></a>算法题</h3><h4 id=\"手动实现parseInt\"><a href=\"#手动实现parseInt\" class=\"headerlink\" title=\"手动实现parseInt\"></a>手动实现parseInt</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parseInt</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"params\">(i <span class=\"keyword\">int</span>, err error)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 去掉空格</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断为空</span></span><br><span class=\"line\">  <span class=\"comment\">// 判断第一个字符是否是正负号</span></span><br><span class=\"line\">  <span class=\"comment\">// 增加时判</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><h3 id=\"业务\"><a href=\"#业务\" class=\"headerlink\" title=\"业务\"></a>业务</h3><h3 id=\"算法题-1\"><a href=\"#算法题-1\" class=\"headerlink\" title=\"算法题\"></a>算法题</h3><h4 id=\"最长无重复子串\"><a href=\"#最长无重复子串\" class=\"headerlink\" title=\"最长无重复子串\"></a>最长无重复子串</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">  location := [<span class=\"number\">256</span>]<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i:=<span class=\"keyword\">range</span> location &#123;</span><br><span class=\"line\">    location[i] = <span class=\"number\">-1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  left, maxLen := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> location[i] &gt;= left &#123;</span><br><span class=\"line\">      left = location[s[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> i + <span class=\"number\">1</span> - left &gt; maxLen &#123;</span><br><span class=\"line\">      maxLen = i + <span class=\"number\">1</span> - left</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location[s[i]] = i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【面试复盘】知乎面试","date":"2020-02-23T16:00:00.000Z","_content":"\n\n\n\n\n知乎这个岗位不合适，是做存储系统的。\n\n## 业务\n\n\n\n## 算法\n\n\n\n### 反转链表\n\n``` go\ntype ListNode struct {\n  Val int\n  Next *ListNode\n}\nfunc reverseListNode(root *ListNode) root {\n  if root == nil ||root.Next == nil {\n    return root\n  }\n  var prev *List\n  for root != nil {\n    prev, root, root.Next = root, root.Next, prev\n  }\n  return prev\n}\n```\n\n","source":"_posts/面试/复盘/2.24知乎面试.md","raw":"---\ntitle: 【面试复盘】知乎面试\ndate: 2020-02-24 \ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n\n\n知乎这个岗位不合适，是做存储系统的。\n\n## 业务\n\n\n\n## 算法\n\n\n\n### 反转链表\n\n``` go\ntype ListNode struct {\n  Val int\n  Next *ListNode\n}\nfunc reverseListNode(root *ListNode) root {\n  if root == nil ||root.Next == nil {\n    return root\n  }\n  var prev *List\n  for root != nil {\n    prev, root, root.Next = root, root.Next, prev\n  }\n  return prev\n}\n```\n\n","slug":"面试/复盘/2.24知乎面试","published":1,"updated":"2020-02-25T01:45:50.580Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tub001umn8ncxzjh4o8","content":"<p>知乎这个岗位不合适，是做存储系统的。</p>\n<h2 id=\"业务\"><a href=\"#业务\" class=\"headerlink\" title=\"业务\"></a>业务</h2><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ListNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Val <span class=\"keyword\">int</span></span><br><span class=\"line\">  Next *ListNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseListNode</span><span class=\"params\">(root *ListNode)</span> <span class=\"title\">root</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> ||root.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prev *List</span><br><span class=\"line\">  <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    prev, root, root.Next = root, root.Next, prev</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>知乎这个岗位不合适，是做存储系统的。</p>\n<h2 id=\"业务\"><a href=\"#业务\" class=\"headerlink\" title=\"业务\"></a>业务</h2><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ListNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Val <span class=\"keyword\">int</span></span><br><span class=\"line\">  Next *ListNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverseListNode</span><span class=\"params\">(root *ListNode)</span> <span class=\"title\">root</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> ||root.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prev *List</span><br><span class=\"line\">  <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    prev, root, root.Next = root, root.Next, prev</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【面试复盘】映客面试","date":"2020-02-23T16:00:00.000Z","_content":"\n\n\n## 算法\n\n\n\n### 树的前中后序遍历\n\n```go\n  2\n/   \\\n```\n\n\n\n### 判断链表中有环\n\n\n\n```go\n// 使用快慢链表\nfunc cycleExist(root *ListNode) bool {\n  \n}\n```\n\n\n\n### 爬楼梯 1\n\n``` go\n// 一次可以走一步或者两步 求到第n个楼梯的方法\n// 斐波那契数列\n```\n\n\n\n### 爬楼梯 2\n\n``` go\n// 一次可以走1-n步 求走到第n个楼梯的方法\n// 2的n-1次方\n\n```\n\n\n\n### 从左上角到右下角的方法\n\n``` go\n// ___________\n// |s| | | | |\n// ___________\n// | | | | | |\n// ___________\n// | | | | |e|\n// 从s点到e点有多少种方法\n\n```\n\n\n\n### top k个数\n\n``` go\n// 给定一个数组中的数 求前k个数\n// 方法一 暴力排序法\n// 方法二 中间容量为k的数组 用来存储 每次最小的出堆。最小堆\n// 方法三 每次选一个数将数组分为两个 \n```\n\n\n\n## 基础知识\n\n### mysql group by的用法\n\n``` sql\nselect value, count(*) from test group by value\n```\n\n\n\n### 索引的类型\n\n- 聚合索引\n- 普通索引\n- 唯一索引\n- 主键索引\n\n\n\n### 引擎\n\n#### 分类\n\n- myisam\n- innodb\n\n#### 区别\n\n- **innodb支持事务**\n- 获取总量的时候myisam比较快\n- innodb支持外键\n- 索引的数据结构不一样 innodb是 b+树 myisam是b树\n\n\n\n#### innodb为什么使用b + 树\n\n- 数据结构更精简\n\n#### 为什么不用红黑树\n\n- 二叉树 存储的数据量太少了 ，导致磁盘io次数增加\n- b+树可以范围查询\n\n\n\n### raft协议\n\n\n\n### redis\n\n#### redis的数据结构\n\n```\nstring\nlist\nhash\nset\nzset\n```\n\n#### redis怎么实现持久化的\n\n``` \nAOF 1s 日志 热存储\nRDB 快照 冷存储\n\n结合使用\n```\n\n\n\n#### zset怎么实现的\n\n``` \n使用字典和跳表实现的\n```\n\n\n\n### 消息队列\n\n\n\n### 为什么使用消息队列\n\n``` \n解耦\n\n异步\n\n削峰\n```\n\n","source":"_posts/面试/复盘/2.24映客面试.md","raw":"---\ntitle: 【面试复盘】映客面试\ndate: 2020-02-24 \ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n## 算法\n\n\n\n### 树的前中后序遍历\n\n```go\n  2\n/   \\\n```\n\n\n\n### 判断链表中有环\n\n\n\n```go\n// 使用快慢链表\nfunc cycleExist(root *ListNode) bool {\n  \n}\n```\n\n\n\n### 爬楼梯 1\n\n``` go\n// 一次可以走一步或者两步 求到第n个楼梯的方法\n// 斐波那契数列\n```\n\n\n\n### 爬楼梯 2\n\n``` go\n// 一次可以走1-n步 求走到第n个楼梯的方法\n// 2的n-1次方\n\n```\n\n\n\n### 从左上角到右下角的方法\n\n``` go\n// ___________\n// |s| | | | |\n// ___________\n// | | | | | |\n// ___________\n// | | | | |e|\n// 从s点到e点有多少种方法\n\n```\n\n\n\n### top k个数\n\n``` go\n// 给定一个数组中的数 求前k个数\n// 方法一 暴力排序法\n// 方法二 中间容量为k的数组 用来存储 每次最小的出堆。最小堆\n// 方法三 每次选一个数将数组分为两个 \n```\n\n\n\n## 基础知识\n\n### mysql group by的用法\n\n``` sql\nselect value, count(*) from test group by value\n```\n\n\n\n### 索引的类型\n\n- 聚合索引\n- 普通索引\n- 唯一索引\n- 主键索引\n\n\n\n### 引擎\n\n#### 分类\n\n- myisam\n- innodb\n\n#### 区别\n\n- **innodb支持事务**\n- 获取总量的时候myisam比较快\n- innodb支持外键\n- 索引的数据结构不一样 innodb是 b+树 myisam是b树\n\n\n\n#### innodb为什么使用b + 树\n\n- 数据结构更精简\n\n#### 为什么不用红黑树\n\n- 二叉树 存储的数据量太少了 ，导致磁盘io次数增加\n- b+树可以范围查询\n\n\n\n### raft协议\n\n\n\n### redis\n\n#### redis的数据结构\n\n```\nstring\nlist\nhash\nset\nzset\n```\n\n#### redis怎么实现持久化的\n\n``` \nAOF 1s 日志 热存储\nRDB 快照 冷存储\n\n结合使用\n```\n\n\n\n#### zset怎么实现的\n\n``` \n使用字典和跳表实现的\n```\n\n\n\n### 消息队列\n\n\n\n### 为什么使用消息队列\n\n``` \n解耦\n\n异步\n\n削峰\n```\n\n","slug":"面试/复盘/2.24映客面试","published":1,"updated":"2020-02-24T07:51:43.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tuc001xmn8ndpwccoxe","content":"<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"树的前中后序遍历\"><a href=\"#树的前中后序遍历\" class=\"headerlink\" title=\"树的前中后序遍历\"></a>树的前中后序遍历</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">2</span></span><br><span class=\"line\">/   \\</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"判断链表中有环\"><a href=\"#判断链表中有环\" class=\"headerlink\" title=\"判断链表中有环\"></a>判断链表中有环</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用快慢链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cycleExist</span><span class=\"params\">(root *ListNode)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"爬楼梯-1\"><a href=\"#爬楼梯-1\" class=\"headerlink\" title=\"爬楼梯 1\"></a>爬楼梯 1</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一次可以走一步或者两步 求到第n个楼梯的方法</span></span><br><span class=\"line\"><span class=\"comment\">// 斐波那契数列</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"爬楼梯-2\"><a href=\"#爬楼梯-2\" class=\"headerlink\" title=\"爬楼梯 2\"></a>爬楼梯 2</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一次可以走1-n步 求走到第n个楼梯的方法</span></span><br><span class=\"line\"><span class=\"comment\">// 2的n-1次方</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"从左上角到右下角的方法\"><a href=\"#从左上角到右下角的方法\" class=\"headerlink\" title=\"从左上角到右下角的方法\"></a>从左上角到右下角的方法</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ___________</span></span><br><span class=\"line\"><span class=\"comment\">// |s| | | | |</span></span><br><span class=\"line\"><span class=\"comment\">// ___________</span></span><br><span class=\"line\"><span class=\"comment\">// | | | | | |</span></span><br><span class=\"line\"><span class=\"comment\">// ___________</span></span><br><span class=\"line\"><span class=\"comment\">// | | | | |e|</span></span><br><span class=\"line\"><span class=\"comment\">// 从s点到e点有多少种方法</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"top-k个数\"><a href=\"#top-k个数\" class=\"headerlink\" title=\"top k个数\"></a>top k个数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给定一个数组中的数 求前k个数</span></span><br><span class=\"line\"><span class=\"comment\">// 方法一 暴力排序法</span></span><br><span class=\"line\"><span class=\"comment\">// 方法二 中间容量为k的数组 用来存储 每次最小的出堆。最小堆</span></span><br><span class=\"line\"><span class=\"comment\">// 方法三 每次选一个数将数组分为两个</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"mysql-group-by的用法\"><a href=\"#mysql-group-by的用法\" class=\"headerlink\" title=\"mysql group by的用法\"></a>mysql group by的用法</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">value</span>, <span class=\"keyword\">count</span>(*) <span class=\"keyword\">from</span> <span class=\"keyword\">test</span> <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">value</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"索引的类型\"><a href=\"#索引的类型\" class=\"headerlink\" title=\"索引的类型\"></a>索引的类型</h3><ul>\n<li>聚合索引</li>\n<li>普通索引</li>\n<li>唯一索引</li>\n<li>主键索引</li>\n</ul>\n<h3 id=\"引擎\"><a href=\"#引擎\" class=\"headerlink\" title=\"引擎\"></a>引擎</h3><h4 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h4><ul>\n<li>myisam</li>\n<li>innodb</li>\n</ul>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><ul>\n<li><strong>innodb支持事务</strong></li>\n<li>获取总量的时候myisam比较快</li>\n<li>innodb支持外键</li>\n<li>索引的数据结构不一样 innodb是 b+树 myisam是b树</li>\n</ul>\n<h4 id=\"innodb为什么使用b-树\"><a href=\"#innodb为什么使用b-树\" class=\"headerlink\" title=\"innodb为什么使用b + 树\"></a>innodb为什么使用b + 树</h4><ul>\n<li>数据结构更精简</li>\n</ul>\n<h4 id=\"为什么不用红黑树\"><a href=\"#为什么不用红黑树\" class=\"headerlink\" title=\"为什么不用红黑树\"></a>为什么不用红黑树</h4><ul>\n<li>二叉树 存储的数据量太少了 ，导致磁盘io次数增加</li>\n<li>b+树可以范围查询</li>\n</ul>\n<h3 id=\"raft协议\"><a href=\"#raft协议\" class=\"headerlink\" title=\"raft协议\"></a>raft协议</h3><h3 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h3><h4 id=\"redis的数据结构\"><a href=\"#redis的数据结构\" class=\"headerlink\" title=\"redis的数据结构\"></a>redis的数据结构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string</span><br><span class=\"line\">list</span><br><span class=\"line\">hash</span><br><span class=\"line\">set</span><br><span class=\"line\">zset</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"redis怎么实现持久化的\"><a href=\"#redis怎么实现持久化的\" class=\"headerlink\" title=\"redis怎么实现持久化的\"></a>redis怎么实现持久化的</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AOF 1s 日志 热存储</span><br><span class=\"line\">RDB 快照 冷存储</span><br><span class=\"line\"></span><br><span class=\"line\">结合使用</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"zset怎么实现的\"><a href=\"#zset怎么实现的\" class=\"headerlink\" title=\"zset怎么实现的\"></a>zset怎么实现的</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用字典和跳表实现的</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><h3 id=\"为什么使用消息队列\"><a href=\"#为什么使用消息队列\" class=\"headerlink\" title=\"为什么使用消息队列\"></a>为什么使用消息队列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解耦</span><br><span class=\"line\"></span><br><span class=\"line\">异步</span><br><span class=\"line\"></span><br><span class=\"line\">削峰</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"树的前中后序遍历\"><a href=\"#树的前中后序遍历\" class=\"headerlink\" title=\"树的前中后序遍历\"></a>树的前中后序遍历</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"number\">2</span></span><br><span class=\"line\">/   \\</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"判断链表中有环\"><a href=\"#判断链表中有环\" class=\"headerlink\" title=\"判断链表中有环\"></a>判断链表中有环</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用快慢链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cycleExist</span><span class=\"params\">(root *ListNode)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"爬楼梯-1\"><a href=\"#爬楼梯-1\" class=\"headerlink\" title=\"爬楼梯 1\"></a>爬楼梯 1</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一次可以走一步或者两步 求到第n个楼梯的方法</span></span><br><span class=\"line\"><span class=\"comment\">// 斐波那契数列</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"爬楼梯-2\"><a href=\"#爬楼梯-2\" class=\"headerlink\" title=\"爬楼梯 2\"></a>爬楼梯 2</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一次可以走1-n步 求走到第n个楼梯的方法</span></span><br><span class=\"line\"><span class=\"comment\">// 2的n-1次方</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"从左上角到右下角的方法\"><a href=\"#从左上角到右下角的方法\" class=\"headerlink\" title=\"从左上角到右下角的方法\"></a>从左上角到右下角的方法</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ___________</span></span><br><span class=\"line\"><span class=\"comment\">// |s| | | | |</span></span><br><span class=\"line\"><span class=\"comment\">// ___________</span></span><br><span class=\"line\"><span class=\"comment\">// | | | | | |</span></span><br><span class=\"line\"><span class=\"comment\">// ___________</span></span><br><span class=\"line\"><span class=\"comment\">// | | | | |e|</span></span><br><span class=\"line\"><span class=\"comment\">// 从s点到e点有多少种方法</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"top-k个数\"><a href=\"#top-k个数\" class=\"headerlink\" title=\"top k个数\"></a>top k个数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给定一个数组中的数 求前k个数</span></span><br><span class=\"line\"><span class=\"comment\">// 方法一 暴力排序法</span></span><br><span class=\"line\"><span class=\"comment\">// 方法二 中间容量为k的数组 用来存储 每次最小的出堆。最小堆</span></span><br><span class=\"line\"><span class=\"comment\">// 方法三 每次选一个数将数组分为两个</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"mysql-group-by的用法\"><a href=\"#mysql-group-by的用法\" class=\"headerlink\" title=\"mysql group by的用法\"></a>mysql group by的用法</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">value</span>, <span class=\"keyword\">count</span>(*) <span class=\"keyword\">from</span> <span class=\"keyword\">test</span> <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">value</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"索引的类型\"><a href=\"#索引的类型\" class=\"headerlink\" title=\"索引的类型\"></a>索引的类型</h3><ul>\n<li>聚合索引</li>\n<li>普通索引</li>\n<li>唯一索引</li>\n<li>主键索引</li>\n</ul>\n<h3 id=\"引擎\"><a href=\"#引擎\" class=\"headerlink\" title=\"引擎\"></a>引擎</h3><h4 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h4><ul>\n<li>myisam</li>\n<li>innodb</li>\n</ul>\n<h4 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h4><ul>\n<li><strong>innodb支持事务</strong></li>\n<li>获取总量的时候myisam比较快</li>\n<li>innodb支持外键</li>\n<li>索引的数据结构不一样 innodb是 b+树 myisam是b树</li>\n</ul>\n<h4 id=\"innodb为什么使用b-树\"><a href=\"#innodb为什么使用b-树\" class=\"headerlink\" title=\"innodb为什么使用b + 树\"></a>innodb为什么使用b + 树</h4><ul>\n<li>数据结构更精简</li>\n</ul>\n<h4 id=\"为什么不用红黑树\"><a href=\"#为什么不用红黑树\" class=\"headerlink\" title=\"为什么不用红黑树\"></a>为什么不用红黑树</h4><ul>\n<li>二叉树 存储的数据量太少了 ，导致磁盘io次数增加</li>\n<li>b+树可以范围查询</li>\n</ul>\n<h3 id=\"raft协议\"><a href=\"#raft协议\" class=\"headerlink\" title=\"raft协议\"></a>raft协议</h3><h3 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h3><h4 id=\"redis的数据结构\"><a href=\"#redis的数据结构\" class=\"headerlink\" title=\"redis的数据结构\"></a>redis的数据结构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string</span><br><span class=\"line\">list</span><br><span class=\"line\">hash</span><br><span class=\"line\">set</span><br><span class=\"line\">zset</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"redis怎么实现持久化的\"><a href=\"#redis怎么实现持久化的\" class=\"headerlink\" title=\"redis怎么实现持久化的\"></a>redis怎么实现持久化的</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AOF 1s 日志 热存储</span><br><span class=\"line\">RDB 快照 冷存储</span><br><span class=\"line\"></span><br><span class=\"line\">结合使用</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"zset怎么实现的\"><a href=\"#zset怎么实现的\" class=\"headerlink\" title=\"zset怎么实现的\"></a>zset怎么实现的</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用字典和跳表实现的</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><h3 id=\"为什么使用消息队列\"><a href=\"#为什么使用消息队列\" class=\"headerlink\" title=\"为什么使用消息队列\"></a>为什么使用消息队列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解耦</span><br><span class=\"line\"></span><br><span class=\"line\">异步</span><br><span class=\"line\"></span><br><span class=\"line\">削峰</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【递归和分治】x的n次方","date":"2020-02-08T16:00:00.000Z","_content":"\n\n\n## 题目\n\n 实现 pow(x, n) ，即计算 x 的 n 次幂函数。\n\n示例 1:\n\n```\n输入: 2.00000, 10\n输出: 1024.00000\n```\n\n\n\n示例 2:\n\n```\n输入: 2.10000, 3\n输出: 9.26100\n```\n\n\n\n示例 3:\n\n```\n输入: 2.00000, -2\n输出: 0.25000\n解释: 2-2 = 1/22 = 1/4 = 0.25\n```\n\n\n\n说明:\n\n-100.0 < x < 100.0\nn 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc myPow(x float64, n int) float64 {\n  if n < 0 {\n    return 1.0/pow(x, -n)\n  }\n  return pow(x, n)\n}\nfunc pow(x float64, n int) float64 {\n  if x == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  res := pow(x, n>>1)\n  if n & 1 == 0 {\n    return res * res\n  }\n  return res * res * x\n}\n```\n\n","source":"_posts/刷题心得/递归分治/求指数.md","raw":"---\ntitle: 【递归和分治】x的n次方\ndate: 2020-02-09\ntags:\n- 算法\n- 分治\ncategories:\n- 刷题心得\n\n---\n\n\n\n## 题目\n\n 实现 pow(x, n) ，即计算 x 的 n 次幂函数。\n\n示例 1:\n\n```\n输入: 2.00000, 10\n输出: 1024.00000\n```\n\n\n\n示例 2:\n\n```\n输入: 2.10000, 3\n输出: 9.26100\n```\n\n\n\n示例 3:\n\n```\n输入: 2.00000, -2\n输出: 0.25000\n解释: 2-2 = 1/22 = 1/4 = 0.25\n```\n\n\n\n说明:\n\n-100.0 < x < 100.0\nn 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。\n\n\n\n## 解题\n\n### 代码\n\n``` go\nfunc myPow(x float64, n int) float64 {\n  if n < 0 {\n    return 1.0/pow(x, -n)\n  }\n  return pow(x, n)\n}\nfunc pow(x float64, n int) float64 {\n  if x == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  res := pow(x, n>>1)\n  if n & 1 == 0 {\n    return res * res\n  }\n  return res * res * x\n}\n```\n\n","slug":"刷题心得/递归分治/求指数","published":1,"updated":"2020-02-12T02:15:00.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tue0021mn8nedsd9una","content":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p> 实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 2.00000, 10</span><br><span class=\"line\">输出: 1024.00000</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 2.10000, 3</span><br><span class=\"line\">输出: 9.26100</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 3:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 2.00000, -2</span><br><span class=\"line\">输出: 0.25000</span><br><span class=\"line\">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>\n\n\n\n<p>说明:</p>\n<p>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myPow</span><span class=\"params\">(x <span class=\"keyword\">float64</span>, n <span class=\"keyword\">int</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.0</span>/pow(x, -n)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pow(x, n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(x <span class=\"keyword\">float64</span>, n <span class=\"keyword\">int</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> x == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res := pow(x, n&gt;&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> n &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res * res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res * res * x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p> 实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 2.00000, 10</span><br><span class=\"line\">输出: 1024.00000</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 2.10000, 3</span><br><span class=\"line\">输出: 9.26100</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 3:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: 2.00000, -2</span><br><span class=\"line\">输出: 0.25000</span><br><span class=\"line\">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>\n\n\n\n<p>说明:</p>\n<p>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myPow</span><span class=\"params\">(x <span class=\"keyword\">float64</span>, n <span class=\"keyword\">int</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> n &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1.0</span>/pow(x, -n)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pow(x, n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(x <span class=\"keyword\">float64</span>, n <span class=\"keyword\">int</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> x == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  res := pow(x, n&gt;&gt;<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> n &amp; <span class=\"number\">1</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res * res</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res * res * x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【面试复盘】伴鱼面试","date":"2020-02-23T16:00:00.000Z","_content":"\n\n\n## 算法题\n\n\n\n``` go\n// 用一个 M×N 的矩阵表示一个未知星球的地表，0 表示该区域为海洋，1 表示该区域为陆地，每块陆地只可能与上、下、左、右相邻的四块陆地接壤，请找到这个星球上面积最大的岛屿。\n// 示例：\n// 输入：\n// [\n//   [1, 1, 0],\n//   [1, 0, 0],\n//   [0, 0, 1]\n// ]\n// 输出：3\n\nfunc maxArea(grid [][]int) int {\n  max := 0\n  for i:=0; i<len(grid); i++ {\n    for j:=0; j< len(grid[0]; j++) {\n      if grid[i][j] == 1 {\n        area := dfs(grid, i, j)\n        if area > max {\n          max = area\n        }\n      }\n    }\n  }\n  return max\n}\n\nfunc dfs(grid [][]int, x,y int) int {\n  if x < 0 || x >= len(grid) || y < 0 || y >= len(grid[0]) {\n    return 0\n  }\n  if grid[i][j] == 0 {\n    return 0\n  }\n  area := 1\n  grid[i][j] == 0\n  dx := [4]int{0,0,-1,1}\n  dy := [4]int{-1, 1, 0, 0}\n  for i := 0; i< 4; i++ {\n    area += dfs(grid, x+ dx[i], y + dy[i])\n  }\n  return area\n}\n```\n\n\n\n## 基础\n\n### Go 变量与函数同名\n\n\n\n\n\n### 有n个大文件，无法加载进内存， 里面内容是无序的，怎么把他们合并成一个有序的文件\n\n外排序\n\n### 建堆的过程\n\n```\n大顶堆：每个结点的值都大于或等于其左右孩子结点的值\n小顶堆：每个结点的值都小于或等于其左右孩子结点的值\n\n根据堆的特性来形成公式就是，节点为i的话\n大顶堆: arr[i]>=arr[2i+1] && arr[i]>=arr[2i+2]\n小顶堆：arr[i]<=arr[2i+1] && arr[i]<=arr[2i+2]\n```\n\n\n\n### 索引为什么不用b+树和平衡二叉树\n\n\n\n### 索引的节点 多大比较合适\n\n\n\n### 索引存什么样的格式比较合适\n\n树转数组\n\n\n\n### 操作系统 io的大小\n\n- 分页\n- 分段\n- 段页式\n\n\n\n### 操作系统32位和64位的区别\n\n\n\n### mysql执行事务的时候宕机了，恢复之后还能正常执行吗\n\n\n\n### 多个进程的时候，如果系统使用时间片轮转的方式 他们是用什么方式提醒下一个进程的，需要存储什么数据\n\n``` \n1. 使用中断\n2. 寄存器内的数据，当前任务的状态\n```\n\n\n\n### 更新数据库和缓存的时候怎么保证强一致性\n\n\n\n\n\n","source":"_posts/面试/复盘/2.24伴鱼面试.md","raw":"---\ntitle: 【面试复盘】伴鱼面试\ndate: 2020-02-24 \ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n## 算法题\n\n\n\n``` go\n// 用一个 M×N 的矩阵表示一个未知星球的地表，0 表示该区域为海洋，1 表示该区域为陆地，每块陆地只可能与上、下、左、右相邻的四块陆地接壤，请找到这个星球上面积最大的岛屿。\n// 示例：\n// 输入：\n// [\n//   [1, 1, 0],\n//   [1, 0, 0],\n//   [0, 0, 1]\n// ]\n// 输出：3\n\nfunc maxArea(grid [][]int) int {\n  max := 0\n  for i:=0; i<len(grid); i++ {\n    for j:=0; j< len(grid[0]; j++) {\n      if grid[i][j] == 1 {\n        area := dfs(grid, i, j)\n        if area > max {\n          max = area\n        }\n      }\n    }\n  }\n  return max\n}\n\nfunc dfs(grid [][]int, x,y int) int {\n  if x < 0 || x >= len(grid) || y < 0 || y >= len(grid[0]) {\n    return 0\n  }\n  if grid[i][j] == 0 {\n    return 0\n  }\n  area := 1\n  grid[i][j] == 0\n  dx := [4]int{0,0,-1,1}\n  dy := [4]int{-1, 1, 0, 0}\n  for i := 0; i< 4; i++ {\n    area += dfs(grid, x+ dx[i], y + dy[i])\n  }\n  return area\n}\n```\n\n\n\n## 基础\n\n### Go 变量与函数同名\n\n\n\n\n\n### 有n个大文件，无法加载进内存， 里面内容是无序的，怎么把他们合并成一个有序的文件\n\n外排序\n\n### 建堆的过程\n\n```\n大顶堆：每个结点的值都大于或等于其左右孩子结点的值\n小顶堆：每个结点的值都小于或等于其左右孩子结点的值\n\n根据堆的特性来形成公式就是，节点为i的话\n大顶堆: arr[i]>=arr[2i+1] && arr[i]>=arr[2i+2]\n小顶堆：arr[i]<=arr[2i+1] && arr[i]<=arr[2i+2]\n```\n\n\n\n### 索引为什么不用b+树和平衡二叉树\n\n\n\n### 索引的节点 多大比较合适\n\n\n\n### 索引存什么样的格式比较合适\n\n树转数组\n\n\n\n### 操作系统 io的大小\n\n- 分页\n- 分段\n- 段页式\n\n\n\n### 操作系统32位和64位的区别\n\n\n\n### mysql执行事务的时候宕机了，恢复之后还能正常执行吗\n\n\n\n### 多个进程的时候，如果系统使用时间片轮转的方式 他们是用什么方式提醒下一个进程的，需要存储什么数据\n\n``` \n1. 使用中断\n2. 寄存器内的数据，当前任务的状态\n```\n\n\n\n### 更新数据库和缓存的时候怎么保证强一致性\n\n\n\n\n\n","slug":"面试/复盘/2.24伴鱼面试","published":1,"updated":"2020-02-25T10:56:48.816Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71t2tue0024mn8n5q26ao7w","content":"<h2 id=\"算法题\"><a href=\"#算法题\" class=\"headerlink\" title=\"算法题\"></a>算法题</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用一个 M×N 的矩阵表示一个未知星球的地表，0 表示该区域为海洋，1 表示该区域为陆地，每块陆地只可能与上、下、左、右相邻的四块陆地接壤，请找到这个星球上面积最大的岛屿。</span></span><br><span class=\"line\"><span class=\"comment\">// 示例：</span></span><br><span class=\"line\"><span class=\"comment\">// 输入：</span></span><br><span class=\"line\"><span class=\"comment\">// [</span></span><br><span class=\"line\"><span class=\"comment\">//   [1, 1, 0],</span></span><br><span class=\"line\"><span class=\"comment\">//   [1, 0, 0],</span></span><br><span class=\"line\"><span class=\"comment\">//   [0, 0, 1]</span></span><br><span class=\"line\"><span class=\"comment\">// ]</span></span><br><span class=\"line\"><span class=\"comment\">// 输出：3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxArea</span><span class=\"params\">(grid [][]<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  max := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(grid); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j:=<span class=\"number\">0</span>; j&lt; <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>]; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> grid[i][j] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        area := dfs(grid, i, j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> area &gt; max &#123;</span><br><span class=\"line\">          max = area</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(grid [][]<span class=\"keyword\">int</span>, x,y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> || x &gt;= <span class=\"built_in\">len</span>(grid) || y &lt; <span class=\"number\">0</span> || y &gt;= <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> grid[i][j] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  area := <span class=\"number\">1</span></span><br><span class=\"line\">  grid[i][j] == <span class=\"number\">0</span></span><br><span class=\"line\">  dx := [<span class=\"number\">4</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">  dy := [<span class=\"number\">4</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i&lt; <span class=\"number\">4</span>; i++ &#123;</span><br><span class=\"line\">    area += dfs(grid, x+ dx[i], y + dy[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> area</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"Go-变量与函数同名\"><a href=\"#Go-变量与函数同名\" class=\"headerlink\" title=\"Go 变量与函数同名\"></a>Go 变量与函数同名</h3><h3 id=\"有n个大文件，无法加载进内存，-里面内容是无序的，怎么把他们合并成一个有序的文件\"><a href=\"#有n个大文件，无法加载进内存，-里面内容是无序的，怎么把他们合并成一个有序的文件\" class=\"headerlink\" title=\"有n个大文件，无法加载进内存， 里面内容是无序的，怎么把他们合并成一个有序的文件\"></a>有n个大文件，无法加载进内存， 里面内容是无序的，怎么把他们合并成一个有序的文件</h3><p>外排序</p>\n<h3 id=\"建堆的过程\"><a href=\"#建堆的过程\" class=\"headerlink\" title=\"建堆的过程\"></a>建堆的过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">大顶堆：每个结点的值都大于或等于其左右孩子结点的值</span><br><span class=\"line\">小顶堆：每个结点的值都小于或等于其左右孩子结点的值</span><br><span class=\"line\"></span><br><span class=\"line\">根据堆的特性来形成公式就是，节点为i的话</span><br><span class=\"line\">大顶堆: arr[i]&gt;&#x3D;arr[2i+1] &amp;&amp; arr[i]&gt;&#x3D;arr[2i+2]</span><br><span class=\"line\">小顶堆：arr[i]&lt;&#x3D;arr[2i+1] &amp;&amp; arr[i]&lt;&#x3D;arr[2i+2]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"索引为什么不用b-树和平衡二叉树\"><a href=\"#索引为什么不用b-树和平衡二叉树\" class=\"headerlink\" title=\"索引为什么不用b+树和平衡二叉树\"></a>索引为什么不用b+树和平衡二叉树</h3><h3 id=\"索引的节点-多大比较合适\"><a href=\"#索引的节点-多大比较合适\" class=\"headerlink\" title=\"索引的节点 多大比较合适\"></a>索引的节点 多大比较合适</h3><h3 id=\"索引存什么样的格式比较合适\"><a href=\"#索引存什么样的格式比较合适\" class=\"headerlink\" title=\"索引存什么样的格式比较合适\"></a>索引存什么样的格式比较合适</h3><p>树转数组</p>\n<h3 id=\"操作系统-io的大小\"><a href=\"#操作系统-io的大小\" class=\"headerlink\" title=\"操作系统 io的大小\"></a>操作系统 io的大小</h3><ul>\n<li>分页</li>\n<li>分段</li>\n<li>段页式</li>\n</ul>\n<h3 id=\"操作系统32位和64位的区别\"><a href=\"#操作系统32位和64位的区别\" class=\"headerlink\" title=\"操作系统32位和64位的区别\"></a>操作系统32位和64位的区别</h3><h3 id=\"mysql执行事务的时候宕机了，恢复之后还能正常执行吗\"><a href=\"#mysql执行事务的时候宕机了，恢复之后还能正常执行吗\" class=\"headerlink\" title=\"mysql执行事务的时候宕机了，恢复之后还能正常执行吗\"></a>mysql执行事务的时候宕机了，恢复之后还能正常执行吗</h3><h3 id=\"多个进程的时候，如果系统使用时间片轮转的方式-他们是用什么方式提醒下一个进程的，需要存储什么数据\"><a href=\"#多个进程的时候，如果系统使用时间片轮转的方式-他们是用什么方式提醒下一个进程的，需要存储什么数据\" class=\"headerlink\" title=\"多个进程的时候，如果系统使用时间片轮转的方式 他们是用什么方式提醒下一个进程的，需要存储什么数据\"></a>多个进程的时候，如果系统使用时间片轮转的方式 他们是用什么方式提醒下一个进程的，需要存储什么数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 使用中断</span><br><span class=\"line\">2. 寄存器内的数据，当前任务的状态</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"更新数据库和缓存的时候怎么保证强一致性\"><a href=\"#更新数据库和缓存的时候怎么保证强一致性\" class=\"headerlink\" title=\"更新数据库和缓存的时候怎么保证强一致性\"></a>更新数据库和缓存的时候怎么保证强一致性</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"算法题\"><a href=\"#算法题\" class=\"headerlink\" title=\"算法题\"></a>算法题</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用一个 M×N 的矩阵表示一个未知星球的地表，0 表示该区域为海洋，1 表示该区域为陆地，每块陆地只可能与上、下、左、右相邻的四块陆地接壤，请找到这个星球上面积最大的岛屿。</span></span><br><span class=\"line\"><span class=\"comment\">// 示例：</span></span><br><span class=\"line\"><span class=\"comment\">// 输入：</span></span><br><span class=\"line\"><span class=\"comment\">// [</span></span><br><span class=\"line\"><span class=\"comment\">//   [1, 1, 0],</span></span><br><span class=\"line\"><span class=\"comment\">//   [1, 0, 0],</span></span><br><span class=\"line\"><span class=\"comment\">//   [0, 0, 1]</span></span><br><span class=\"line\"><span class=\"comment\">// ]</span></span><br><span class=\"line\"><span class=\"comment\">// 输出：3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxArea</span><span class=\"params\">(grid [][]<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  max := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(grid); i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j:=<span class=\"number\">0</span>; j&lt; <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>]; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> grid[i][j] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        area := dfs(grid, i, j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> area &gt; max &#123;</span><br><span class=\"line\">          max = area</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> max</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(grid [][]<span class=\"keyword\">int</span>, x,y <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> || x &gt;= <span class=\"built_in\">len</span>(grid) || y &lt; <span class=\"number\">0</span> || y &gt;= <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> grid[i][j] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  area := <span class=\"number\">1</span></span><br><span class=\"line\">  grid[i][j] == <span class=\"number\">0</span></span><br><span class=\"line\">  dx := [<span class=\"number\">4</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">  dy := [<span class=\"number\">4</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i&lt; <span class=\"number\">4</span>; i++ &#123;</span><br><span class=\"line\">    area += dfs(grid, x+ dx[i], y + dy[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> area</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"Go-变量与函数同名\"><a href=\"#Go-变量与函数同名\" class=\"headerlink\" title=\"Go 变量与函数同名\"></a>Go 变量与函数同名</h3><h3 id=\"有n个大文件，无法加载进内存，-里面内容是无序的，怎么把他们合并成一个有序的文件\"><a href=\"#有n个大文件，无法加载进内存，-里面内容是无序的，怎么把他们合并成一个有序的文件\" class=\"headerlink\" title=\"有n个大文件，无法加载进内存， 里面内容是无序的，怎么把他们合并成一个有序的文件\"></a>有n个大文件，无法加载进内存， 里面内容是无序的，怎么把他们合并成一个有序的文件</h3><p>外排序</p>\n<h3 id=\"建堆的过程\"><a href=\"#建堆的过程\" class=\"headerlink\" title=\"建堆的过程\"></a>建堆的过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">大顶堆：每个结点的值都大于或等于其左右孩子结点的值</span><br><span class=\"line\">小顶堆：每个结点的值都小于或等于其左右孩子结点的值</span><br><span class=\"line\"></span><br><span class=\"line\">根据堆的特性来形成公式就是，节点为i的话</span><br><span class=\"line\">大顶堆: arr[i]&gt;&#x3D;arr[2i+1] &amp;&amp; arr[i]&gt;&#x3D;arr[2i+2]</span><br><span class=\"line\">小顶堆：arr[i]&lt;&#x3D;arr[2i+1] &amp;&amp; arr[i]&lt;&#x3D;arr[2i+2]</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"索引为什么不用b-树和平衡二叉树\"><a href=\"#索引为什么不用b-树和平衡二叉树\" class=\"headerlink\" title=\"索引为什么不用b+树和平衡二叉树\"></a>索引为什么不用b+树和平衡二叉树</h3><h3 id=\"索引的节点-多大比较合适\"><a href=\"#索引的节点-多大比较合适\" class=\"headerlink\" title=\"索引的节点 多大比较合适\"></a>索引的节点 多大比较合适</h3><h3 id=\"索引存什么样的格式比较合适\"><a href=\"#索引存什么样的格式比较合适\" class=\"headerlink\" title=\"索引存什么样的格式比较合适\"></a>索引存什么样的格式比较合适</h3><p>树转数组</p>\n<h3 id=\"操作系统-io的大小\"><a href=\"#操作系统-io的大小\" class=\"headerlink\" title=\"操作系统 io的大小\"></a>操作系统 io的大小</h3><ul>\n<li>分页</li>\n<li>分段</li>\n<li>段页式</li>\n</ul>\n<h3 id=\"操作系统32位和64位的区别\"><a href=\"#操作系统32位和64位的区别\" class=\"headerlink\" title=\"操作系统32位和64位的区别\"></a>操作系统32位和64位的区别</h3><h3 id=\"mysql执行事务的时候宕机了，恢复之后还能正常执行吗\"><a href=\"#mysql执行事务的时候宕机了，恢复之后还能正常执行吗\" class=\"headerlink\" title=\"mysql执行事务的时候宕机了，恢复之后还能正常执行吗\"></a>mysql执行事务的时候宕机了，恢复之后还能正常执行吗</h3><h3 id=\"多个进程的时候，如果系统使用时间片轮转的方式-他们是用什么方式提醒下一个进程的，需要存储什么数据\"><a href=\"#多个进程的时候，如果系统使用时间片轮转的方式-他们是用什么方式提醒下一个进程的，需要存储什么数据\" class=\"headerlink\" title=\"多个进程的时候，如果系统使用时间片轮转的方式 他们是用什么方式提醒下一个进程的，需要存储什么数据\"></a>多个进程的时候，如果系统使用时间片轮转的方式 他们是用什么方式提醒下一个进程的，需要存储什么数据</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 使用中断</span><br><span class=\"line\">2. 寄存器内的数据，当前任务的状态</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"更新数据库和缓存的时候怎么保证强一致性\"><a href=\"#更新数据库和缓存的时候怎么保证强一致性\" class=\"headerlink\" title=\"更新数据库和缓存的时候怎么保证强一致性\"></a>更新数据库和缓存的时候怎么保证强一致性</h3>"},{"title":"【面试复盘】作业帮面试","date":"2020-02-24T16:00:00.000Z","_content":"\n\n\n## 小结 \n\n```\n作业帮的面试相对会问很多业务相关的东西， 并且会有很多mysql的代码提问\n```\n\n\n\n## 一面\n\n### 在数据库主库和从库不一致的时候，怎么保证数据正确\n\n- 读写都在主库\n- 在写入sql的时候，同时更新缓存，过期时间可以根据自己的经验设置\n- 数据库中间件 （成本较高）读取走读库， 写走写库， 判断如果这个key最近修改过， 也走写库\n\n### 怎么保证数据库和redis数据一致性\n\n- 延时双删 超时时间内还是会有问题\n- 异步更新 binlog增量订阅 + 消息队列 + 更新redis\n\n### rabbitMQ比redis作为消息队列的优点\n\n\n\n### mysql的锁的类型\n\n\n\n### 事务隔离的级别\n\n```\n数据库提供的四种隔离级别：\n01：Read uncommitted(读未提交)：最低级别，任何情况都会发生。\n02：Read Committed(读已提交)：可避免脏读的发生。\n03：Repeatable read(可重复读)：可避免脏读、不可重复读的发生。\n04：Serializable(串行化)：避免脏读、不可重复读，幻读的发生。\n```\n\n\n\n### 下面代码关键字的执行顺序\n\n``` sql\nselect * from tables where true order by id limit 1\n```\n\n\n\n### 怎么保证增减积分的时候不会多扣\n\n- 消息队列\n- 设锁（悲观锁）\n- where \n\n\n\n### git cherry-pick\n\n\n\n### 反向代理\n\n\n\n## 二面\n\n### rabbitMQ是一种怎么样的形式， 推还是订阅\n\n\n\n### 联合索引的执行顺序\n\n最左匹配原则\n\n### 为什么要使用联合索引\n\n- 减少开销 建一个联合索引等于建很多索引\n- \n\n### like能否用索引 !=呢 in呢\n\n- like的前模糊和全模糊不会走索引 即 %j j j 或%j j j%\n\n- 使用<> 或者 != 也不走索引\n- in走索引\n\n### 分段有序的数组， 查找指定数\n\n``` go\n// 二分法\n\nfunc findX(x int, a []int) bool {\n  l, r := 0, len(a)-1\n  for l < r {\n    mid = l + (r-l)/2\n    if a[mid] == x {\n      return true\n    }\n    if a[mid-1] > a[l] {\n      if a[mid - 1] > x && x > a[l] {\n      \tr= mid -1 \n      } else {\n        l = mid + 1\n      }\n    } else {\n      if a[mid+1] < x && x < a[r] {\n        l = mid + 1\n      } else {\n        r = mid - 1\n      }\n    }\n  }\n}\n```\n\n\n\n","source":"_posts/面试/复盘/2.25作业帮面试.md","raw":"---\ntitle: 【面试复盘】作业帮面试\ndate: 2020-02-25\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n## 小结 \n\n```\n作业帮的面试相对会问很多业务相关的东西， 并且会有很多mysql的代码提问\n```\n\n\n\n## 一面\n\n### 在数据库主库和从库不一致的时候，怎么保证数据正确\n\n- 读写都在主库\n- 在写入sql的时候，同时更新缓存，过期时间可以根据自己的经验设置\n- 数据库中间件 （成本较高）读取走读库， 写走写库， 判断如果这个key最近修改过， 也走写库\n\n### 怎么保证数据库和redis数据一致性\n\n- 延时双删 超时时间内还是会有问题\n- 异步更新 binlog增量订阅 + 消息队列 + 更新redis\n\n### rabbitMQ比redis作为消息队列的优点\n\n\n\n### mysql的锁的类型\n\n\n\n### 事务隔离的级别\n\n```\n数据库提供的四种隔离级别：\n01：Read uncommitted(读未提交)：最低级别，任何情况都会发生。\n02：Read Committed(读已提交)：可避免脏读的发生。\n03：Repeatable read(可重复读)：可避免脏读、不可重复读的发生。\n04：Serializable(串行化)：避免脏读、不可重复读，幻读的发生。\n```\n\n\n\n### 下面代码关键字的执行顺序\n\n``` sql\nselect * from tables where true order by id limit 1\n```\n\n\n\n### 怎么保证增减积分的时候不会多扣\n\n- 消息队列\n- 设锁（悲观锁）\n- where \n\n\n\n### git cherry-pick\n\n\n\n### 反向代理\n\n\n\n## 二面\n\n### rabbitMQ是一种怎么样的形式， 推还是订阅\n\n\n\n### 联合索引的执行顺序\n\n最左匹配原则\n\n### 为什么要使用联合索引\n\n- 减少开销 建一个联合索引等于建很多索引\n- \n\n### like能否用索引 !=呢 in呢\n\n- like的前模糊和全模糊不会走索引 即 %j j j 或%j j j%\n\n- 使用<> 或者 != 也不走索引\n- in走索引\n\n### 分段有序的数组， 查找指定数\n\n``` go\n// 二分法\n\nfunc findX(x int, a []int) bool {\n  l, r := 0, len(a)-1\n  for l < r {\n    mid = l + (r-l)/2\n    if a[mid] == x {\n      return true\n    }\n    if a[mid-1] > a[l] {\n      if a[mid - 1] > x && x > a[l] {\n      \tr= mid -1 \n      } else {\n        l = mid + 1\n      }\n    } else {\n      if a[mid+1] < x && x < a[r] {\n        l = mid + 1\n      } else {\n        r = mid - 1\n      }\n    }\n  }\n}\n```\n\n\n\n","slug":"面试/复盘/2.25作业帮面试","published":1,"updated":"2020-03-05T03:52:54.967Z","_id":"ck71t2tuf0028mn8nhtn96d40","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作业帮的面试相对会问很多业务相关的东西， 并且会有很多mysql的代码提问</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"在数据库主库和从库不一致的时候，怎么保证数据正确\"><a href=\"#在数据库主库和从库不一致的时候，怎么保证数据正确\" class=\"headerlink\" title=\"在数据库主库和从库不一致的时候，怎么保证数据正确\"></a>在数据库主库和从库不一致的时候，怎么保证数据正确</h3><ul>\n<li>读写都在主库</li>\n<li>在写入sql的时候，同时更新缓存，过期时间可以根据自己的经验设置</li>\n<li>数据库中间件 （成本较高）读取走读库， 写走写库， 判断如果这个key最近修改过， 也走写库</li>\n</ul>\n<h3 id=\"怎么保证数据库和redis数据一致性\"><a href=\"#怎么保证数据库和redis数据一致性\" class=\"headerlink\" title=\"怎么保证数据库和redis数据一致性\"></a>怎么保证数据库和redis数据一致性</h3><ul>\n<li>延时双删 超时时间内还是会有问题</li>\n<li>异步更新 binlog增量订阅 + 消息队列 + 更新redis</li>\n</ul>\n<h3 id=\"rabbitMQ比redis作为消息队列的优点\"><a href=\"#rabbitMQ比redis作为消息队列的优点\" class=\"headerlink\" title=\"rabbitMQ比redis作为消息队列的优点\"></a>rabbitMQ比redis作为消息队列的优点</h3><h3 id=\"mysql的锁的类型\"><a href=\"#mysql的锁的类型\" class=\"headerlink\" title=\"mysql的锁的类型\"></a>mysql的锁的类型</h3><h3 id=\"事务隔离的级别\"><a href=\"#事务隔离的级别\" class=\"headerlink\" title=\"事务隔离的级别\"></a>事务隔离的级别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据库提供的四种隔离级别：</span><br><span class=\"line\">01：Read uncommitted(读未提交)：最低级别，任何情况都会发生。</span><br><span class=\"line\">02：Read Committed(读已提交)：可避免脏读的发生。</span><br><span class=\"line\">03：Repeatable read(可重复读)：可避免脏读、不可重复读的发生。</span><br><span class=\"line\">04：Serializable(串行化)：避免脏读、不可重复读，幻读的发生。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"下面代码关键字的执行顺序\"><a href=\"#下面代码关键字的执行顺序\" class=\"headerlink\" title=\"下面代码关键字的执行顺序\"></a>下面代码关键字的执行顺序</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">tables</span> <span class=\"keyword\">where</span> <span class=\"literal\">true</span> <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"keyword\">id</span> <span class=\"keyword\">limit</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"怎么保证增减积分的时候不会多扣\"><a href=\"#怎么保证增减积分的时候不会多扣\" class=\"headerlink\" title=\"怎么保证增减积分的时候不会多扣\"></a>怎么保证增减积分的时候不会多扣</h3><ul>\n<li>消息队列</li>\n<li>设锁（悲观锁）</li>\n<li>where </li>\n</ul>\n<h3 id=\"git-cherry-pick\"><a href=\"#git-cherry-pick\" class=\"headerlink\" title=\"git cherry-pick\"></a>git cherry-pick</h3><h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><h3 id=\"rabbitMQ是一种怎么样的形式，-推还是订阅\"><a href=\"#rabbitMQ是一种怎么样的形式，-推还是订阅\" class=\"headerlink\" title=\"rabbitMQ是一种怎么样的形式， 推还是订阅\"></a>rabbitMQ是一种怎么样的形式， 推还是订阅</h3><h3 id=\"联合索引的执行顺序\"><a href=\"#联合索引的执行顺序\" class=\"headerlink\" title=\"联合索引的执行顺序\"></a>联合索引的执行顺序</h3><p>最左匹配原则</p>\n<h3 id=\"为什么要使用联合索引\"><a href=\"#为什么要使用联合索引\" class=\"headerlink\" title=\"为什么要使用联合索引\"></a>为什么要使用联合索引</h3><ul>\n<li>减少开销 建一个联合索引等于建很多索引</li>\n<li></li>\n</ul>\n<h3 id=\"like能否用索引-呢-in呢\"><a href=\"#like能否用索引-呢-in呢\" class=\"headerlink\" title=\"like能否用索引 !=呢 in呢\"></a>like能否用索引 !=呢 in呢</h3><ul>\n<li><p>like的前模糊和全模糊不会走索引 即 %j j j 或%j j j%</p>\n</li>\n<li><p>使用&lt;&gt; 或者 != 也不走索引</p>\n</li>\n<li><p>in走索引</p>\n</li>\n</ul>\n<h3 id=\"分段有序的数组，-查找指定数\"><a href=\"#分段有序的数组，-查找指定数\" class=\"headerlink\" title=\"分段有序的数组， 查找指定数\"></a>分段有序的数组， 查找指定数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二分法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findX</span><span class=\"params\">(x <span class=\"keyword\">int</span>, a []<span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  l, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(a)<span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> l &lt; r &#123;</span><br><span class=\"line\">    mid = l + (r-l)/<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a[mid] == x &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a[mid<span class=\"number\">-1</span>] &gt; a[l] &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> a[mid - <span class=\"number\">1</span>] &gt; x &amp;&amp; x &gt; a[l] &#123;</span><br><span class=\"line\">      \tr= mid <span class=\"number\">-1</span> </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> a[mid+<span class=\"number\">1</span>] &lt; x &amp;&amp; x &lt; a[r] &#123;</span><br><span class=\"line\">        l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        r = mid - <span class=\"number\">1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作业帮的面试相对会问很多业务相关的东西， 并且会有很多mysql的代码提问</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"在数据库主库和从库不一致的时候，怎么保证数据正确\"><a href=\"#在数据库主库和从库不一致的时候，怎么保证数据正确\" class=\"headerlink\" title=\"在数据库主库和从库不一致的时候，怎么保证数据正确\"></a>在数据库主库和从库不一致的时候，怎么保证数据正确</h3><ul>\n<li>读写都在主库</li>\n<li>在写入sql的时候，同时更新缓存，过期时间可以根据自己的经验设置</li>\n<li>数据库中间件 （成本较高）读取走读库， 写走写库， 判断如果这个key最近修改过， 也走写库</li>\n</ul>\n<h3 id=\"怎么保证数据库和redis数据一致性\"><a href=\"#怎么保证数据库和redis数据一致性\" class=\"headerlink\" title=\"怎么保证数据库和redis数据一致性\"></a>怎么保证数据库和redis数据一致性</h3><ul>\n<li>延时双删 超时时间内还是会有问题</li>\n<li>异步更新 binlog增量订阅 + 消息队列 + 更新redis</li>\n</ul>\n<h3 id=\"rabbitMQ比redis作为消息队列的优点\"><a href=\"#rabbitMQ比redis作为消息队列的优点\" class=\"headerlink\" title=\"rabbitMQ比redis作为消息队列的优点\"></a>rabbitMQ比redis作为消息队列的优点</h3><h3 id=\"mysql的锁的类型\"><a href=\"#mysql的锁的类型\" class=\"headerlink\" title=\"mysql的锁的类型\"></a>mysql的锁的类型</h3><h3 id=\"事务隔离的级别\"><a href=\"#事务隔离的级别\" class=\"headerlink\" title=\"事务隔离的级别\"></a>事务隔离的级别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据库提供的四种隔离级别：</span><br><span class=\"line\">01：Read uncommitted(读未提交)：最低级别，任何情况都会发生。</span><br><span class=\"line\">02：Read Committed(读已提交)：可避免脏读的发生。</span><br><span class=\"line\">03：Repeatable read(可重复读)：可避免脏读、不可重复读的发生。</span><br><span class=\"line\">04：Serializable(串行化)：避免脏读、不可重复读，幻读的发生。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"下面代码关键字的执行顺序\"><a href=\"#下面代码关键字的执行顺序\" class=\"headerlink\" title=\"下面代码关键字的执行顺序\"></a>下面代码关键字的执行顺序</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">tables</span> <span class=\"keyword\">where</span> <span class=\"literal\">true</span> <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"keyword\">id</span> <span class=\"keyword\">limit</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"怎么保证增减积分的时候不会多扣\"><a href=\"#怎么保证增减积分的时候不会多扣\" class=\"headerlink\" title=\"怎么保证增减积分的时候不会多扣\"></a>怎么保证增减积分的时候不会多扣</h3><ul>\n<li>消息队列</li>\n<li>设锁（悲观锁）</li>\n<li>where </li>\n</ul>\n<h3 id=\"git-cherry-pick\"><a href=\"#git-cherry-pick\" class=\"headerlink\" title=\"git cherry-pick\"></a>git cherry-pick</h3><h3 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h3><h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><h3 id=\"rabbitMQ是一种怎么样的形式，-推还是订阅\"><a href=\"#rabbitMQ是一种怎么样的形式，-推还是订阅\" class=\"headerlink\" title=\"rabbitMQ是一种怎么样的形式， 推还是订阅\"></a>rabbitMQ是一种怎么样的形式， 推还是订阅</h3><h3 id=\"联合索引的执行顺序\"><a href=\"#联合索引的执行顺序\" class=\"headerlink\" title=\"联合索引的执行顺序\"></a>联合索引的执行顺序</h3><p>最左匹配原则</p>\n<h3 id=\"为什么要使用联合索引\"><a href=\"#为什么要使用联合索引\" class=\"headerlink\" title=\"为什么要使用联合索引\"></a>为什么要使用联合索引</h3><ul>\n<li>减少开销 建一个联合索引等于建很多索引</li>\n<li></li>\n</ul>\n<h3 id=\"like能否用索引-呢-in呢\"><a href=\"#like能否用索引-呢-in呢\" class=\"headerlink\" title=\"like能否用索引 !=呢 in呢\"></a>like能否用索引 !=呢 in呢</h3><ul>\n<li><p>like的前模糊和全模糊不会走索引 即 %j j j 或%j j j%</p>\n</li>\n<li><p>使用&lt;&gt; 或者 != 也不走索引</p>\n</li>\n<li><p>in走索引</p>\n</li>\n</ul>\n<h3 id=\"分段有序的数组，-查找指定数\"><a href=\"#分段有序的数组，-查找指定数\" class=\"headerlink\" title=\"分段有序的数组， 查找指定数\"></a>分段有序的数组， 查找指定数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 二分法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findX</span><span class=\"params\">(x <span class=\"keyword\">int</span>, a []<span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">  l, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(a)<span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> l &lt; r &#123;</span><br><span class=\"line\">    mid = l + (r-l)/<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a[mid] == x &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a[mid<span class=\"number\">-1</span>] &gt; a[l] &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> a[mid - <span class=\"number\">1</span>] &gt; x &amp;&amp; x &gt; a[l] &#123;</span><br><span class=\"line\">      \tr= mid <span class=\"number\">-1</span> </span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> a[mid+<span class=\"number\">1</span>] &lt; x &amp;&amp; x &lt; a[r] &#123;</span><br><span class=\"line\">        l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        r = mid - <span class=\"number\">1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"【面试复盘】来也面试","date":"2020-02-24T16:00:00.000Z","_content":"\n\n\n该部门只是对一个微信公众号的网站进行维护 因此兴趣不大\n\n## 基础\n\n\n\n### 并列排行榜的实现\n\n使用浮点数 如果分数是整数的时候，直接大于x.1即可\n\n### hash的底层实现\n\n- 数组加链表的数据结构\n\n- 通过算法计算hash_code （可能会有hash冲突）\n\n- hash冲突的时候使用链表\n\n### 评论的时候怎么保证幂等性\n\n\n\n### mysql 线上有1000万个数据，怎么加索引\n\n新建另外的数据库来加\n\n### mysql 1000万个数据，怎么分页\n\n加一个子查询 id>= limit\n\n``` sql\nselect * from test where id >= (select id from test limit 9000000,1)limit 0,100\n```\n\n\n\n### grpc的底层协议\n\ngrpc底层使用的是http2.0  传输的数据结构是protocolbuf 是二进制的格式","source":"_posts/面试/复盘/2.25来也面试.md","raw":"---\ntitle: 【面试复盘】来也面试\ndate: 2020-02-25\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n该部门只是对一个微信公众号的网站进行维护 因此兴趣不大\n\n## 基础\n\n\n\n### 并列排行榜的实现\n\n使用浮点数 如果分数是整数的时候，直接大于x.1即可\n\n### hash的底层实现\n\n- 数组加链表的数据结构\n\n- 通过算法计算hash_code （可能会有hash冲突）\n\n- hash冲突的时候使用链表\n\n### 评论的时候怎么保证幂等性\n\n\n\n### mysql 线上有1000万个数据，怎么加索引\n\n新建另外的数据库来加\n\n### mysql 1000万个数据，怎么分页\n\n加一个子查询 id>= limit\n\n``` sql\nselect * from test where id >= (select id from test limit 9000000,1)limit 0,100\n```\n\n\n\n### grpc的底层协议\n\ngrpc底层使用的是http2.0  传输的数据结构是protocolbuf 是二进制的格式","slug":"面试/复盘/2.25来也面试","published":1,"updated":"2020-02-25T12:00:10.757Z","_id":"ck71t2tug002bmn8ncslh8u3d","comments":1,"layout":"post","photos":[],"link":"","content":"<p>该部门只是对一个微信公众号的网站进行维护 因此兴趣不大</p>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"并列排行榜的实现\"><a href=\"#并列排行榜的实现\" class=\"headerlink\" title=\"并列排行榜的实现\"></a>并列排行榜的实现</h3><p>使用浮点数 如果分数是整数的时候，直接大于x.1即可</p>\n<h3 id=\"hash的底层实现\"><a href=\"#hash的底层实现\" class=\"headerlink\" title=\"hash的底层实现\"></a>hash的底层实现</h3><ul>\n<li><p>数组加链表的数据结构</p>\n</li>\n<li><p>通过算法计算hash_code （可能会有hash冲突）</p>\n</li>\n<li><p>hash冲突的时候使用链表</p>\n</li>\n</ul>\n<h3 id=\"评论的时候怎么保证幂等性\"><a href=\"#评论的时候怎么保证幂等性\" class=\"headerlink\" title=\"评论的时候怎么保证幂等性\"></a>评论的时候怎么保证幂等性</h3><h3 id=\"mysql-线上有1000万个数据，怎么加索引\"><a href=\"#mysql-线上有1000万个数据，怎么加索引\" class=\"headerlink\" title=\"mysql 线上有1000万个数据，怎么加索引\"></a>mysql 线上有1000万个数据，怎么加索引</h3><p>新建另外的数据库来加</p>\n<h3 id=\"mysql-1000万个数据，怎么分页\"><a href=\"#mysql-1000万个数据，怎么分页\" class=\"headerlink\" title=\"mysql 1000万个数据，怎么分页\"></a>mysql 1000万个数据，怎么分页</h3><p>加一个子查询 id&gt;= limit</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">test</span> <span class=\"keyword\">where</span> <span class=\"keyword\">id</span> &gt;= (<span class=\"keyword\">select</span> <span class=\"keyword\">id</span> <span class=\"keyword\">from</span> <span class=\"keyword\">test</span> <span class=\"keyword\">limit</span> <span class=\"number\">9000000</span>,<span class=\"number\">1</span>)<span class=\"keyword\">limit</span> <span class=\"number\">0</span>,<span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"grpc的底层协议\"><a href=\"#grpc的底层协议\" class=\"headerlink\" title=\"grpc的底层协议\"></a>grpc的底层协议</h3><p>grpc底层使用的是http2.0  传输的数据结构是protocolbuf 是二进制的格式</p>\n","site":{"data":{}},"excerpt":"","more":"<p>该部门只是对一个微信公众号的网站进行维护 因此兴趣不大</p>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"并列排行榜的实现\"><a href=\"#并列排行榜的实现\" class=\"headerlink\" title=\"并列排行榜的实现\"></a>并列排行榜的实现</h3><p>使用浮点数 如果分数是整数的时候，直接大于x.1即可</p>\n<h3 id=\"hash的底层实现\"><a href=\"#hash的底层实现\" class=\"headerlink\" title=\"hash的底层实现\"></a>hash的底层实现</h3><ul>\n<li><p>数组加链表的数据结构</p>\n</li>\n<li><p>通过算法计算hash_code （可能会有hash冲突）</p>\n</li>\n<li><p>hash冲突的时候使用链表</p>\n</li>\n</ul>\n<h3 id=\"评论的时候怎么保证幂等性\"><a href=\"#评论的时候怎么保证幂等性\" class=\"headerlink\" title=\"评论的时候怎么保证幂等性\"></a>评论的时候怎么保证幂等性</h3><h3 id=\"mysql-线上有1000万个数据，怎么加索引\"><a href=\"#mysql-线上有1000万个数据，怎么加索引\" class=\"headerlink\" title=\"mysql 线上有1000万个数据，怎么加索引\"></a>mysql 线上有1000万个数据，怎么加索引</h3><p>新建另外的数据库来加</p>\n<h3 id=\"mysql-1000万个数据，怎么分页\"><a href=\"#mysql-1000万个数据，怎么分页\" class=\"headerlink\" title=\"mysql 1000万个数据，怎么分页\"></a>mysql 1000万个数据，怎么分页</h3><p>加一个子查询 id&gt;= limit</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">test</span> <span class=\"keyword\">where</span> <span class=\"keyword\">id</span> &gt;= (<span class=\"keyword\">select</span> <span class=\"keyword\">id</span> <span class=\"keyword\">from</span> <span class=\"keyword\">test</span> <span class=\"keyword\">limit</span> <span class=\"number\">9000000</span>,<span class=\"number\">1</span>)<span class=\"keyword\">limit</span> <span class=\"number\">0</span>,<span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"grpc的底层协议\"><a href=\"#grpc的底层协议\" class=\"headerlink\" title=\"grpc的底层协议\"></a>grpc的底层协议</h3><p>grpc底层使用的是http2.0  传输的数据结构是protocolbuf 是二进制的格式</p>\n"},{"title":"【面试复盘】映客面试","date":"2020-02-26T16:00:00.000Z","_content":"\n\n\n### 访问mi.com 的过程\n\n\n\n### rpc的协议\n\n\n\n### 除了pb http怎么返回数据\n\nASCII码\n\n### 怎么保证消息队列不会重复处理\n\n唯一keyid\n\n### mysql调优 的方法\n\n\n\n### 使用redis来实现定时器 如果所有用户等待时间相同 或者不同\n\n- list  rpush lpop\n- zset zrangebyscore key min max\n\n\n\n### mysql 主库写入还没有更新到读库的时候 怎么保证读的数据是最新的","source":"_posts/面试/复盘/2.27映客面试.md","raw":"---\ntitle: 【面试复盘】映客面试\ndate: 2020-02-27\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n### 访问mi.com 的过程\n\n\n\n### rpc的协议\n\n\n\n### 除了pb http怎么返回数据\n\nASCII码\n\n### 怎么保证消息队列不会重复处理\n\n唯一keyid\n\n### mysql调优 的方法\n\n\n\n### 使用redis来实现定时器 如果所有用户等待时间相同 或者不同\n\n- list  rpush lpop\n- zset zrangebyscore key min max\n\n\n\n### mysql 主库写入还没有更新到读库的时候 怎么保证读的数据是最新的","slug":"面试/复盘/2.27映客面试","published":1,"updated":"2020-03-03T02:58:30.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7cxr5db00005x8n9872dt3v","content":"<h3 id=\"访问mi-com-的过程\"><a href=\"#访问mi-com-的过程\" class=\"headerlink\" title=\"访问mi.com 的过程\"></a>访问mi.com 的过程</h3><h3 id=\"rpc的协议\"><a href=\"#rpc的协议\" class=\"headerlink\" title=\"rpc的协议\"></a>rpc的协议</h3><h3 id=\"除了pb-http怎么返回数据\"><a href=\"#除了pb-http怎么返回数据\" class=\"headerlink\" title=\"除了pb http怎么返回数据\"></a>除了pb http怎么返回数据</h3><p>ASCII码</p>\n<h3 id=\"怎么保证消息队列不会重复处理\"><a href=\"#怎么保证消息队列不会重复处理\" class=\"headerlink\" title=\"怎么保证消息队列不会重复处理\"></a>怎么保证消息队列不会重复处理</h3><p>唯一keyid</p>\n<h3 id=\"mysql调优-的方法\"><a href=\"#mysql调优-的方法\" class=\"headerlink\" title=\"mysql调优 的方法\"></a>mysql调优 的方法</h3><h3 id=\"使用redis来实现定时器-如果所有用户等待时间相同-或者不同\"><a href=\"#使用redis来实现定时器-如果所有用户等待时间相同-或者不同\" class=\"headerlink\" title=\"使用redis来实现定时器 如果所有用户等待时间相同 或者不同\"></a>使用redis来实现定时器 如果所有用户等待时间相同 或者不同</h3><ul>\n<li>list  rpush lpop</li>\n<li>zset zrangebyscore key min max</li>\n</ul>\n<h3 id=\"mysql-主库写入还没有更新到读库的时候-怎么保证读的数据是最新的\"><a href=\"#mysql-主库写入还没有更新到读库的时候-怎么保证读的数据是最新的\" class=\"headerlink\" title=\"mysql 主库写入还没有更新到读库的时候 怎么保证读的数据是最新的\"></a>mysql 主库写入还没有更新到读库的时候 怎么保证读的数据是最新的</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"访问mi-com-的过程\"><a href=\"#访问mi-com-的过程\" class=\"headerlink\" title=\"访问mi.com 的过程\"></a>访问mi.com 的过程</h3><h3 id=\"rpc的协议\"><a href=\"#rpc的协议\" class=\"headerlink\" title=\"rpc的协议\"></a>rpc的协议</h3><h3 id=\"除了pb-http怎么返回数据\"><a href=\"#除了pb-http怎么返回数据\" class=\"headerlink\" title=\"除了pb http怎么返回数据\"></a>除了pb http怎么返回数据</h3><p>ASCII码</p>\n<h3 id=\"怎么保证消息队列不会重复处理\"><a href=\"#怎么保证消息队列不会重复处理\" class=\"headerlink\" title=\"怎么保证消息队列不会重复处理\"></a>怎么保证消息队列不会重复处理</h3><p>唯一keyid</p>\n<h3 id=\"mysql调优-的方法\"><a href=\"#mysql调优-的方法\" class=\"headerlink\" title=\"mysql调优 的方法\"></a>mysql调优 的方法</h3><h3 id=\"使用redis来实现定时器-如果所有用户等待时间相同-或者不同\"><a href=\"#使用redis来实现定时器-如果所有用户等待时间相同-或者不同\" class=\"headerlink\" title=\"使用redis来实现定时器 如果所有用户等待时间相同 或者不同\"></a>使用redis来实现定时器 如果所有用户等待时间相同 或者不同</h3><ul>\n<li>list  rpush lpop</li>\n<li>zset zrangebyscore key min max</li>\n</ul>\n<h3 id=\"mysql-主库写入还没有更新到读库的时候-怎么保证读的数据是最新的\"><a href=\"#mysql-主库写入还没有更新到读库的时候-怎么保证读的数据是最新的\" class=\"headerlink\" title=\"mysql 主库写入还没有更新到读库的时候 怎么保证读的数据是最新的\"></a>mysql 主库写入还没有更新到读库的时候 怎么保证读的数据是最新的</h3>"},{"title":"【面试复盘】滴滴面试","date":"2020-02-26T16:00:00.000Z","_content":"\n\n\n### 二叉树最长叶子结点路径之和\n\n``` go\ntype TreeNode struct {\n  Val \tint\n  Left  *TreeNode\n  Right *TreeNode\n}\n\nfunc longestWaySum(root *TreeNode) {\n  \n}\n\nfunc dfs(root *TreeNode, level, before int) (depth, sum int) {\n  \n}\n```\n\n\n\n### 大文件如何对字符串计数\n\n\n\n### 数据库的四种隔离级别 并举例说明\n\n\n\n### mysql的非sql命令 \n\n\n\n### binlog的格式\n\nbinlog分为三种格式\n\n1. statement 用来记录每一条修改的语句\n2. Row 不记录具体的语句 只记录哪条记录被修改 缺点 有些语句修改量过大， 记录不了\n3. Mixedlevel 混合使用，仅特殊语句 会记录 如sleep()函数， last_insert_id()，以及user-defined functions(udf\n\n\n\n### 为什么使用b+树\n\n**hash：**虽然可以快速定位，但是没有顺序，IO复杂度高。\n\n**二叉树：**树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。\n\n**红黑树：**树的高度随着数据量增加而增加，IO代价高。\n\n\n\n### 为什么树的高度影响IO代价\n\n尽管内存上读取速度快， 但是会可能因为断电等原因造成数据丢失，存在硬盘上可以保证数据的持久化，而每个数据节点代表一个磁盘块。\n\n### b+树范围查询\n\n有序的链表\n\n\n\n### 为什么使用连续自增主键\n\n结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率\n\n### 统计日志的qps\n\n``` shell\n# 实时统计\n## 方式一\ntail -f access.log | awk -F '[' '{print $2}' | awk 'BEGIN{key=\"\";count=0}{if(key==$1){count++}else{printf(\"%s\\t%d\\r\\n\", key, count);count=1;key=$1}}'\n \n## 方式二\ntail -f access.log | awk -F '[' '{print $2}' | awk '{print $1}' | uniq -c\n \n# 非实时按秒统计QPS\ncat access.log | awk -F '[' '{print $2}' | awk '{print $1}' | sort | uniq -c |sort -k1,1nr\n```\n\n\n\n### http四种方法 以及header头里会携带什么参数\n\n- put\n- get\n- post\n- delete\n- head\n- ...\n\n#### head头参数 \n\n- reffer\n- accept\n- cookie\n- Host\n- User-agent\n\n#### 请求报文包括\n\n- 请求行\n- 请求头\n- 空行\n- 请求体\n\n#### 状态码\n\n- 200\n- 301\n- 302\n- 500\n- 404\n\n\n\n### 下载文件\n\n\n\n### 访问mi.com的过程\n\n#### url缓存\n\n- 浏览器进行安全检查和访问控制\n\n#### dns查询\n\n- 检查浏览器缓存\n- 检查host文件\n- 路由器缓存\n- 首选dns解析服务器 \n- 根域名服务器查询\n\n#### tcp连接\n\n- 应用层 发送网络请求\n- 传输层 TCP传输报文\n- 网络层 ip查询mac地址\n- 链路层 以太网协议\n\n- 到达服务器时反转上述操作","source":"_posts/面试/复盘/2.27滴滴面试.md","raw":"---\ntitle: 【面试复盘】滴滴面试\ndate: 2020-02-27\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n### 二叉树最长叶子结点路径之和\n\n``` go\ntype TreeNode struct {\n  Val \tint\n  Left  *TreeNode\n  Right *TreeNode\n}\n\nfunc longestWaySum(root *TreeNode) {\n  \n}\n\nfunc dfs(root *TreeNode, level, before int) (depth, sum int) {\n  \n}\n```\n\n\n\n### 大文件如何对字符串计数\n\n\n\n### 数据库的四种隔离级别 并举例说明\n\n\n\n### mysql的非sql命令 \n\n\n\n### binlog的格式\n\nbinlog分为三种格式\n\n1. statement 用来记录每一条修改的语句\n2. Row 不记录具体的语句 只记录哪条记录被修改 缺点 有些语句修改量过大， 记录不了\n3. Mixedlevel 混合使用，仅特殊语句 会记录 如sleep()函数， last_insert_id()，以及user-defined functions(udf\n\n\n\n### 为什么使用b+树\n\n**hash：**虽然可以快速定位，但是没有顺序，IO复杂度高。\n\n**二叉树：**树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。\n\n**红黑树：**树的高度随着数据量增加而增加，IO代价高。\n\n\n\n### 为什么树的高度影响IO代价\n\n尽管内存上读取速度快， 但是会可能因为断电等原因造成数据丢失，存在硬盘上可以保证数据的持久化，而每个数据节点代表一个磁盘块。\n\n### b+树范围查询\n\n有序的链表\n\n\n\n### 为什么使用连续自增主键\n\n结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率\n\n### 统计日志的qps\n\n``` shell\n# 实时统计\n## 方式一\ntail -f access.log | awk -F '[' '{print $2}' | awk 'BEGIN{key=\"\";count=0}{if(key==$1){count++}else{printf(\"%s\\t%d\\r\\n\", key, count);count=1;key=$1}}'\n \n## 方式二\ntail -f access.log | awk -F '[' '{print $2}' | awk '{print $1}' | uniq -c\n \n# 非实时按秒统计QPS\ncat access.log | awk -F '[' '{print $2}' | awk '{print $1}' | sort | uniq -c |sort -k1,1nr\n```\n\n\n\n### http四种方法 以及header头里会携带什么参数\n\n- put\n- get\n- post\n- delete\n- head\n- ...\n\n#### head头参数 \n\n- reffer\n- accept\n- cookie\n- Host\n- User-agent\n\n#### 请求报文包括\n\n- 请求行\n- 请求头\n- 空行\n- 请求体\n\n#### 状态码\n\n- 200\n- 301\n- 302\n- 500\n- 404\n\n\n\n### 下载文件\n\n\n\n### 访问mi.com的过程\n\n#### url缓存\n\n- 浏览器进行安全检查和访问控制\n\n#### dns查询\n\n- 检查浏览器缓存\n- 检查host文件\n- 路由器缓存\n- 首选dns解析服务器 \n- 根域名服务器查询\n\n#### tcp连接\n\n- 应用层 发送网络请求\n- 传输层 TCP传输报文\n- 网络层 ip查询mac地址\n- 链路层 以太网协议\n\n- 到达服务器时反转上述操作","slug":"面试/复盘/2.27滴滴面试","published":1,"updated":"2020-02-29T10:31:17.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7cxr5de00015x8nfjw3ds7g","content":"<h3 id=\"二叉树最长叶子结点路径之和\"><a href=\"#二叉树最长叶子结点路径之和\" class=\"headerlink\" title=\"二叉树最长叶子结点路径之和\"></a>二叉树最长叶子结点路径之和</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Val \t<span class=\"keyword\">int</span></span><br><span class=\"line\">  Left  *TreeNode</span><br><span class=\"line\">  Right *TreeNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">longestWaySum</span><span class=\"params\">(root *TreeNode)</span></span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(root *TreeNode, level, before <span class=\"keyword\">int</span>)</span> <span class=\"params\">(depth, sum <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"大文件如何对字符串计数\"><a href=\"#大文件如何对字符串计数\" class=\"headerlink\" title=\"大文件如何对字符串计数\"></a>大文件如何对字符串计数</h3><h3 id=\"数据库的四种隔离级别-并举例说明\"><a href=\"#数据库的四种隔离级别-并举例说明\" class=\"headerlink\" title=\"数据库的四种隔离级别 并举例说明\"></a>数据库的四种隔离级别 并举例说明</h3><h3 id=\"mysql的非sql命令\"><a href=\"#mysql的非sql命令\" class=\"headerlink\" title=\"mysql的非sql命令\"></a>mysql的非sql命令</h3><h3 id=\"binlog的格式\"><a href=\"#binlog的格式\" class=\"headerlink\" title=\"binlog的格式\"></a>binlog的格式</h3><p>binlog分为三种格式</p>\n<ol>\n<li>statement 用来记录每一条修改的语句</li>\n<li>Row 不记录具体的语句 只记录哪条记录被修改 缺点 有些语句修改量过大， 记录不了</li>\n<li>Mixedlevel 混合使用，仅特殊语句 会记录 如sleep()函数， last_insert_id()，以及user-defined functions(udf</li>\n</ol>\n<h3 id=\"为什么使用b-树\"><a href=\"#为什么使用b-树\" class=\"headerlink\" title=\"为什么使用b+树\"></a>为什么使用b+树</h3><p><strong>hash：</strong>虽然可以快速定位，但是没有顺序，IO复杂度高。</p>\n<p><strong>二叉树：</strong>树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</p>\n<p><strong>红黑树：</strong>树的高度随着数据量增加而增加，IO代价高。</p>\n<h3 id=\"为什么树的高度影响IO代价\"><a href=\"#为什么树的高度影响IO代价\" class=\"headerlink\" title=\"为什么树的高度影响IO代价\"></a>为什么树的高度影响IO代价</h3><p>尽管内存上读取速度快， 但是会可能因为断电等原因造成数据丢失，存在硬盘上可以保证数据的持久化，而每个数据节点代表一个磁盘块。</p>\n<h3 id=\"b-树范围查询\"><a href=\"#b-树范围查询\" class=\"headerlink\" title=\"b+树范围查询\"></a>b+树范围查询</h3><p>有序的链表</p>\n<h3 id=\"为什么使用连续自增主键\"><a href=\"#为什么使用连续自增主键\" class=\"headerlink\" title=\"为什么使用连续自增主键\"></a>为什么使用连续自增主键</h3><p>结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率</p>\n<h3 id=\"统计日志的qps\"><a href=\"#统计日志的qps\" class=\"headerlink\" title=\"统计日志的qps\"></a>统计日志的qps</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 实时统计</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 方式一</span></span></span><br><span class=\"line\">tail -f access.log | awk -F '[' '&#123;print $2&#125;' | awk 'BEGIN&#123;key=\"\";count=0&#125;&#123;if(key==$1)&#123;count++&#125;else&#123;printf(\"%s\\t%d\\r\\n\", key, count);count=1;key=$1&#125;&#125;'</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 方式二</span></span></span><br><span class=\"line\">tail -f access.log | awk -F '[' '&#123;print $2&#125;' | awk '&#123;print $1&#125;' | uniq -c</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 非实时按秒统计QPS</span></span><br><span class=\"line\">cat access.log | awk -F '[' '&#123;print $2&#125;' | awk '&#123;print $1&#125;' | sort | uniq -c |sort -k1,1nr</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"http四种方法-以及header头里会携带什么参数\"><a href=\"#http四种方法-以及header头里会携带什么参数\" class=\"headerlink\" title=\"http四种方法 以及header头里会携带什么参数\"></a>http四种方法 以及header头里会携带什么参数</h3><ul>\n<li>put</li>\n<li>get</li>\n<li>post</li>\n<li>delete</li>\n<li>head</li>\n<li>…</li>\n</ul>\n<h4 id=\"head头参数\"><a href=\"#head头参数\" class=\"headerlink\" title=\"head头参数\"></a>head头参数</h4><ul>\n<li>reffer</li>\n<li>accept</li>\n<li>cookie</li>\n<li>Host</li>\n<li>User-agent</li>\n</ul>\n<h4 id=\"请求报文包括\"><a href=\"#请求报文包括\" class=\"headerlink\" title=\"请求报文包括\"></a>请求报文包括</h4><ul>\n<li>请求行</li>\n<li>请求头</li>\n<li>空行</li>\n<li>请求体</li>\n</ul>\n<h4 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h4><ul>\n<li>200</li>\n<li>301</li>\n<li>302</li>\n<li>500</li>\n<li>404</li>\n</ul>\n<h3 id=\"下载文件\"><a href=\"#下载文件\" class=\"headerlink\" title=\"下载文件\"></a>下载文件</h3><h3 id=\"访问mi-com的过程\"><a href=\"#访问mi-com的过程\" class=\"headerlink\" title=\"访问mi.com的过程\"></a>访问mi.com的过程</h3><h4 id=\"url缓存\"><a href=\"#url缓存\" class=\"headerlink\" title=\"url缓存\"></a>url缓存</h4><ul>\n<li>浏览器进行安全检查和访问控制</li>\n</ul>\n<h4 id=\"dns查询\"><a href=\"#dns查询\" class=\"headerlink\" title=\"dns查询\"></a>dns查询</h4><ul>\n<li>检查浏览器缓存</li>\n<li>检查host文件</li>\n<li>路由器缓存</li>\n<li>首选dns解析服务器 </li>\n<li>根域名服务器查询</li>\n</ul>\n<h4 id=\"tcp连接\"><a href=\"#tcp连接\" class=\"headerlink\" title=\"tcp连接\"></a>tcp连接</h4><ul>\n<li><p>应用层 发送网络请求</p>\n</li>\n<li><p>传输层 TCP传输报文</p>\n</li>\n<li><p>网络层 ip查询mac地址</p>\n</li>\n<li><p>链路层 以太网协议</p>\n</li>\n<li><p>到达服务器时反转上述操作</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"二叉树最长叶子结点路径之和\"><a href=\"#二叉树最长叶子结点路径之和\" class=\"headerlink\" title=\"二叉树最长叶子结点路径之和\"></a>二叉树最长叶子结点路径之和</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  Val \t<span class=\"keyword\">int</span></span><br><span class=\"line\">  Left  *TreeNode</span><br><span class=\"line\">  Right *TreeNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">longestWaySum</span><span class=\"params\">(root *TreeNode)</span></span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dfs</span><span class=\"params\">(root *TreeNode, level, before <span class=\"keyword\">int</span>)</span> <span class=\"params\">(depth, sum <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"大文件如何对字符串计数\"><a href=\"#大文件如何对字符串计数\" class=\"headerlink\" title=\"大文件如何对字符串计数\"></a>大文件如何对字符串计数</h3><h3 id=\"数据库的四种隔离级别-并举例说明\"><a href=\"#数据库的四种隔离级别-并举例说明\" class=\"headerlink\" title=\"数据库的四种隔离级别 并举例说明\"></a>数据库的四种隔离级别 并举例说明</h3><h3 id=\"mysql的非sql命令\"><a href=\"#mysql的非sql命令\" class=\"headerlink\" title=\"mysql的非sql命令\"></a>mysql的非sql命令</h3><h3 id=\"binlog的格式\"><a href=\"#binlog的格式\" class=\"headerlink\" title=\"binlog的格式\"></a>binlog的格式</h3><p>binlog分为三种格式</p>\n<ol>\n<li>statement 用来记录每一条修改的语句</li>\n<li>Row 不记录具体的语句 只记录哪条记录被修改 缺点 有些语句修改量过大， 记录不了</li>\n<li>Mixedlevel 混合使用，仅特殊语句 会记录 如sleep()函数， last_insert_id()，以及user-defined functions(udf</li>\n</ol>\n<h3 id=\"为什么使用b-树\"><a href=\"#为什么使用b-树\" class=\"headerlink\" title=\"为什么使用b+树\"></a>为什么使用b+树</h3><p><strong>hash：</strong>虽然可以快速定位，但是没有顺序，IO复杂度高。</p>\n<p><strong>二叉树：</strong>树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</p>\n<p><strong>红黑树：</strong>树的高度随着数据量增加而增加，IO代价高。</p>\n<h3 id=\"为什么树的高度影响IO代价\"><a href=\"#为什么树的高度影响IO代价\" class=\"headerlink\" title=\"为什么树的高度影响IO代价\"></a>为什么树的高度影响IO代价</h3><p>尽管内存上读取速度快， 但是会可能因为断电等原因造成数据丢失，存在硬盘上可以保证数据的持久化，而每个数据节点代表一个磁盘块。</p>\n<h3 id=\"b-树范围查询\"><a href=\"#b-树范围查询\" class=\"headerlink\" title=\"b+树范围查询\"></a>b+树范围查询</h3><p>有序的链表</p>\n<h3 id=\"为什么使用连续自增主键\"><a href=\"#为什么使用连续自增主键\" class=\"headerlink\" title=\"为什么使用连续自增主键\"></a>为什么使用连续自增主键</h3><p>结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率</p>\n<h3 id=\"统计日志的qps\"><a href=\"#统计日志的qps\" class=\"headerlink\" title=\"统计日志的qps\"></a>统计日志的qps</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 实时统计</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 方式一</span></span></span><br><span class=\"line\">tail -f access.log | awk -F '[' '&#123;print $2&#125;' | awk 'BEGIN&#123;key=\"\";count=0&#125;&#123;if(key==$1)&#123;count++&#125;else&#123;printf(\"%s\\t%d\\r\\n\", key, count);count=1;key=$1&#125;&#125;'</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 方式二</span></span></span><br><span class=\"line\">tail -f access.log | awk -F '[' '&#123;print $2&#125;' | awk '&#123;print $1&#125;' | uniq -c</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 非实时按秒统计QPS</span></span><br><span class=\"line\">cat access.log | awk -F '[' '&#123;print $2&#125;' | awk '&#123;print $1&#125;' | sort | uniq -c |sort -k1,1nr</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"http四种方法-以及header头里会携带什么参数\"><a href=\"#http四种方法-以及header头里会携带什么参数\" class=\"headerlink\" title=\"http四种方法 以及header头里会携带什么参数\"></a>http四种方法 以及header头里会携带什么参数</h3><ul>\n<li>put</li>\n<li>get</li>\n<li>post</li>\n<li>delete</li>\n<li>head</li>\n<li>…</li>\n</ul>\n<h4 id=\"head头参数\"><a href=\"#head头参数\" class=\"headerlink\" title=\"head头参数\"></a>head头参数</h4><ul>\n<li>reffer</li>\n<li>accept</li>\n<li>cookie</li>\n<li>Host</li>\n<li>User-agent</li>\n</ul>\n<h4 id=\"请求报文包括\"><a href=\"#请求报文包括\" class=\"headerlink\" title=\"请求报文包括\"></a>请求报文包括</h4><ul>\n<li>请求行</li>\n<li>请求头</li>\n<li>空行</li>\n<li>请求体</li>\n</ul>\n<h4 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h4><ul>\n<li>200</li>\n<li>301</li>\n<li>302</li>\n<li>500</li>\n<li>404</li>\n</ul>\n<h3 id=\"下载文件\"><a href=\"#下载文件\" class=\"headerlink\" title=\"下载文件\"></a>下载文件</h3><h3 id=\"访问mi-com的过程\"><a href=\"#访问mi-com的过程\" class=\"headerlink\" title=\"访问mi.com的过程\"></a>访问mi.com的过程</h3><h4 id=\"url缓存\"><a href=\"#url缓存\" class=\"headerlink\" title=\"url缓存\"></a>url缓存</h4><ul>\n<li>浏览器进行安全检查和访问控制</li>\n</ul>\n<h4 id=\"dns查询\"><a href=\"#dns查询\" class=\"headerlink\" title=\"dns查询\"></a>dns查询</h4><ul>\n<li>检查浏览器缓存</li>\n<li>检查host文件</li>\n<li>路由器缓存</li>\n<li>首选dns解析服务器 </li>\n<li>根域名服务器查询</li>\n</ul>\n<h4 id=\"tcp连接\"><a href=\"#tcp连接\" class=\"headerlink\" title=\"tcp连接\"></a>tcp连接</h4><ul>\n<li><p>应用层 发送网络请求</p>\n</li>\n<li><p>传输层 TCP传输报文</p>\n</li>\n<li><p>网络层 ip查询mac地址</p>\n</li>\n<li><p>链路层 以太网协议</p>\n</li>\n<li><p>到达服务器时反转上述操作</p>\n</li>\n</ul>\n"},{"title":"【面试复盘】滴滴面试","date":"2020-02-24T16:00:00.000Z","_content":"\n\n\n滴滴一面老哥人比较好，会帮忙思考一些问题\n\n\n\n## 基础\n\n\n\n\n\n### 发现cpu异常，应该如何处理\n\n\n\n### go程序有没有办法使用工具检测\n\n还有一个go自己的工具 `go tool trace`, 它有一个UI, 允许你查看你的程序和运行时的状况\n\n### linux 干掉占用内存过高的程序\n\n Top && sudo kill -9 pid\n\nPid 的ppid有可能还没被杀死\n\n-9 表示强制的参数\n\n\n\n### mysql有什么分库分表的中间件\n\n\n\n### go的context \n\n上下文 主要是对协程进行统一管理\n\ncontext包中还包含了四个用于繁衍Context值的函数，即：WithCancel、WithDeadline、WithTimeout和WithValue。\n\n\n\n### go的协程与线程的区别\n\n#### 协程\n\n- 协程由一个或者多个线程管理， 且协程调度发生在线程中\n- 可以被调度，调度策略由应用层代码实现\n- 高效， 节省了线程切换的成本\n- 占用内存少 线程的内存供多个goroutine使用\n\n### 锁和channel的区别\n\n\n\n### go的mutex是否是可重入锁\n\n\n\n### go的mutex是不是公平锁\n\n\n\n### 测试包的使用\n\n对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。*\n\n对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。\n\n对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。\n\n### MPG\n\n\n\n### 快排的稳定性为什么差\n\n因为每次都随机选择快排子\n\n### 优化快排\n\n\n\n### 多列索引的实现\n\nq\n\n### rabbitMQ底层怎么做存储\n\n\n\n### waitGroup的缺点","source":"_posts/面试/复盘/2.26滴滴面试.md","raw":"---\ntitle: 【面试复盘】滴滴面试\ndate: 2020-02-25\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n滴滴一面老哥人比较好，会帮忙思考一些问题\n\n\n\n## 基础\n\n\n\n\n\n### 发现cpu异常，应该如何处理\n\n\n\n### go程序有没有办法使用工具检测\n\n还有一个go自己的工具 `go tool trace`, 它有一个UI, 允许你查看你的程序和运行时的状况\n\n### linux 干掉占用内存过高的程序\n\n Top && sudo kill -9 pid\n\nPid 的ppid有可能还没被杀死\n\n-9 表示强制的参数\n\n\n\n### mysql有什么分库分表的中间件\n\n\n\n### go的context \n\n上下文 主要是对协程进行统一管理\n\ncontext包中还包含了四个用于繁衍Context值的函数，即：WithCancel、WithDeadline、WithTimeout和WithValue。\n\n\n\n### go的协程与线程的区别\n\n#### 协程\n\n- 协程由一个或者多个线程管理， 且协程调度发生在线程中\n- 可以被调度，调度策略由应用层代码实现\n- 高效， 节省了线程切换的成本\n- 占用内存少 线程的内存供多个goroutine使用\n\n### 锁和channel的区别\n\n\n\n### go的mutex是否是可重入锁\n\n\n\n### go的mutex是不是公平锁\n\n\n\n### 测试包的使用\n\n对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。*\n\n对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。\n\n对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。\n\n### MPG\n\n\n\n### 快排的稳定性为什么差\n\n因为每次都随机选择快排子\n\n### 优化快排\n\n\n\n### 多列索引的实现\n\nq\n\n### rabbitMQ底层怎么做存储\n\n\n\n### waitGroup的缺点","slug":"面试/复盘/2.26滴滴面试","published":1,"updated":"2020-03-01T02:49:45.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7cxr5dg00035x8nej0hbp1d","content":"<p>滴滴一面老哥人比较好，会帮忙思考一些问题</p>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"发现cpu异常，应该如何处理\"><a href=\"#发现cpu异常，应该如何处理\" class=\"headerlink\" title=\"发现cpu异常，应该如何处理\"></a>发现cpu异常，应该如何处理</h3><h3 id=\"go程序有没有办法使用工具检测\"><a href=\"#go程序有没有办法使用工具检测\" class=\"headerlink\" title=\"go程序有没有办法使用工具检测\"></a>go程序有没有办法使用工具检测</h3><p>还有一个go自己的工具 <code>go tool trace</code>, 它有一个UI, 允许你查看你的程序和运行时的状况</p>\n<h3 id=\"linux-干掉占用内存过高的程序\"><a href=\"#linux-干掉占用内存过高的程序\" class=\"headerlink\" title=\"linux 干掉占用内存过高的程序\"></a>linux 干掉占用内存过高的程序</h3><p> Top &amp;&amp; sudo kill -9 pid</p>\n<p>Pid 的ppid有可能还没被杀死</p>\n<p>-9 表示强制的参数</p>\n<h3 id=\"mysql有什么分库分表的中间件\"><a href=\"#mysql有什么分库分表的中间件\" class=\"headerlink\" title=\"mysql有什么分库分表的中间件\"></a>mysql有什么分库分表的中间件</h3><h3 id=\"go的context\"><a href=\"#go的context\" class=\"headerlink\" title=\"go的context\"></a>go的context</h3><p>上下文 主要是对协程进行统一管理</p>\n<p>context包中还包含了四个用于繁衍Context值的函数，即：WithCancel、WithDeadline、WithTimeout和WithValue。</p>\n<h3 id=\"go的协程与线程的区别\"><a href=\"#go的协程与线程的区别\" class=\"headerlink\" title=\"go的协程与线程的区别\"></a>go的协程与线程的区别</h3><h4 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h4><ul>\n<li>协程由一个或者多个线程管理， 且协程调度发生在线程中</li>\n<li>可以被调度，调度策略由应用层代码实现</li>\n<li>高效， 节省了线程切换的成本</li>\n<li>占用内存少 线程的内存供多个goroutine使用</li>\n</ul>\n<h3 id=\"锁和channel的区别\"><a href=\"#锁和channel的区别\" class=\"headerlink\" title=\"锁和channel的区别\"></a>锁和channel的区别</h3><h3 id=\"go的mutex是否是可重入锁\"><a href=\"#go的mutex是否是可重入锁\" class=\"headerlink\" title=\"go的mutex是否是可重入锁\"></a>go的mutex是否是可重入锁</h3><h3 id=\"go的mutex是不是公平锁\"><a href=\"#go的mutex是不是公平锁\" class=\"headerlink\" title=\"go的mutex是不是公平锁\"></a>go的mutex是不是公平锁</h3><h3 id=\"测试包的使用\"><a href=\"#测试包的使用\" class=\"headerlink\" title=\"测试包的使用\"></a>测试包的使用</h3><p>对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个<em>testing.T类型的参数声明。</em></p>\n<p>对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。</p>\n<p>对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。</p>\n<h3 id=\"MPG\"><a href=\"#MPG\" class=\"headerlink\" title=\"MPG\"></a>MPG</h3><h3 id=\"快排的稳定性为什么差\"><a href=\"#快排的稳定性为什么差\" class=\"headerlink\" title=\"快排的稳定性为什么差\"></a>快排的稳定性为什么差</h3><p>因为每次都随机选择快排子</p>\n<h3 id=\"优化快排\"><a href=\"#优化快排\" class=\"headerlink\" title=\"优化快排\"></a>优化快排</h3><h3 id=\"多列索引的实现\"><a href=\"#多列索引的实现\" class=\"headerlink\" title=\"多列索引的实现\"></a>多列索引的实现</h3><p>q</p>\n<h3 id=\"rabbitMQ底层怎么做存储\"><a href=\"#rabbitMQ底层怎么做存储\" class=\"headerlink\" title=\"rabbitMQ底层怎么做存储\"></a>rabbitMQ底层怎么做存储</h3><h3 id=\"waitGroup的缺点\"><a href=\"#waitGroup的缺点\" class=\"headerlink\" title=\"waitGroup的缺点\"></a>waitGroup的缺点</h3>","site":{"data":{}},"excerpt":"","more":"<p>滴滴一面老哥人比较好，会帮忙思考一些问题</p>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"发现cpu异常，应该如何处理\"><a href=\"#发现cpu异常，应该如何处理\" class=\"headerlink\" title=\"发现cpu异常，应该如何处理\"></a>发现cpu异常，应该如何处理</h3><h3 id=\"go程序有没有办法使用工具检测\"><a href=\"#go程序有没有办法使用工具检测\" class=\"headerlink\" title=\"go程序有没有办法使用工具检测\"></a>go程序有没有办法使用工具检测</h3><p>还有一个go自己的工具 <code>go tool trace</code>, 它有一个UI, 允许你查看你的程序和运行时的状况</p>\n<h3 id=\"linux-干掉占用内存过高的程序\"><a href=\"#linux-干掉占用内存过高的程序\" class=\"headerlink\" title=\"linux 干掉占用内存过高的程序\"></a>linux 干掉占用内存过高的程序</h3><p> Top &amp;&amp; sudo kill -9 pid</p>\n<p>Pid 的ppid有可能还没被杀死</p>\n<p>-9 表示强制的参数</p>\n<h3 id=\"mysql有什么分库分表的中间件\"><a href=\"#mysql有什么分库分表的中间件\" class=\"headerlink\" title=\"mysql有什么分库分表的中间件\"></a>mysql有什么分库分表的中间件</h3><h3 id=\"go的context\"><a href=\"#go的context\" class=\"headerlink\" title=\"go的context\"></a>go的context</h3><p>上下文 主要是对协程进行统一管理</p>\n<p>context包中还包含了四个用于繁衍Context值的函数，即：WithCancel、WithDeadline、WithTimeout和WithValue。</p>\n<h3 id=\"go的协程与线程的区别\"><a href=\"#go的协程与线程的区别\" class=\"headerlink\" title=\"go的协程与线程的区别\"></a>go的协程与线程的区别</h3><h4 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h4><ul>\n<li>协程由一个或者多个线程管理， 且协程调度发生在线程中</li>\n<li>可以被调度，调度策略由应用层代码实现</li>\n<li>高效， 节省了线程切换的成本</li>\n<li>占用内存少 线程的内存供多个goroutine使用</li>\n</ul>\n<h3 id=\"锁和channel的区别\"><a href=\"#锁和channel的区别\" class=\"headerlink\" title=\"锁和channel的区别\"></a>锁和channel的区别</h3><h3 id=\"go的mutex是否是可重入锁\"><a href=\"#go的mutex是否是可重入锁\" class=\"headerlink\" title=\"go的mutex是否是可重入锁\"></a>go的mutex是否是可重入锁</h3><h3 id=\"go的mutex是不是公平锁\"><a href=\"#go的mutex是不是公平锁\" class=\"headerlink\" title=\"go的mutex是不是公平锁\"></a>go的mutex是不是公平锁</h3><h3 id=\"测试包的使用\"><a href=\"#测试包的使用\" class=\"headerlink\" title=\"测试包的使用\"></a>测试包的使用</h3><p>对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个<em>testing.T类型的参数声明。</em></p>\n<p>对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。</p>\n<p>对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。</p>\n<h3 id=\"MPG\"><a href=\"#MPG\" class=\"headerlink\" title=\"MPG\"></a>MPG</h3><h3 id=\"快排的稳定性为什么差\"><a href=\"#快排的稳定性为什么差\" class=\"headerlink\" title=\"快排的稳定性为什么差\"></a>快排的稳定性为什么差</h3><p>因为每次都随机选择快排子</p>\n<h3 id=\"优化快排\"><a href=\"#优化快排\" class=\"headerlink\" title=\"优化快排\"></a>优化快排</h3><h3 id=\"多列索引的实现\"><a href=\"#多列索引的实现\" class=\"headerlink\" title=\"多列索引的实现\"></a>多列索引的实现</h3><p>q</p>\n<h3 id=\"rabbitMQ底层怎么做存储\"><a href=\"#rabbitMQ底层怎么做存储\" class=\"headerlink\" title=\"rabbitMQ底层怎么做存储\"></a>rabbitMQ底层怎么做存储</h3><h3 id=\"waitGroup的缺点\"><a href=\"#waitGroup的缺点\" class=\"headerlink\" title=\"waitGroup的缺点\"></a>waitGroup的缺点</h3>"},{"title":"【面试复盘】头条面试","date":"2020-02-29T16:00:00.000Z","_content":"\n\n\n## 一面\n\n### 具体的rpc调用过程 \n\n\n\n### 消息队列的使用过程\n\n\n\n### 如果一个事务里想要操作两个不同数据库的数据，怎么操作\n\n\n\n### redis 分布式锁 的使用 \n\n\n\n### redis 过期机制的\n\n\n\n### sql：找出一个班里的哪个年龄的人最多\n\n``` sql\nselect age from user group by age  order by count(age) desc limit 1\n```\n\n\n\n### 算法： 给定一个数组，0~i单调递增，i~n单调递减，其中n为数组长度，i未知。\n\n``` go\n去重后元素的个数\ninput: [1, 3, 5, 100, 2, 1]\noutput: 5\n不使用额外的空间，不改变原数组\ninput: 1  2\noutput: 0  4\n\n\nfunc findT(target int, arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    l, r := 0, len(arr)-1\n    for l <= r {\n        mid := l + (r-l)/2\n        if target == arr[mid] {\n            return mid\n        }\n        d := IsD(arr, mid)\n        if d = 1 {\n            if target > arr[l] && arr[mid] > target {\n                r = mid - 1\n            } else {\n                l = mid + 1\n            }\n            \n        } else if d == -1 {\n            if target < arr[mid] && arr[r] < target {\n                l = mid + 1\n            } else {\n                r = mid -1\n            }\n        } else {\n            res := findTInArea(arr, l, mid-1, target, 1)\n            if res != -1 {\n                return res\n            }\n            res = findTInArea(arr, mid+1, r, target, -1 )\n            return res\n        }\n    }\n    if arr[mid] == target {\n        return mid\n    }\n    return -1\n}\n// 判断是否单调 且单调的方向\nfunc IsD(arr []int, index int) int {\n    if index > 0 && index < len(arr) - 1 {\n        if arr[index] > arr[index-1] && arr[index] < arr[index + 1] {\n            return 1\n        }\n        if arr[index] < arr[index-1] && arr[index] > arr[index + 1] {\n            return -1\n        }\n    }\n    if index == 0  {\n        return 1\n    }\n    if index == len(arr) - 1 {\n        return -1\n    }\n    return 0\n}\n// 常规二分查找\nfunc findTInArea(arr int[], l, r , target, ty int) int{\n    if len(arr) == 0 {\n        return -1\n    }\n    l, r := 0, len(arr)-1\n    for l <= r {\n        mid = l + (r-l)/2\n        if arr[mid] == target {\n            \n        }\n    }\n}\n```\n\n\n\n## 二面\n\n\n\n### context使用 及简单代码\n\n``` go\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc)\nfunc WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)\nfunc WithValue(parent Context, key, val interface{}) Context\nfunc Background() Context\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo watch(ctx,\"【监控1】\")\n\tgo watch(ctx,\"【监控2】\")\n\tgo watch(ctx,\"【监控3】\")\n\n\ttime.Sleep(10 * time.Second)\n\tfmt.Println(\"可以了，通知监控停止\")\n\tcancel()\n\t//为了检测监控过是否停止，如果没有监控输出，就表示停止了\n\ttime.Sleep(5 * time.Second)\n}\n\nfunc watch(ctx context.Context, name string) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(name,\"监控退出，停止了...\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(name,\"goroutine监控中...\")\n\t\t\ttime.Sleep(2 * time.Second)\n\t\t}\n\t}\n}\n```\n\n\n\n### 实现简单的消息队列 并说出优化方向\n\n优化方向\n\n- 增加消息的容量\n- 消息存入硬盘，保证高可用\n- 如果消费阻塞的话，另一方面，增加消费者数目\n\n``` go\n\n\ntype Producer struct {\n    messages [9]chan string\n}\n\ntype Consumer struct {\n    messages [9]chan string\n}\nfunc (p *Producer) init(message [9]chan string) {\n    p.messages = message\n}\nfunc (p *Producer) send(message string) {\n    p.messages <- message\n}\nfunc (c *Consumer) init (message [9]chan string) {\n    c.messages = message\n}\nfunc (c *Receive) receive() string {\n    for {\n        switch {\n        case <-c.message: \n            return c.message\n        default: return \"\"\n        }\n        sleep(100)\n    }\n}\nfunc main() {\n    message := [9]chan string\n    var prod Producer\n    var cons Consumer\n    prod.init(message)\n    cons.init(message)\n    for i:=0; i<100;i++ {\n        go func() {\n            prod.send(\"test\")\n        }\n    }\n    s := cons.receive()\n    fmt.Println(s)\n}\n```\n\n\n\n### 防刷的做法 \n\n时间维度和ip维度\n\n### 【算法题】 k个一组 反转链表\n\n``` go\n\n```\n\n\n\n## 三面\n\n\n\n### 【系统设计题】设计一个抢红包的结构\n\n``` \n页面-后端\n- 长连接 \n- 短链接 \n- 每次点击时提交 or 出完结果后提交\n- API\n- Redis\n- MQ -> 使用mq消费，异步，削峰，解耦\n\n```\n\n\n\n### 【系统设计题】 设计一个唯一ID生成器\n\n- int64的数字\n- 唯一\n- 高并发\n\n``` \n雪花算法\n32位秒级时间戳+16位自增id+5位机器码\n42位毫秒级时间戳+10机器码+12bit序列号\n```\n\n\n\n### 【算法题】给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3\n\n``` go\nvar location [256]int{}\nfunc indexOfStringNoRepeat(s string, target rune[]) int {\n    for i := range location {\n        location[i] = -1\n    }\n    rs := []rune(s)\n    ma := make(map[rune]int)\n    for i := range target {\n        ma[target] = 0\n    }\n    // shooted 目前已有的未重复字符\n    left, shooted := 0, 0\n    for i := 0; i<len(rs); i++ {\n        // 不存在该字符\n        if _, ok := ma[rs[i]]; !ok {\n            before = left \n            left = location[rs[i]] + 1\n            updateLocation(rs, before, left)\n            continue\n        }\n        // 该字符\n        if location[rs[i]] != -1 {\n            if location[rs[i]] >= left {\n                before = left\n                left = location[rs[i]] + 1\n                shooted\n                updateLocation(rs, before, left)\n            }\n        } else {\n            shooted ++\n            if shooted == len(target) {\n                return left\n            }\n        }\n        location[rs[i]] ++\n    }\n    return -1\n}\nfunc updateLocations(rs []rune, l, r int) {\n    for l < r {\n        location[rs[l]] = -1\n        l ++\n    }\n    return \n}\n\n```\n\n","source":"_posts/面试/复盘/3.1头条面试.md","raw":"---\ntitle: 【面试复盘】头条面试\ndate: 2020-03-1\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n## 一面\n\n### 具体的rpc调用过程 \n\n\n\n### 消息队列的使用过程\n\n\n\n### 如果一个事务里想要操作两个不同数据库的数据，怎么操作\n\n\n\n### redis 分布式锁 的使用 \n\n\n\n### redis 过期机制的\n\n\n\n### sql：找出一个班里的哪个年龄的人最多\n\n``` sql\nselect age from user group by age  order by count(age) desc limit 1\n```\n\n\n\n### 算法： 给定一个数组，0~i单调递增，i~n单调递减，其中n为数组长度，i未知。\n\n``` go\n去重后元素的个数\ninput: [1, 3, 5, 100, 2, 1]\noutput: 5\n不使用额外的空间，不改变原数组\ninput: 1  2\noutput: 0  4\n\n\nfunc findT(target int, arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    l, r := 0, len(arr)-1\n    for l <= r {\n        mid := l + (r-l)/2\n        if target == arr[mid] {\n            return mid\n        }\n        d := IsD(arr, mid)\n        if d = 1 {\n            if target > arr[l] && arr[mid] > target {\n                r = mid - 1\n            } else {\n                l = mid + 1\n            }\n            \n        } else if d == -1 {\n            if target < arr[mid] && arr[r] < target {\n                l = mid + 1\n            } else {\n                r = mid -1\n            }\n        } else {\n            res := findTInArea(arr, l, mid-1, target, 1)\n            if res != -1 {\n                return res\n            }\n            res = findTInArea(arr, mid+1, r, target, -1 )\n            return res\n        }\n    }\n    if arr[mid] == target {\n        return mid\n    }\n    return -1\n}\n// 判断是否单调 且单调的方向\nfunc IsD(arr []int, index int) int {\n    if index > 0 && index < len(arr) - 1 {\n        if arr[index] > arr[index-1] && arr[index] < arr[index + 1] {\n            return 1\n        }\n        if arr[index] < arr[index-1] && arr[index] > arr[index + 1] {\n            return -1\n        }\n    }\n    if index == 0  {\n        return 1\n    }\n    if index == len(arr) - 1 {\n        return -1\n    }\n    return 0\n}\n// 常规二分查找\nfunc findTInArea(arr int[], l, r , target, ty int) int{\n    if len(arr) == 0 {\n        return -1\n    }\n    l, r := 0, len(arr)-1\n    for l <= r {\n        mid = l + (r-l)/2\n        if arr[mid] == target {\n            \n        }\n    }\n}\n```\n\n\n\n## 二面\n\n\n\n### context使用 及简单代码\n\n``` go\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc)\nfunc WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)\nfunc WithValue(parent Context, key, val interface{}) Context\nfunc Background() Context\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo watch(ctx,\"【监控1】\")\n\tgo watch(ctx,\"【监控2】\")\n\tgo watch(ctx,\"【监控3】\")\n\n\ttime.Sleep(10 * time.Second)\n\tfmt.Println(\"可以了，通知监控停止\")\n\tcancel()\n\t//为了检测监控过是否停止，如果没有监控输出，就表示停止了\n\ttime.Sleep(5 * time.Second)\n}\n\nfunc watch(ctx context.Context, name string) {\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tfmt.Println(name,\"监控退出，停止了...\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(name,\"goroutine监控中...\")\n\t\t\ttime.Sleep(2 * time.Second)\n\t\t}\n\t}\n}\n```\n\n\n\n### 实现简单的消息队列 并说出优化方向\n\n优化方向\n\n- 增加消息的容量\n- 消息存入硬盘，保证高可用\n- 如果消费阻塞的话，另一方面，增加消费者数目\n\n``` go\n\n\ntype Producer struct {\n    messages [9]chan string\n}\n\ntype Consumer struct {\n    messages [9]chan string\n}\nfunc (p *Producer) init(message [9]chan string) {\n    p.messages = message\n}\nfunc (p *Producer) send(message string) {\n    p.messages <- message\n}\nfunc (c *Consumer) init (message [9]chan string) {\n    c.messages = message\n}\nfunc (c *Receive) receive() string {\n    for {\n        switch {\n        case <-c.message: \n            return c.message\n        default: return \"\"\n        }\n        sleep(100)\n    }\n}\nfunc main() {\n    message := [9]chan string\n    var prod Producer\n    var cons Consumer\n    prod.init(message)\n    cons.init(message)\n    for i:=0; i<100;i++ {\n        go func() {\n            prod.send(\"test\")\n        }\n    }\n    s := cons.receive()\n    fmt.Println(s)\n}\n```\n\n\n\n### 防刷的做法 \n\n时间维度和ip维度\n\n### 【算法题】 k个一组 反转链表\n\n``` go\n\n```\n\n\n\n## 三面\n\n\n\n### 【系统设计题】设计一个抢红包的结构\n\n``` \n页面-后端\n- 长连接 \n- 短链接 \n- 每次点击时提交 or 出完结果后提交\n- API\n- Redis\n- MQ -> 使用mq消费，异步，削峰，解耦\n\n```\n\n\n\n### 【系统设计题】 设计一个唯一ID生成器\n\n- int64的数字\n- 唯一\n- 高并发\n\n``` \n雪花算法\n32位秒级时间戳+16位自增id+5位机器码\n42位毫秒级时间戳+10机器码+12bit序列号\n```\n\n\n\n### 【算法题】给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3\n\n``` go\nvar location [256]int{}\nfunc indexOfStringNoRepeat(s string, target rune[]) int {\n    for i := range location {\n        location[i] = -1\n    }\n    rs := []rune(s)\n    ma := make(map[rune]int)\n    for i := range target {\n        ma[target] = 0\n    }\n    // shooted 目前已有的未重复字符\n    left, shooted := 0, 0\n    for i := 0; i<len(rs); i++ {\n        // 不存在该字符\n        if _, ok := ma[rs[i]]; !ok {\n            before = left \n            left = location[rs[i]] + 1\n            updateLocation(rs, before, left)\n            continue\n        }\n        // 该字符\n        if location[rs[i]] != -1 {\n            if location[rs[i]] >= left {\n                before = left\n                left = location[rs[i]] + 1\n                shooted\n                updateLocation(rs, before, left)\n            }\n        } else {\n            shooted ++\n            if shooted == len(target) {\n                return left\n            }\n        }\n        location[rs[i]] ++\n    }\n    return -1\n}\nfunc updateLocations(rs []rune, l, r int) {\n    for l < r {\n        location[rs[l]] = -1\n        l ++\n    }\n    return \n}\n\n```\n\n","slug":"面试/复盘/3.1头条面试","published":1,"updated":"2020-03-04T07:40:01.005Z","_id":"ck7cxr5di00055x8n1ehw8jio","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"具体的rpc调用过程\"><a href=\"#具体的rpc调用过程\" class=\"headerlink\" title=\"具体的rpc调用过程\"></a>具体的rpc调用过程</h3><h3 id=\"消息队列的使用过程\"><a href=\"#消息队列的使用过程\" class=\"headerlink\" title=\"消息队列的使用过程\"></a>消息队列的使用过程</h3><h3 id=\"如果一个事务里想要操作两个不同数据库的数据，怎么操作\"><a href=\"#如果一个事务里想要操作两个不同数据库的数据，怎么操作\" class=\"headerlink\" title=\"如果一个事务里想要操作两个不同数据库的数据，怎么操作\"></a>如果一个事务里想要操作两个不同数据库的数据，怎么操作</h3><h3 id=\"redis-分布式锁-的使用\"><a href=\"#redis-分布式锁-的使用\" class=\"headerlink\" title=\"redis 分布式锁 的使用\"></a>redis 分布式锁 的使用</h3><h3 id=\"redis-过期机制的\"><a href=\"#redis-过期机制的\" class=\"headerlink\" title=\"redis 过期机制的\"></a>redis 过期机制的</h3><h3 id=\"sql：找出一个班里的哪个年龄的人最多\"><a href=\"#sql：找出一个班里的哪个年龄的人最多\" class=\"headerlink\" title=\"sql：找出一个班里的哪个年龄的人最多\"></a>sql：找出一个班里的哪个年龄的人最多</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> age <span class=\"keyword\">from</span> <span class=\"keyword\">user</span> <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> age  <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"keyword\">count</span>(age) <span class=\"keyword\">desc</span> <span class=\"keyword\">limit</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"算法：-给定一个数组，0i单调递增，in单调递减，其中n为数组长度，i未知。\"><a href=\"#算法：-给定一个数组，0i单调递增，in单调递减，其中n为数组长度，i未知。\" class=\"headerlink\" title=\"算法： 给定一个数组，0i单调递增，in单调递减，其中n为数组长度，i未知。\"></a>算法： 给定一个数组，0<del>i单调递增，i</del>n单调递减，其中n为数组长度，i未知。</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">去重后元素的个数</span><br><span class=\"line\">input: [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">100</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">output: <span class=\"number\">5</span></span><br><span class=\"line\">不使用额外的空间，不改变原数组</span><br><span class=\"line\">input: <span class=\"number\">1</span>  <span class=\"number\">2</span></span><br><span class=\"line\">output: <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findT</span><span class=\"params\">(target <span class=\"keyword\">int</span>, arr []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(arr) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(arr)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> l &lt;= r &#123;</span><br><span class=\"line\">        mid := l + (r-l)/<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == arr[mid] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        d := IsD(arr, mid)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d = <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; arr[l] &amp;&amp; arr[mid] &gt; target &#123;</span><br><span class=\"line\">                r = mid - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> d == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &lt; arr[mid] &amp;&amp; arr[r] &lt; target &#123;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                r = mid <span class=\"number\">-1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res := findTInArea(arr, l, mid<span class=\"number\">-1</span>, target, <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> res != <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = findTInArea(arr, mid+<span class=\"number\">1</span>, r, target, <span class=\"number\">-1</span> )</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> arr[mid] == target &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断是否单调 且单调的方向</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsD</span><span class=\"params\">(arr []<span class=\"keyword\">int</span>, index <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> index &gt; <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">len</span>(arr) - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[index] &gt; arr[index<span class=\"number\">-1</span>] &amp;&amp; arr[index] &lt; arr[index + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[index] &lt; arr[index<span class=\"number\">-1</span>] &amp;&amp; arr[index] &gt; arr[index + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> index == <span class=\"number\">0</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> index == <span class=\"built_in\">len</span>(arr) - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 常规二分查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findTInArea</span><span class=\"params\">(arr <span class=\"keyword\">int</span>[], l, r , target, ty <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(arr) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(arr)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> l &lt;= r &#123;</span><br><span class=\"line\">        mid = l + (r-l)/<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[mid] == target &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><h3 id=\"context使用-及简单代码\"><a href=\"#context使用-及简单代码\" class=\"headerlink\" title=\"context使用 及简单代码\"></a>context使用 及简单代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithCancel</span><span class=\"params\">(parent Context)</span> <span class=\"params\">(ctx Context, cancel CancelFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithDeadline</span><span class=\"params\">(parent Context, deadline time.Time)</span> <span class=\"params\">(Context, CancelFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithTimeout</span><span class=\"params\">(parent Context, timeout time.Duration)</span> <span class=\"params\">(Context, CancelFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithValue</span><span class=\"params\">(parent Context, key, val <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Context</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Background</span><span class=\"params\">()</span> <span class=\"title\">Context</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tctx, cancel := context.WithCancel(context.Background())</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> watch(ctx,<span class=\"string\">\"【监控1】\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> watch(ctx,<span class=\"string\">\"【监控2】\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> watch(ctx,<span class=\"string\">\"【监控3】\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">10</span> * time.Second)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"可以了，通知监控停止\"</span>)</span><br><span class=\"line\">\tcancel()</span><br><span class=\"line\">\t<span class=\"comment\">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">watch</span><span class=\"params\">(ctx context.Context, name <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\tfmt.Println(name,<span class=\"string\">\"监控退出，停止了...\"</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tfmt.Println(name,<span class=\"string\">\"goroutine监控中...\"</span>)</span><br><span class=\"line\">\t\t\ttime.Sleep(<span class=\"number\">2</span> * time.Second)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"实现简单的消息队列-并说出优化方向\"><a href=\"#实现简单的消息队列-并说出优化方向\" class=\"headerlink\" title=\"实现简单的消息队列 并说出优化方向\"></a>实现简单的消息队列 并说出优化方向</h3><p>优化方向</p>\n<ul>\n<li>增加消息的容量</li>\n<li>消息存入硬盘，保证高可用</li>\n<li>如果消费阻塞的话，另一方面，增加消费者数目</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Producer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    messages [<span class=\"number\">9</span>]<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Consumer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    messages [<span class=\"number\">9</span>]<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Producer)</span> <span class=\"title\">init</span><span class=\"params\">(message [9]<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    p.messages = message</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Producer)</span> <span class=\"title\">send</span><span class=\"params\">(message <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    p.messages &lt;- message</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Consumer)</span> <span class=\"title\">init</span> <span class=\"params\">(message [9]<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    c.messages = message</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Receive)</span> <span class=\"title\">receive</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-c.message: </span><br><span class=\"line\">            <span class=\"keyword\">return</span> c.message</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sleep(<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    message := [<span class=\"number\">9</span>]<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> prod Producer</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cons Consumer</span><br><span class=\"line\">    prod.init(message)</span><br><span class=\"line\">    cons.init(message)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>;i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            prod.send(<span class=\"string\">\"test\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s := cons.receive()</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"防刷的做法\"><a href=\"#防刷的做法\" class=\"headerlink\" title=\"防刷的做法\"></a>防刷的做法</h3><p>时间维度和ip维度</p>\n<h3 id=\"【算法题】-k个一组-反转链表\"><a href=\"#【算法题】-k个一组-反转链表\" class=\"headerlink\" title=\"【算法题】 k个一组 反转链表\"></a>【算法题】 k个一组 反转链表</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h2><h3 id=\"【系统设计题】设计一个抢红包的结构\"><a href=\"#【系统设计题】设计一个抢红包的结构\" class=\"headerlink\" title=\"【系统设计题】设计一个抢红包的结构\"></a>【系统设计题】设计一个抢红包的结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">页面-后端</span><br><span class=\"line\">- 长连接 </span><br><span class=\"line\">- 短链接 </span><br><span class=\"line\">- 每次点击时提交 or 出完结果后提交</span><br><span class=\"line\">- API</span><br><span class=\"line\">- Redis</span><br><span class=\"line\">- MQ -&gt; 使用mq消费，异步，削峰，解耦</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"【系统设计题】-设计一个唯一ID生成器\"><a href=\"#【系统设计题】-设计一个唯一ID生成器\" class=\"headerlink\" title=\"【系统设计题】 设计一个唯一ID生成器\"></a>【系统设计题】 设计一个唯一ID生成器</h3><ul>\n<li>int64的数字</li>\n<li>唯一</li>\n<li>高并发</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">雪花算法</span><br><span class=\"line\">32位秒级时间戳+16位自增id+5位机器码</span><br><span class=\"line\">42位毫秒级时间戳+10机器码+12bit序列号</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"【算法题】给定m个不重复的字符-a-b-c-d-，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3\"><a href=\"#【算法题】给定m个不重复的字符-a-b-c-d-，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3\" class=\"headerlink\" title=\"【算法题】给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3\"></a>【算法题】给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> location [<span class=\"number\">256</span>]<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">indexOfStringNoRepeat</span><span class=\"params\">(s <span class=\"keyword\">string</span>, target <span class=\"keyword\">rune</span>[])</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> location &#123;</span><br><span class=\"line\">        location[i] = <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rs := []<span class=\"keyword\">rune</span>(s)</span><br><span class=\"line\">    ma := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">rune</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> target &#123;</span><br><span class=\"line\">        ma[target] = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// shooted 目前已有的未重复字符</span></span><br><span class=\"line\">    left, shooted := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(rs); i++ &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不存在该字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> _, ok := ma[rs[i]]; !ok &#123;</span><br><span class=\"line\">            before = left </span><br><span class=\"line\">            left = location[rs[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">            updateLocation(rs, before, left)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 该字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> location[rs[i]] != <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> location[rs[i]] &gt;= left &#123;</span><br><span class=\"line\">                before = left</span><br><span class=\"line\">                left = location[rs[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">                shooted</span><br><span class=\"line\">                updateLocation(rs, before, left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            shooted ++</span><br><span class=\"line\">            <span class=\"keyword\">if</span> shooted == <span class=\"built_in\">len</span>(target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> left</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location[rs[i]] ++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateLocations</span><span class=\"params\">(rs []<span class=\"keyword\">rune</span>, l, r <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> l &lt; r &#123;</span><br><span class=\"line\">        location[rs[l]] = <span class=\"number\">-1</span></span><br><span class=\"line\">        l ++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"具体的rpc调用过程\"><a href=\"#具体的rpc调用过程\" class=\"headerlink\" title=\"具体的rpc调用过程\"></a>具体的rpc调用过程</h3><h3 id=\"消息队列的使用过程\"><a href=\"#消息队列的使用过程\" class=\"headerlink\" title=\"消息队列的使用过程\"></a>消息队列的使用过程</h3><h3 id=\"如果一个事务里想要操作两个不同数据库的数据，怎么操作\"><a href=\"#如果一个事务里想要操作两个不同数据库的数据，怎么操作\" class=\"headerlink\" title=\"如果一个事务里想要操作两个不同数据库的数据，怎么操作\"></a>如果一个事务里想要操作两个不同数据库的数据，怎么操作</h3><h3 id=\"redis-分布式锁-的使用\"><a href=\"#redis-分布式锁-的使用\" class=\"headerlink\" title=\"redis 分布式锁 的使用\"></a>redis 分布式锁 的使用</h3><h3 id=\"redis-过期机制的\"><a href=\"#redis-过期机制的\" class=\"headerlink\" title=\"redis 过期机制的\"></a>redis 过期机制的</h3><h3 id=\"sql：找出一个班里的哪个年龄的人最多\"><a href=\"#sql：找出一个班里的哪个年龄的人最多\" class=\"headerlink\" title=\"sql：找出一个班里的哪个年龄的人最多\"></a>sql：找出一个班里的哪个年龄的人最多</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> age <span class=\"keyword\">from</span> <span class=\"keyword\">user</span> <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> age  <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"keyword\">count</span>(age) <span class=\"keyword\">desc</span> <span class=\"keyword\">limit</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"算法：-给定一个数组，0i单调递增，in单调递减，其中n为数组长度，i未知。\"><a href=\"#算法：-给定一个数组，0i单调递增，in单调递减，其中n为数组长度，i未知。\" class=\"headerlink\" title=\"算法： 给定一个数组，0i单调递增，in单调递减，其中n为数组长度，i未知。\"></a>算法： 给定一个数组，0<del>i单调递增，i</del>n单调递减，其中n为数组长度，i未知。</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">去重后元素的个数</span><br><span class=\"line\">input: [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">100</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">output: <span class=\"number\">5</span></span><br><span class=\"line\">不使用额外的空间，不改变原数组</span><br><span class=\"line\">input: <span class=\"number\">1</span>  <span class=\"number\">2</span></span><br><span class=\"line\">output: <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findT</span><span class=\"params\">(target <span class=\"keyword\">int</span>, arr []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(arr) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(arr)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> l &lt;= r &#123;</span><br><span class=\"line\">        mid := l + (r-l)/<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target == arr[mid] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        d := IsD(arr, mid)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> d = <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; arr[l] &amp;&amp; arr[mid] &gt; target &#123;</span><br><span class=\"line\">                r = mid - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> d == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &lt; arr[mid] &amp;&amp; arr[r] &lt; target &#123;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                r = mid <span class=\"number\">-1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res := findTInArea(arr, l, mid<span class=\"number\">-1</span>, target, <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> res != <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = findTInArea(arr, mid+<span class=\"number\">1</span>, r, target, <span class=\"number\">-1</span> )</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> arr[mid] == target &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断是否单调 且单调的方向</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsD</span><span class=\"params\">(arr []<span class=\"keyword\">int</span>, index <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> index &gt; <span class=\"number\">0</span> &amp;&amp; index &lt; <span class=\"built_in\">len</span>(arr) - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[index] &gt; arr[index<span class=\"number\">-1</span>] &amp;&amp; arr[index] &lt; arr[index + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[index] &lt; arr[index<span class=\"number\">-1</span>] &amp;&amp; arr[index] &gt; arr[index + <span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> index == <span class=\"number\">0</span>  &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> index == <span class=\"built_in\">len</span>(arr) - <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 常规二分查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findTInArea</span><span class=\"params\">(arr <span class=\"keyword\">int</span>[], l, r , target, ty <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(arr) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(arr)<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> l &lt;= r &#123;</span><br><span class=\"line\">        mid = l + (r-l)/<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[mid] == target &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><h3 id=\"context使用-及简单代码\"><a href=\"#context使用-及简单代码\" class=\"headerlink\" title=\"context使用 及简单代码\"></a>context使用 及简单代码</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithCancel</span><span class=\"params\">(parent Context)</span> <span class=\"params\">(ctx Context, cancel CancelFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithDeadline</span><span class=\"params\">(parent Context, deadline time.Time)</span> <span class=\"params\">(Context, CancelFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithTimeout</span><span class=\"params\">(parent Context, timeout time.Duration)</span> <span class=\"params\">(Context, CancelFunc)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WithValue</span><span class=\"params\">(parent Context, key, val <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Context</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Background</span><span class=\"params\">()</span> <span class=\"title\">Context</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tctx, cancel := context.WithCancel(context.Background())</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> watch(ctx,<span class=\"string\">\"【监控1】\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> watch(ctx,<span class=\"string\">\"【监控2】\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> watch(ctx,<span class=\"string\">\"【监控3】\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">10</span> * time.Second)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"可以了，通知监控停止\"</span>)</span><br><span class=\"line\">\tcancel()</span><br><span class=\"line\">\t<span class=\"comment\">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class=\"line\">\ttime.Sleep(<span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">watch</span><span class=\"params\">(ctx context.Context, name <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-ctx.Done():</span><br><span class=\"line\">\t\t\tfmt.Println(name,<span class=\"string\">\"监控退出，停止了...\"</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tfmt.Println(name,<span class=\"string\">\"goroutine监控中...\"</span>)</span><br><span class=\"line\">\t\t\ttime.Sleep(<span class=\"number\">2</span> * time.Second)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"实现简单的消息队列-并说出优化方向\"><a href=\"#实现简单的消息队列-并说出优化方向\" class=\"headerlink\" title=\"实现简单的消息队列 并说出优化方向\"></a>实现简单的消息队列 并说出优化方向</h3><p>优化方向</p>\n<ul>\n<li>增加消息的容量</li>\n<li>消息存入硬盘，保证高可用</li>\n<li>如果消费阻塞的话，另一方面，增加消费者数目</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Producer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    messages [<span class=\"number\">9</span>]<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Consumer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    messages [<span class=\"number\">9</span>]<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Producer)</span> <span class=\"title\">init</span><span class=\"params\">(message [9]<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    p.messages = message</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Producer)</span> <span class=\"title\">send</span><span class=\"params\">(message <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    p.messages &lt;- message</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Consumer)</span> <span class=\"title\">init</span> <span class=\"params\">(message [9]<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    c.messages = message</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Receive)</span> <span class=\"title\">receive</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> &lt;-c.message: </span><br><span class=\"line\">            <span class=\"keyword\">return</span> c.message</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sleep(<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    message := [<span class=\"number\">9</span>]<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> prod Producer</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cons Consumer</span><br><span class=\"line\">    prod.init(message)</span><br><span class=\"line\">    cons.init(message)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>;i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            prod.send(<span class=\"string\">\"test\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s := cons.receive()</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"防刷的做法\"><a href=\"#防刷的做法\" class=\"headerlink\" title=\"防刷的做法\"></a>防刷的做法</h3><p>时间维度和ip维度</p>\n<h3 id=\"【算法题】-k个一组-反转链表\"><a href=\"#【算法题】-k个一组-反转链表\" class=\"headerlink\" title=\"【算法题】 k个一组 反转链表\"></a>【算法题】 k个一组 反转链表</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"三面\"><a href=\"#三面\" class=\"headerlink\" title=\"三面\"></a>三面</h2><h3 id=\"【系统设计题】设计一个抢红包的结构\"><a href=\"#【系统设计题】设计一个抢红包的结构\" class=\"headerlink\" title=\"【系统设计题】设计一个抢红包的结构\"></a>【系统设计题】设计一个抢红包的结构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">页面-后端</span><br><span class=\"line\">- 长连接 </span><br><span class=\"line\">- 短链接 </span><br><span class=\"line\">- 每次点击时提交 or 出完结果后提交</span><br><span class=\"line\">- API</span><br><span class=\"line\">- Redis</span><br><span class=\"line\">- MQ -&gt; 使用mq消费，异步，削峰，解耦</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"【系统设计题】-设计一个唯一ID生成器\"><a href=\"#【系统设计题】-设计一个唯一ID生成器\" class=\"headerlink\" title=\"【系统设计题】 设计一个唯一ID生成器\"></a>【系统设计题】 设计一个唯一ID生成器</h3><ul>\n<li>int64的数字</li>\n<li>唯一</li>\n<li>高并发</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">雪花算法</span><br><span class=\"line\">32位秒级时间戳+16位自增id+5位机器码</span><br><span class=\"line\">42位毫秒级时间戳+10机器码+12bit序列号</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"【算法题】给定m个不重复的字符-a-b-c-d-，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3\"><a href=\"#【算法题】给定m个不重复的字符-a-b-c-d-，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3\" class=\"headerlink\" title=\"【算法题】给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3\"></a>【算法题】给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> location [<span class=\"number\">256</span>]<span class=\"keyword\">int</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">indexOfStringNoRepeat</span><span class=\"params\">(s <span class=\"keyword\">string</span>, target <span class=\"keyword\">rune</span>[])</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> location &#123;</span><br><span class=\"line\">        location[i] = <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rs := []<span class=\"keyword\">rune</span>(s)</span><br><span class=\"line\">    ma := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">rune</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> target &#123;</span><br><span class=\"line\">        ma[target] = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// shooted 目前已有的未重复字符</span></span><br><span class=\"line\">    left, shooted := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(rs); i++ &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不存在该字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> _, ok := ma[rs[i]]; !ok &#123;</span><br><span class=\"line\">            before = left </span><br><span class=\"line\">            left = location[rs[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">            updateLocation(rs, before, left)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 该字符</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> location[rs[i]] != <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> location[rs[i]] &gt;= left &#123;</span><br><span class=\"line\">                before = left</span><br><span class=\"line\">                left = location[rs[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">                shooted</span><br><span class=\"line\">                updateLocation(rs, before, left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            shooted ++</span><br><span class=\"line\">            <span class=\"keyword\">if</span> shooted == <span class=\"built_in\">len</span>(target) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> left</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location[rs[i]] ++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateLocations</span><span class=\"params\">(rs []<span class=\"keyword\">rune</span>, l, r <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> l &lt; r &#123;</span><br><span class=\"line\">        location[rs[l]] = <span class=\"number\">-1</span></span><br><span class=\"line\">        l ++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【面试复盘】来也面试","date":"2020-02-24T16:00:00.000Z","_content":"\n\n\n这个部门的面试好水啊....\n\n主要业务 小猴语文\n\n## 基础\n\n\n\n### redis的数据类型\n\n\n\n### redis中的string和c中的string\n\n相似， 因为c里的string时字符数组的格式， 而c++里的是一个指针加上长度\n\n### rabbitMQ和talos的模式 是推还是拉\n\n\n\n### grpc和thrift的区别\n\n\n\n## 算法\n\n### 逐行遍历数， 求列数\n\n``` go\n// dfs\n\n```\n\n\n\n### 数组里 找重复元素\n\n``` go\n// 1. hash\n// 2. 排序\n```\n\n\n\n## 二面\n\n### mvcc\n\n### lru\n\n### 数据库千万级为什么会慢\n\n\n\n### 请求一个连接的访问过程\n\n\n\n### go的热加载实现\n\n\n\n","source":"_posts/面试/复盘/2.26好未来面试.md","raw":"---\ntitle: 【面试复盘】来也面试\ndate: 2020-02-25\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n这个部门的面试好水啊....\n\n主要业务 小猴语文\n\n## 基础\n\n\n\n### redis的数据类型\n\n\n\n### redis中的string和c中的string\n\n相似， 因为c里的string时字符数组的格式， 而c++里的是一个指针加上长度\n\n### rabbitMQ和talos的模式 是推还是拉\n\n\n\n### grpc和thrift的区别\n\n\n\n## 算法\n\n### 逐行遍历数， 求列数\n\n``` go\n// dfs\n\n```\n\n\n\n### 数组里 找重复元素\n\n``` go\n// 1. hash\n// 2. 排序\n```\n\n\n\n## 二面\n\n### mvcc\n\n### lru\n\n### 数据库千万级为什么会慢\n\n\n\n### 请求一个连接的访问过程\n\n\n\n### go的热加载实现\n\n\n\n","slug":"面试/复盘/2.26好未来面试","published":1,"updated":"2020-03-05T03:59:54.942Z","_id":"ck7cxr5dj00085x8ncd0n4p58","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这个部门的面试好水啊….</p>\n<p>主要业务 小猴语文</p>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"redis的数据类型\"><a href=\"#redis的数据类型\" class=\"headerlink\" title=\"redis的数据类型\"></a>redis的数据类型</h3><h3 id=\"redis中的string和c中的string\"><a href=\"#redis中的string和c中的string\" class=\"headerlink\" title=\"redis中的string和c中的string\"></a>redis中的string和c中的string</h3><p>相似， 因为c里的string时字符数组的格式， 而c++里的是一个指针加上长度</p>\n<h3 id=\"rabbitMQ和talos的模式-是推还是拉\"><a href=\"#rabbitMQ和talos的模式-是推还是拉\" class=\"headerlink\" title=\"rabbitMQ和talos的模式 是推还是拉\"></a>rabbitMQ和talos的模式 是推还是拉</h3><h3 id=\"grpc和thrift的区别\"><a href=\"#grpc和thrift的区别\" class=\"headerlink\" title=\"grpc和thrift的区别\"></a>grpc和thrift的区别</h3><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"逐行遍历数，-求列数\"><a href=\"#逐行遍历数，-求列数\" class=\"headerlink\" title=\"逐行遍历数， 求列数\"></a>逐行遍历数， 求列数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dfs</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"数组里-找重复元素\"><a href=\"#数组里-找重复元素\" class=\"headerlink\" title=\"数组里 找重复元素\"></a>数组里 找重复元素</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. hash</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 排序</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><h3 id=\"mvcc\"><a href=\"#mvcc\" class=\"headerlink\" title=\"mvcc\"></a>mvcc</h3><h3 id=\"lru\"><a href=\"#lru\" class=\"headerlink\" title=\"lru\"></a>lru</h3><h3 id=\"数据库千万级为什么会慢\"><a href=\"#数据库千万级为什么会慢\" class=\"headerlink\" title=\"数据库千万级为什么会慢\"></a>数据库千万级为什么会慢</h3><h3 id=\"请求一个连接的访问过程\"><a href=\"#请求一个连接的访问过程\" class=\"headerlink\" title=\"请求一个连接的访问过程\"></a>请求一个连接的访问过程</h3><h3 id=\"go的热加载实现\"><a href=\"#go的热加载实现\" class=\"headerlink\" title=\"go的热加载实现\"></a>go的热加载实现</h3>","site":{"data":{}},"excerpt":"","more":"<p>这个部门的面试好水啊….</p>\n<p>主要业务 小猴语文</p>\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"redis的数据类型\"><a href=\"#redis的数据类型\" class=\"headerlink\" title=\"redis的数据类型\"></a>redis的数据类型</h3><h3 id=\"redis中的string和c中的string\"><a href=\"#redis中的string和c中的string\" class=\"headerlink\" title=\"redis中的string和c中的string\"></a>redis中的string和c中的string</h3><p>相似， 因为c里的string时字符数组的格式， 而c++里的是一个指针加上长度</p>\n<h3 id=\"rabbitMQ和talos的模式-是推还是拉\"><a href=\"#rabbitMQ和talos的模式-是推还是拉\" class=\"headerlink\" title=\"rabbitMQ和talos的模式 是推还是拉\"></a>rabbitMQ和talos的模式 是推还是拉</h3><h3 id=\"grpc和thrift的区别\"><a href=\"#grpc和thrift的区别\" class=\"headerlink\" title=\"grpc和thrift的区别\"></a>grpc和thrift的区别</h3><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><h3 id=\"逐行遍历数，-求列数\"><a href=\"#逐行遍历数，-求列数\" class=\"headerlink\" title=\"逐行遍历数， 求列数\"></a>逐行遍历数， 求列数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dfs</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"数组里-找重复元素\"><a href=\"#数组里-找重复元素\" class=\"headerlink\" title=\"数组里 找重复元素\"></a>数组里 找重复元素</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. hash</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 排序</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><h3 id=\"mvcc\"><a href=\"#mvcc\" class=\"headerlink\" title=\"mvcc\"></a>mvcc</h3><h3 id=\"lru\"><a href=\"#lru\" class=\"headerlink\" title=\"lru\"></a>lru</h3><h3 id=\"数据库千万级为什么会慢\"><a href=\"#数据库千万级为什么会慢\" class=\"headerlink\" title=\"数据库千万级为什么会慢\"></a>数据库千万级为什么会慢</h3><h3 id=\"请求一个连接的访问过程\"><a href=\"#请求一个连接的访问过程\" class=\"headerlink\" title=\"请求一个连接的访问过程\"></a>请求一个连接的访问过程</h3><h3 id=\"go的热加载实现\"><a href=\"#go的热加载实现\" class=\"headerlink\" title=\"go的热加载实现\"></a>go的热加载实现</h3>"},{"title":"【面试复盘】腾讯面试","date":"2020-02-28T16:00:00.000Z","_content":"\n\n\n\n\n### M G P\n\n\n\n### context\n\n\n\n### go对象的过程\n\n\n\n### 算法题\n\n\n\n\n\n``` go\n//【气球游戏】小Q在进行射击气球的游戏，\n// 如果小Q在连续T枪中打爆了所有颜色的气球，将得到一只QQ公仔作为奖励。\n//（每种颜色的气球至少被打爆一只）。这个游戏中有m种不同颜色的气球，编号1到m。\n// 小Q一共有n发子弹，然后连续开了n枪。小Q想知道在这n枪中，打爆所有颜色的气球最少用了连续几枪？\n// 输入描述： 第一行两个空格间隔的整数数n，m。n&lt;=1000000 m&lt;=2000 第二行一共n个空格间隔的整数，分别表示每一枪打中的气球的颜色,0表示没打中任何颜色的气球。\n// 输出描述： 一个整数表示小Q打爆所有颜色气球用的最少枪数。如果小Q无法在这n枪打爆所有颜色的气球，则输出-1\n\nvar ma  map[int]int\nfunc shootGame(n, m int, arr []int) int {\n\tif n < m {\n\t\treturn -1\n\t}\n\tma = make(map[int]int)\n\tmin := n+1\n\t// t 已击中气球 s 射击数 最左数\n\tt , s, l  := 0, 0, 0\n\tfor _, k := range arr {\n\t\t// 如果气球不存在存在\n\t\tif _, ok := ma[k]; !ok || ma[k] == 0 {\n\t\t\tif k != 0 {\n\t\t\t\tt++\n\t\t\t}\n\t\t\t// 如果已击中气球的颜色\n\t\t\tif t == m {\n\t\t\t\tif min > s {\n\t\t\t\t\tmin = s\n\t\t\t\t}\n\t\t\t\t// 找到下一个点\n\t\t\t\tma[l] --\n\t\t\t\t// 射击气球数目为0 t--\n\t\t\t\tif ma[l] == 0 && l != 0 {\n\t\t\t\t\tt --\n\t\t\t\t}\n\t\t\t\t// 左移一位\n\t\t\t\tl ++\n\t\t\t\t// 射击数减yi\n\t\t\t\ts --\n\t\t\t\tif t==m && min > s {\n\t\t\t\t\tmin = s\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 给当前数目加一\n\t\t// 射击数加一\n\t\tma[k] ++\n\t\ts ++\n\t}\n\tif min == n+1 {\n\t\treturn -1\n\t}\n\treturn min\n}\n\n```\n\n","source":"_posts/面试/复盘/2.29腾讯面试.md","raw":"---\ntitle: 【面试复盘】腾讯面试\ndate: 2020-02-29\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n\n\n### M G P\n\n\n\n### context\n\n\n\n### go对象的过程\n\n\n\n### 算法题\n\n\n\n\n\n``` go\n//【气球游戏】小Q在进行射击气球的游戏，\n// 如果小Q在连续T枪中打爆了所有颜色的气球，将得到一只QQ公仔作为奖励。\n//（每种颜色的气球至少被打爆一只）。这个游戏中有m种不同颜色的气球，编号1到m。\n// 小Q一共有n发子弹，然后连续开了n枪。小Q想知道在这n枪中，打爆所有颜色的气球最少用了连续几枪？\n// 输入描述： 第一行两个空格间隔的整数数n，m。n&lt;=1000000 m&lt;=2000 第二行一共n个空格间隔的整数，分别表示每一枪打中的气球的颜色,0表示没打中任何颜色的气球。\n// 输出描述： 一个整数表示小Q打爆所有颜色气球用的最少枪数。如果小Q无法在这n枪打爆所有颜色的气球，则输出-1\n\nvar ma  map[int]int\nfunc shootGame(n, m int, arr []int) int {\n\tif n < m {\n\t\treturn -1\n\t}\n\tma = make(map[int]int)\n\tmin := n+1\n\t// t 已击中气球 s 射击数 最左数\n\tt , s, l  := 0, 0, 0\n\tfor _, k := range arr {\n\t\t// 如果气球不存在存在\n\t\tif _, ok := ma[k]; !ok || ma[k] == 0 {\n\t\t\tif k != 0 {\n\t\t\t\tt++\n\t\t\t}\n\t\t\t// 如果已击中气球的颜色\n\t\t\tif t == m {\n\t\t\t\tif min > s {\n\t\t\t\t\tmin = s\n\t\t\t\t}\n\t\t\t\t// 找到下一个点\n\t\t\t\tma[l] --\n\t\t\t\t// 射击气球数目为0 t--\n\t\t\t\tif ma[l] == 0 && l != 0 {\n\t\t\t\t\tt --\n\t\t\t\t}\n\t\t\t\t// 左移一位\n\t\t\t\tl ++\n\t\t\t\t// 射击数减yi\n\t\t\t\ts --\n\t\t\t\tif t==m && min > s {\n\t\t\t\t\tmin = s\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 给当前数目加一\n\t\t// 射击数加一\n\t\tma[k] ++\n\t\ts ++\n\t}\n\tif min == n+1 {\n\t\treturn -1\n\t}\n\treturn min\n}\n\n```\n\n","slug":"面试/复盘/2.29腾讯面试","published":1,"updated":"2020-03-04T07:25:08.732Z","_id":"ck7cxr5dk000b5x8n8yt0hqgt","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"M-G-P\"><a href=\"#M-G-P\" class=\"headerlink\" title=\"M G P\"></a>M G P</h3><h3 id=\"context\"><a href=\"#context\" class=\"headerlink\" title=\"context\"></a>context</h3><h3 id=\"go对象的过程\"><a href=\"#go对象的过程\" class=\"headerlink\" title=\"go对象的过程\"></a>go对象的过程</h3><h3 id=\"算法题\"><a href=\"#算法题\" class=\"headerlink\" title=\"算法题\"></a>算法题</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//【气球游戏】小Q在进行射击气球的游戏，</span></span><br><span class=\"line\"><span class=\"comment\">// 如果小Q在连续T枪中打爆了所有颜色的气球，将得到一只QQ公仔作为奖励。</span></span><br><span class=\"line\"><span class=\"comment\">//（每种颜色的气球至少被打爆一只）。这个游戏中有m种不同颜色的气球，编号1到m。</span></span><br><span class=\"line\"><span class=\"comment\">// 小Q一共有n发子弹，然后连续开了n枪。小Q想知道在这n枪中，打爆所有颜色的气球最少用了连续几枪？</span></span><br><span class=\"line\"><span class=\"comment\">// 输入描述： 第一行两个空格间隔的整数数n，m。n&amp;lt;=1000000 m&amp;lt;=2000 第二行一共n个空格间隔的整数，分别表示每一枪打中的气球的颜色,0表示没打中任何颜色的气球。</span></span><br><span class=\"line\"><span class=\"comment\">// 输出描述： 一个整数表示小Q打爆所有颜色气球用的最少枪数。如果小Q无法在这n枪打爆所有颜色的气球，则输出-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ma  <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shootGame</span><span class=\"params\">(n, m <span class=\"keyword\">int</span>, arr []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; m &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tma = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">\tmin := n+<span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"comment\">// t 已击中气球 s 射击数 最左数</span></span><br><span class=\"line\">\tt , s, l  := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, k := <span class=\"keyword\">range</span> arr &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果气球不存在存在</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _, ok := ma[k]; !ok || ma[k] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> k != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tt++</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果已击中气球的颜色</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> t == m &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> min &gt; s &#123;</span><br><span class=\"line\">\t\t\t\t\tmin = s</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 找到下一个点</span></span><br><span class=\"line\">\t\t\t\tma[l] --</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 射击气球数目为0 t--</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ma[l] == <span class=\"number\">0</span> &amp;&amp; l != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tt --</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 左移一位</span></span><br><span class=\"line\">\t\t\t\tl ++</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 射击数减yi</span></span><br><span class=\"line\">\t\t\t\ts --</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> t==m &amp;&amp; min &gt; s &#123;</span><br><span class=\"line\">\t\t\t\t\tmin = s</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 给当前数目加一</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 射击数加一</span></span><br><span class=\"line\">\t\tma[k] ++</span><br><span class=\"line\">\t\ts ++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> min == n+<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> min</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"M-G-P\"><a href=\"#M-G-P\" class=\"headerlink\" title=\"M G P\"></a>M G P</h3><h3 id=\"context\"><a href=\"#context\" class=\"headerlink\" title=\"context\"></a>context</h3><h3 id=\"go对象的过程\"><a href=\"#go对象的过程\" class=\"headerlink\" title=\"go对象的过程\"></a>go对象的过程</h3><h3 id=\"算法题\"><a href=\"#算法题\" class=\"headerlink\" title=\"算法题\"></a>算法题</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//【气球游戏】小Q在进行射击气球的游戏，</span></span><br><span class=\"line\"><span class=\"comment\">// 如果小Q在连续T枪中打爆了所有颜色的气球，将得到一只QQ公仔作为奖励。</span></span><br><span class=\"line\"><span class=\"comment\">//（每种颜色的气球至少被打爆一只）。这个游戏中有m种不同颜色的气球，编号1到m。</span></span><br><span class=\"line\"><span class=\"comment\">// 小Q一共有n发子弹，然后连续开了n枪。小Q想知道在这n枪中，打爆所有颜色的气球最少用了连续几枪？</span></span><br><span class=\"line\"><span class=\"comment\">// 输入描述： 第一行两个空格间隔的整数数n，m。n&amp;lt;=1000000 m&amp;lt;=2000 第二行一共n个空格间隔的整数，分别表示每一枪打中的气球的颜色,0表示没打中任何颜色的气球。</span></span><br><span class=\"line\"><span class=\"comment\">// 输出描述： 一个整数表示小Q打爆所有颜色气球用的最少枪数。如果小Q无法在这n枪打爆所有颜色的气球，则输出-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ma  <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shootGame</span><span class=\"params\">(n, m <span class=\"keyword\">int</span>, arr []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n &lt; m &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tma = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">\tmin := n+<span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"comment\">// t 已击中气球 s 射击数 最左数</span></span><br><span class=\"line\">\tt , s, l  := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, k := <span class=\"keyword\">range</span> arr &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果气球不存在存在</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _, ok := ma[k]; !ok || ma[k] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> k != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tt++</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 如果已击中气球的颜色</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> t == m &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> min &gt; s &#123;</span><br><span class=\"line\">\t\t\t\t\tmin = s</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 找到下一个点</span></span><br><span class=\"line\">\t\t\t\tma[l] --</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 射击气球数目为0 t--</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ma[l] == <span class=\"number\">0</span> &amp;&amp; l != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tt --</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 左移一位</span></span><br><span class=\"line\">\t\t\t\tl ++</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 射击数减yi</span></span><br><span class=\"line\">\t\t\t\ts --</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> t==m &amp;&amp; min &gt; s &#123;</span><br><span class=\"line\">\t\t\t\t\tmin = s</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 给当前数目加一</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 射击数加一</span></span><br><span class=\"line\">\t\tma[k] ++</span><br><span class=\"line\">\t\ts ++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> min == n+<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> min</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【面试复盘】滴滴面试","date":"2020-02-27T16:00:00.000Z","_content":"\n\n\n### 使用非递归去二分查找一个数\n\n``` go\n\n// arr []\n// arr [1]\n// arr [1,2,3]\n// arr [2,3,4]\n// 3, 9999,\nfunc findX(target int, arr []int) bool {\n\t//\n\tif len(arr) == 0 {\n\t\treturn false\n\t}\n\n\t// 左右两个节点\n\tl, r := 0, len(arr)-1\n\tvar mid int\n\n\tfor l < r {\n\t\tmid = l + (r-l)/2\n\t\tif arr[mid] == target {\n\t\t\treturn true\n\t\t}\n\t\tif arr[mid] > target {\n\t\t\tr = mid - 1\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\treturn arr[l] == target\n}\n```\n\n\n\n### 使用递归的方式 二分查找\n\n\n\n``` go\nfunc findX(target int, arr []int) int {\n  return findXInArea(target, arr, 0, len(right)-1)\n}\nfunc findXInArea(target int , arr []int, left, right int) int {\n  if left > right {\n    return -1\n  }\n  mid := left + (right-left)/2\n  if arr[mid] > target {\n    return findXInArea(target, arr, left, mid - 1)\n  } \n  if arr[mid] < target {\n    return findXInArea(target, arr, mid + 1, right)\n  }\n  return mid\n}\n```\n\n","source":"_posts/面试/复盘/2.28滴滴面试.md","raw":"---\ntitle: 【面试复盘】滴滴面试\ndate: 2020-02-28\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n### 使用非递归去二分查找一个数\n\n``` go\n\n// arr []\n// arr [1]\n// arr [1,2,3]\n// arr [2,3,4]\n// 3, 9999,\nfunc findX(target int, arr []int) bool {\n\t//\n\tif len(arr) == 0 {\n\t\treturn false\n\t}\n\n\t// 左右两个节点\n\tl, r := 0, len(arr)-1\n\tvar mid int\n\n\tfor l < r {\n\t\tmid = l + (r-l)/2\n\t\tif arr[mid] == target {\n\t\t\treturn true\n\t\t}\n\t\tif arr[mid] > target {\n\t\t\tr = mid - 1\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\treturn arr[l] == target\n}\n```\n\n\n\n### 使用递归的方式 二分查找\n\n\n\n``` go\nfunc findX(target int, arr []int) int {\n  return findXInArea(target, arr, 0, len(right)-1)\n}\nfunc findXInArea(target int , arr []int, left, right int) int {\n  if left > right {\n    return -1\n  }\n  mid := left + (right-left)/2\n  if arr[mid] > target {\n    return findXInArea(target, arr, left, mid - 1)\n  } \n  if arr[mid] < target {\n    return findXInArea(target, arr, mid + 1, right)\n  }\n  return mid\n}\n```\n\n","slug":"面试/复盘/2.28滴滴面试","published":1,"updated":"2020-02-29T07:28:25.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7cxr5dl000e5x8ncwnj3jvy","content":"<h3 id=\"使用非递归去二分查找一个数\"><a href=\"#使用非递归去二分查找一个数\" class=\"headerlink\" title=\"使用非递归去二分查找一个数\"></a>使用非递归去二分查找一个数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// arr []</span></span><br><span class=\"line\"><span class=\"comment\">// arr [1]</span></span><br><span class=\"line\"><span class=\"comment\">// arr [1,2,3]</span></span><br><span class=\"line\"><span class=\"comment\">// arr [2,3,4]</span></span><br><span class=\"line\"><span class=\"comment\">// 3, 9999,</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findX</span><span class=\"params\">(target <span class=\"keyword\">int</span>, arr []<span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(arr) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 左右两个节点</span></span><br><span class=\"line\">\tl, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(arr)<span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mid <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &lt; r &#123;</span><br><span class=\"line\">\t\tmid = l + (r-l)/<span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> arr[mid] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> arr[mid] &gt; target &#123;</span><br><span class=\"line\">\t\t\tr = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tl = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr[l] == target</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用递归的方式-二分查找\"><a href=\"#使用递归的方式-二分查找\" class=\"headerlink\" title=\"使用递归的方式 二分查找\"></a>使用递归的方式 二分查找</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findX</span><span class=\"params\">(target <span class=\"keyword\">int</span>, arr []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> findXInArea(target, arr, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(right)<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findXInArea</span><span class=\"params\">(target <span class=\"keyword\">int</span> , arr []<span class=\"keyword\">int</span>, left, right <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> left &gt; right &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mid := left + (right-left)/<span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> arr[mid] &gt; target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findXInArea(target, arr, left, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> arr[mid] &lt; target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findXInArea(target, arr, mid + <span class=\"number\">1</span>, right)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"使用非递归去二分查找一个数\"><a href=\"#使用非递归去二分查找一个数\" class=\"headerlink\" title=\"使用非递归去二分查找一个数\"></a>使用非递归去二分查找一个数</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// arr []</span></span><br><span class=\"line\"><span class=\"comment\">// arr [1]</span></span><br><span class=\"line\"><span class=\"comment\">// arr [1,2,3]</span></span><br><span class=\"line\"><span class=\"comment\">// arr [2,3,4]</span></span><br><span class=\"line\"><span class=\"comment\">// 3, 9999,</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findX</span><span class=\"params\">(target <span class=\"keyword\">int</span>, arr []<span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(arr) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 左右两个节点</span></span><br><span class=\"line\">\tl, r := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(arr)<span class=\"number\">-1</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> mid <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> l &lt; r &#123;</span><br><span class=\"line\">\t\tmid = l + (r-l)/<span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> arr[mid] == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> arr[mid] &gt; target &#123;</span><br><span class=\"line\">\t\t\tr = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tl = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr[l] == target</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用递归的方式-二分查找\"><a href=\"#使用递归的方式-二分查找\" class=\"headerlink\" title=\"使用递归的方式 二分查找\"></a>使用递归的方式 二分查找</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findX</span><span class=\"params\">(target <span class=\"keyword\">int</span>, arr []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> findXInArea(target, arr, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(right)<span class=\"number\">-1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findXInArea</span><span class=\"params\">(target <span class=\"keyword\">int</span> , arr []<span class=\"keyword\">int</span>, left, right <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> left &gt; right &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mid := left + (right-left)/<span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> arr[mid] &gt; target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findXInArea(target, arr, left, mid - <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> arr[mid] &lt; target &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findXInArea(target, arr, mid + <span class=\"number\">1</span>, right)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【面试复盘】映客面试","date":"2020-02-27T16:00:00.000Z","_content":"\n\n\n### 秒杀过程中里的远近不同影响用户的秒杀成功 解决方案\n\n\n\n\n\n### http和https和http2.0 spdy\n\n#### http1.0的缺点是安全不足和性能不足\n\n#### http2.0 更安全的http， 更快的https\n\n- 二进制传输（解析更高效）\n- header压缩\n- spdy 多路复用\n- 服务器端推送\n- 提高安全性 \n\n\n\n\t- 队头阻塞\n\t- TCP+TLS延时\n\n#### QUIC\n\n### https\n\n对称加密和非对称加密\n\n### 负载均衡\n\n### http2.0 有哪些优化的方向\n\n解决队头阻塞的问题\n\n\n\n### gopath goroot gobin都是什么\n\n\n\n### 命令行实现查找日志文件中的qps\n\n``` shell\ncat access.log | awk '{print $2}' | uniq -c\n```\n\n\n\n### 两个链表 求他们是否有公共节点 并求出他们的交点位置\n\n``` go\n// 求尾部唯一\n\n\n// 连接ab 判断存在环\n```\n\n\n\n","source":"_posts/面试/复盘/2.28百度面试.md","raw":"---\ntitle: 【面试复盘】映客面试\ndate: 2020-02-28\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n### 秒杀过程中里的远近不同影响用户的秒杀成功 解决方案\n\n\n\n\n\n### http和https和http2.0 spdy\n\n#### http1.0的缺点是安全不足和性能不足\n\n#### http2.0 更安全的http， 更快的https\n\n- 二进制传输（解析更高效）\n- header压缩\n- spdy 多路复用\n- 服务器端推送\n- 提高安全性 \n\n\n\n\t- 队头阻塞\n\t- TCP+TLS延时\n\n#### QUIC\n\n### https\n\n对称加密和非对称加密\n\n### 负载均衡\n\n### http2.0 有哪些优化的方向\n\n解决队头阻塞的问题\n\n\n\n### gopath goroot gobin都是什么\n\n\n\n### 命令行实现查找日志文件中的qps\n\n``` shell\ncat access.log | awk '{print $2}' | uniq -c\n```\n\n\n\n### 两个链表 求他们是否有公共节点 并求出他们的交点位置\n\n``` go\n// 求尾部唯一\n\n\n// 连接ab 判断存在环\n```\n\n\n\n","slug":"面试/复盘/2.28百度面试","published":1,"updated":"2020-03-05T08:58:22.351Z","_id":"ck7cxr5dm000h5x8n7iccfr9g","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"秒杀过程中里的远近不同影响用户的秒杀成功-解决方案\"><a href=\"#秒杀过程中里的远近不同影响用户的秒杀成功-解决方案\" class=\"headerlink\" title=\"秒杀过程中里的远近不同影响用户的秒杀成功 解决方案\"></a>秒杀过程中里的远近不同影响用户的秒杀成功 解决方案</h3><h3 id=\"http和https和http2-0-spdy\"><a href=\"#http和https和http2-0-spdy\" class=\"headerlink\" title=\"http和https和http2.0 spdy\"></a>http和https和http2.0 spdy</h3><h4 id=\"http1-0的缺点是安全不足和性能不足\"><a href=\"#http1-0的缺点是安全不足和性能不足\" class=\"headerlink\" title=\"http1.0的缺点是安全不足和性能不足\"></a>http1.0的缺点是安全不足和性能不足</h4><h4 id=\"http2-0-更安全的http，-更快的https\"><a href=\"#http2-0-更安全的http，-更快的https\" class=\"headerlink\" title=\"http2.0 更安全的http， 更快的https\"></a>http2.0 更安全的http， 更快的https</h4><ul>\n<li>二进制传输（解析更高效）</li>\n<li>header压缩</li>\n<li>spdy 多路复用</li>\n<li>服务器端推送</li>\n<li>提高安全性 </li>\n</ul>\n<pre><code>- 队头阻塞\n- TCP+TLS延时</code></pre><h4 id=\"QUIC\"><a href=\"#QUIC\" class=\"headerlink\" title=\"QUIC\"></a>QUIC</h4><h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h3><p>对称加密和非对称加密</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><h3 id=\"http2-0-有哪些优化的方向\"><a href=\"#http2-0-有哪些优化的方向\" class=\"headerlink\" title=\"http2.0 有哪些优化的方向\"></a>http2.0 有哪些优化的方向</h3><p>解决队头阻塞的问题</p>\n<h3 id=\"gopath-goroot-gobin都是什么\"><a href=\"#gopath-goroot-gobin都是什么\" class=\"headerlink\" title=\"gopath goroot gobin都是什么\"></a>gopath goroot gobin都是什么</h3><h3 id=\"命令行实现查找日志文件中的qps\"><a href=\"#命令行实现查找日志文件中的qps\" class=\"headerlink\" title=\"命令行实现查找日志文件中的qps\"></a>命令行实现查找日志文件中的qps</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat access.log | awk '&#123;print $2&#125;' | uniq -c</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"两个链表-求他们是否有公共节点-并求出他们的交点位置\"><a href=\"#两个链表-求他们是否有公共节点-并求出他们的交点位置\" class=\"headerlink\" title=\"两个链表 求他们是否有公共节点 并求出他们的交点位置\"></a>两个链表 求他们是否有公共节点 并求出他们的交点位置</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求尾部唯一</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接ab 判断存在环</span></span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"秒杀过程中里的远近不同影响用户的秒杀成功-解决方案\"><a href=\"#秒杀过程中里的远近不同影响用户的秒杀成功-解决方案\" class=\"headerlink\" title=\"秒杀过程中里的远近不同影响用户的秒杀成功 解决方案\"></a>秒杀过程中里的远近不同影响用户的秒杀成功 解决方案</h3><h3 id=\"http和https和http2-0-spdy\"><a href=\"#http和https和http2-0-spdy\" class=\"headerlink\" title=\"http和https和http2.0 spdy\"></a>http和https和http2.0 spdy</h3><h4 id=\"http1-0的缺点是安全不足和性能不足\"><a href=\"#http1-0的缺点是安全不足和性能不足\" class=\"headerlink\" title=\"http1.0的缺点是安全不足和性能不足\"></a>http1.0的缺点是安全不足和性能不足</h4><h4 id=\"http2-0-更安全的http，-更快的https\"><a href=\"#http2-0-更安全的http，-更快的https\" class=\"headerlink\" title=\"http2.0 更安全的http， 更快的https\"></a>http2.0 更安全的http， 更快的https</h4><ul>\n<li>二进制传输（解析更高效）</li>\n<li>header压缩</li>\n<li>spdy 多路复用</li>\n<li>服务器端推送</li>\n<li>提高安全性 </li>\n</ul>\n<pre><code>- 队头阻塞\n- TCP+TLS延时</code></pre><h4 id=\"QUIC\"><a href=\"#QUIC\" class=\"headerlink\" title=\"QUIC\"></a>QUIC</h4><h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h3><p>对称加密和非对称加密</p>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><h3 id=\"http2-0-有哪些优化的方向\"><a href=\"#http2-0-有哪些优化的方向\" class=\"headerlink\" title=\"http2.0 有哪些优化的方向\"></a>http2.0 有哪些优化的方向</h3><p>解决队头阻塞的问题</p>\n<h3 id=\"gopath-goroot-gobin都是什么\"><a href=\"#gopath-goroot-gobin都是什么\" class=\"headerlink\" title=\"gopath goroot gobin都是什么\"></a>gopath goroot gobin都是什么</h3><h3 id=\"命令行实现查找日志文件中的qps\"><a href=\"#命令行实现查找日志文件中的qps\" class=\"headerlink\" title=\"命令行实现查找日志文件中的qps\"></a>命令行实现查找日志文件中的qps</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat access.log | awk '&#123;print $2&#125;' | uniq -c</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"两个链表-求他们是否有公共节点-并求出他们的交点位置\"><a href=\"#两个链表-求他们是否有公共节点-并求出他们的交点位置\" class=\"headerlink\" title=\"两个链表 求他们是否有公共节点 并求出他们的交点位置\"></a>两个链表 求他们是否有公共节点 并求出他们的交点位置</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求尾部唯一</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接ab 判断存在环</span></span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"【面试复盘】映客面试","date":"2020-02-26T16:00:00.000Z","_content":"\n\n\n### raft的应用场景 同类的算法\n\nEtched\n\n### hash的时候一个节点链表过长怎么处理\n\n- 更换算法\n- 更换数据结构\n\n### redis持久化\n\nAOF\n\nRDB\n\n### b+树在保存唯一索引的时候的生成\n\n\n\n### mysql 读到从库未更新数据 如何解决\n\n- 主从使用一个数据库 （pass）\n- 写完库后更新缓存 设置过期时间\n- 使用数据库中间件\n\n### golang里 make 和 a := []int{} 的区别\n\n\n\n### 归并排序的时间复杂度和空间复杂度（空间复杂度的计算）\n\n排序算法比较表格\n\n| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |\n| -------- | -------------- | -------------- | ---------- | -------- |\n| 冒泡排序 | o(n2)          | o(n2)          | o(1)       | 是       |\n\n\n\n|选择排序\t|O（n2）|O（n2）|\tO（n2）|O（n2）|\tO（1）|O（1）\t|不是|\n|直接插入排序|\tO（n2）|O（n2）|\tO（n2）|O（n2）|\tO（1）|O（1）\t|是|\n|归并排序|\tO(nlogn)|O(nlogn)\t|O(nlogn)|O(nlogn)\t|O（n）|O（n）|\t是|\n|快速排序\t|O(nlogn)|O(nlogn)|\tO（n2）|O（n2）|\tO（logn）|O（logn）|\t不是|\n|堆排序\t|O(nlogn)|O(nlogn)|\tO(nlogn)|O(nlogn)\t|O（1）|O（1）\t|不是|\n|希尔排序|\tO(nlogn|)O(nlogn)|\tO（ns）|O（ns）|\tO（1）|O（1）|\t不是|\n|计数排序|\tO(n+k)|O(n+k)|\tO(n+k)|O(n+k)|\tO(n+k)|O(n+k)\t是|\n|基数排序|\tO(N∗M|)O(N∗M)|\tO(N∗M)|O(N∗M)\t|O(M)|O(M)\t|是|\n\n### n个有序数组 合并\n\n\n\n### dns使用的协议\n\nUdp协议\n\n### 内网ip访问到公网ip的路径\n\n内网ip在局域网内是唯一的， 但是可以通过该局域网对应的公网ip来实现对其他公网IP的访问","source":"_posts/面试/复盘/2.27知乎面试.md","raw":"---\ntitle: 【面试复盘】映客面试\ndate: 2020-02-27\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n### raft的应用场景 同类的算法\n\nEtched\n\n### hash的时候一个节点链表过长怎么处理\n\n- 更换算法\n- 更换数据结构\n\n### redis持久化\n\nAOF\n\nRDB\n\n### b+树在保存唯一索引的时候的生成\n\n\n\n### mysql 读到从库未更新数据 如何解决\n\n- 主从使用一个数据库 （pass）\n- 写完库后更新缓存 设置过期时间\n- 使用数据库中间件\n\n### golang里 make 和 a := []int{} 的区别\n\n\n\n### 归并排序的时间复杂度和空间复杂度（空间复杂度的计算）\n\n排序算法比较表格\n\n| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |\n| -------- | -------------- | -------------- | ---------- | -------- |\n| 冒泡排序 | o(n2)          | o(n2)          | o(1)       | 是       |\n\n\n\n|选择排序\t|O（n2）|O（n2）|\tO（n2）|O（n2）|\tO（1）|O（1）\t|不是|\n|直接插入排序|\tO（n2）|O（n2）|\tO（n2）|O（n2）|\tO（1）|O（1）\t|是|\n|归并排序|\tO(nlogn)|O(nlogn)\t|O(nlogn)|O(nlogn)\t|O（n）|O（n）|\t是|\n|快速排序\t|O(nlogn)|O(nlogn)|\tO（n2）|O（n2）|\tO（logn）|O（logn）|\t不是|\n|堆排序\t|O(nlogn)|O(nlogn)|\tO(nlogn)|O(nlogn)\t|O（1）|O（1）\t|不是|\n|希尔排序|\tO(nlogn|)O(nlogn)|\tO（ns）|O（ns）|\tO（1）|O（1）|\t不是|\n|计数排序|\tO(n+k)|O(n+k)|\tO(n+k)|O(n+k)|\tO(n+k)|O(n+k)\t是|\n|基数排序|\tO(N∗M|)O(N∗M)|\tO(N∗M)|O(N∗M)\t|O(M)|O(M)\t|是|\n\n### n个有序数组 合并\n\n\n\n### dns使用的协议\n\nUdp协议\n\n### 内网ip访问到公网ip的路径\n\n内网ip在局域网内是唯一的， 但是可以通过该局域网对应的公网ip来实现对其他公网IP的访问","slug":"面试/复盘/2.27知乎面试","published":1,"updated":"2020-02-29T10:42:29.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7cxr5dn000k5x8n1yt2famn","content":"<h3 id=\"raft的应用场景-同类的算法\"><a href=\"#raft的应用场景-同类的算法\" class=\"headerlink\" title=\"raft的应用场景 同类的算法\"></a>raft的应用场景 同类的算法</h3><p>Etched</p>\n<h3 id=\"hash的时候一个节点链表过长怎么处理\"><a href=\"#hash的时候一个节点链表过长怎么处理\" class=\"headerlink\" title=\"hash的时候一个节点链表过长怎么处理\"></a>hash的时候一个节点链表过长怎么处理</h3><ul>\n<li>更换算法</li>\n<li>更换数据结构</li>\n</ul>\n<h3 id=\"redis持久化\"><a href=\"#redis持久化\" class=\"headerlink\" title=\"redis持久化\"></a>redis持久化</h3><p>AOF</p>\n<p>RDB</p>\n<h3 id=\"b-树在保存唯一索引的时候的生成\"><a href=\"#b-树在保存唯一索引的时候的生成\" class=\"headerlink\" title=\"b+树在保存唯一索引的时候的生成\"></a>b+树在保存唯一索引的时候的生成</h3><h3 id=\"mysql-读到从库未更新数据-如何解决\"><a href=\"#mysql-读到从库未更新数据-如何解决\" class=\"headerlink\" title=\"mysql 读到从库未更新数据 如何解决\"></a>mysql 读到从库未更新数据 如何解决</h3><ul>\n<li>主从使用一个数据库 （pass）</li>\n<li>写完库后更新缓存 设置过期时间</li>\n<li>使用数据库中间件</li>\n</ul>\n<h3 id=\"golang里-make-和-a-int-的区别\"><a href=\"#golang里-make-和-a-int-的区别\" class=\"headerlink\" title=\"golang里 make 和 a := []int{} 的区别\"></a>golang里 make 和 a := []int{} 的区别</h3><h3 id=\"归并排序的时间复杂度和空间复杂度（空间复杂度的计算）\"><a href=\"#归并排序的时间复杂度和空间复杂度（空间复杂度的计算）\" class=\"headerlink\" title=\"归并排序的时间复杂度和空间复杂度（空间复杂度的计算）\"></a>归并排序的时间复杂度和空间复杂度（空间复杂度的计算）</h3><p>排序算法比较表格</p>\n<table>\n<thead>\n<tr>\n<th>排序算法</th>\n<th>平均时间复杂度</th>\n<th>最坏时间复杂度</th>\n<th>空间复杂度</th>\n<th>是否稳定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>冒泡排序</td>\n<td>o(n2)</td>\n<td>o(n2)</td>\n<td>o(1)</td>\n<td>是</td>\n</tr>\n</tbody></table>\n<p>|选择排序    |O（n2）|O（n2）|    O（n2）|O（n2）|    O（1）|O（1）    |不是|<br>|直接插入排序|    O（n2）|O（n2）|    O（n2）|O（n2）|    O（1）|O（1）    |是|<br>|归并排序|    O(nlogn)|O(nlogn)    |O(nlogn)|O(nlogn)    |O（n）|O（n）|    是|<br>|快速排序    |O(nlogn)|O(nlogn)|    O（n2）|O（n2）|    O（logn）|O（logn）|    不是|<br>|堆排序    |O(nlogn)|O(nlogn)|    O(nlogn)|O(nlogn)    |O（1）|O（1）    |不是|<br>|希尔排序|    O(nlogn|)O(nlogn)|    O（ns）|O（ns）|    O（1）|O（1）|    不是|<br>|计数排序|    O(n+k)|O(n+k)|    O(n+k)|O(n+k)|    O(n+k)|O(n+k)    是|<br>|基数排序|    O(N∗M|)O(N∗M)|    O(N∗M)|O(N∗M)    |O(M)|O(M)    |是|</p>\n<h3 id=\"n个有序数组-合并\"><a href=\"#n个有序数组-合并\" class=\"headerlink\" title=\"n个有序数组 合并\"></a>n个有序数组 合并</h3><h3 id=\"dns使用的协议\"><a href=\"#dns使用的协议\" class=\"headerlink\" title=\"dns使用的协议\"></a>dns使用的协议</h3><p>Udp协议</p>\n<h3 id=\"内网ip访问到公网ip的路径\"><a href=\"#内网ip访问到公网ip的路径\" class=\"headerlink\" title=\"内网ip访问到公网ip的路径\"></a>内网ip访问到公网ip的路径</h3><p>内网ip在局域网内是唯一的， 但是可以通过该局域网对应的公网ip来实现对其他公网IP的访问</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"raft的应用场景-同类的算法\"><a href=\"#raft的应用场景-同类的算法\" class=\"headerlink\" title=\"raft的应用场景 同类的算法\"></a>raft的应用场景 同类的算法</h3><p>Etched</p>\n<h3 id=\"hash的时候一个节点链表过长怎么处理\"><a href=\"#hash的时候一个节点链表过长怎么处理\" class=\"headerlink\" title=\"hash的时候一个节点链表过长怎么处理\"></a>hash的时候一个节点链表过长怎么处理</h3><ul>\n<li>更换算法</li>\n<li>更换数据结构</li>\n</ul>\n<h3 id=\"redis持久化\"><a href=\"#redis持久化\" class=\"headerlink\" title=\"redis持久化\"></a>redis持久化</h3><p>AOF</p>\n<p>RDB</p>\n<h3 id=\"b-树在保存唯一索引的时候的生成\"><a href=\"#b-树在保存唯一索引的时候的生成\" class=\"headerlink\" title=\"b+树在保存唯一索引的时候的生成\"></a>b+树在保存唯一索引的时候的生成</h3><h3 id=\"mysql-读到从库未更新数据-如何解决\"><a href=\"#mysql-读到从库未更新数据-如何解决\" class=\"headerlink\" title=\"mysql 读到从库未更新数据 如何解决\"></a>mysql 读到从库未更新数据 如何解决</h3><ul>\n<li>主从使用一个数据库 （pass）</li>\n<li>写完库后更新缓存 设置过期时间</li>\n<li>使用数据库中间件</li>\n</ul>\n<h3 id=\"golang里-make-和-a-int-的区别\"><a href=\"#golang里-make-和-a-int-的区别\" class=\"headerlink\" title=\"golang里 make 和 a := []int{} 的区别\"></a>golang里 make 和 a := []int{} 的区别</h3><h3 id=\"归并排序的时间复杂度和空间复杂度（空间复杂度的计算）\"><a href=\"#归并排序的时间复杂度和空间复杂度（空间复杂度的计算）\" class=\"headerlink\" title=\"归并排序的时间复杂度和空间复杂度（空间复杂度的计算）\"></a>归并排序的时间复杂度和空间复杂度（空间复杂度的计算）</h3><p>排序算法比较表格</p>\n<table>\n<thead>\n<tr>\n<th>排序算法</th>\n<th>平均时间复杂度</th>\n<th>最坏时间复杂度</th>\n<th>空间复杂度</th>\n<th>是否稳定</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>冒泡排序</td>\n<td>o(n2)</td>\n<td>o(n2)</td>\n<td>o(1)</td>\n<td>是</td>\n</tr>\n</tbody></table>\n<p>|选择排序    |O（n2）|O（n2）|    O（n2）|O（n2）|    O（1）|O（1）    |不是|<br>|直接插入排序|    O（n2）|O（n2）|    O（n2）|O（n2）|    O（1）|O（1）    |是|<br>|归并排序|    O(nlogn)|O(nlogn)    |O(nlogn)|O(nlogn)    |O（n）|O（n）|    是|<br>|快速排序    |O(nlogn)|O(nlogn)|    O（n2）|O（n2）|    O（logn）|O（logn）|    不是|<br>|堆排序    |O(nlogn)|O(nlogn)|    O(nlogn)|O(nlogn)    |O（1）|O（1）    |不是|<br>|希尔排序|    O(nlogn|)O(nlogn)|    O（ns）|O（ns）|    O（1）|O（1）|    不是|<br>|计数排序|    O(n+k)|O(n+k)|    O(n+k)|O(n+k)|    O(n+k)|O(n+k)    是|<br>|基数排序|    O(N∗M|)O(N∗M)|    O(N∗M)|O(N∗M)    |O(M)|O(M)    |是|</p>\n<h3 id=\"n个有序数组-合并\"><a href=\"#n个有序数组-合并\" class=\"headerlink\" title=\"n个有序数组 合并\"></a>n个有序数组 合并</h3><h3 id=\"dns使用的协议\"><a href=\"#dns使用的协议\" class=\"headerlink\" title=\"dns使用的协议\"></a>dns使用的协议</h3><p>Udp协议</p>\n<h3 id=\"内网ip访问到公网ip的路径\"><a href=\"#内网ip访问到公网ip的路径\" class=\"headerlink\" title=\"内网ip访问到公网ip的路径\"></a>内网ip访问到公网ip的路径</h3><p>内网ip在局域网内是唯一的， 但是可以通过该局域网对应的公网ip来实现对其他公网IP的访问</p>\n"},{"title":"【第一课】linux命令","date":"2019-11-11T16:00:00.000Z","_content":"\n> 本篇文章主要就linux命令的常见问题进行了讨论\n\n<!-- more -->\n\n1. 任务计划格式中，前面5个数字分表表示什么含义？\n\n答：依次表示：分、时、日、月、周\n\n2. Linux 查看端口占用情况可以使用 lsof 和 netstat 命令\n\n3. zcat命令用于不真正解压缩文件，就能显示压缩包中文件的内容的场合。\n\n4. 释放某端口\n\n```bash\nnetstat -tln && lsof -i :9001 && kill -9 9001 && netstat -tln\n```\n\n\n\n5. 删除大于30m的命令\n\n``` bash\nfind ./ -size +50M -exec rm {} \\;\n\n{}是一个特殊的字符串，对于每一个匹配的文件，{}会被替换成相应的文件名；\n```\n\n\n\n6. 从尾部看日志\n\n```bash\ntail -f \n```\n\n\n\n7. 链接远程服务器\n\n```bash\nssh\n```\n\n\n\n8. crontab\n\n```bash\ncrontab [-u user] file crontab [-u user] [ -e | -l | -r ]\n```\n\n\n\n如果不输file的话， 则接受标准输入\n\n9. 远程拷贝\n\n```bash\nscp [参数] [原路径] [目标路径]\n```\n\n\n\n10. 万物皆文件\n\nlsof打开的文件可以是：\n\n1. 普通文件\n\n2. 目录\n\n3. 网络文件系统的文件\n\n4. 字符或设备文件\n\n5. (函数)共享库\n\n6. 管道，命名管道\n\n7. 符号链接\n\n8. 网络文件（例如：NFS file、网络socket，unix域名socket）\n\n9. 还有其它类型的文件，等等\n\n   \n\n11. 设置命令别名\n\n```bash\nalias lsl='ls -lrt'\n```\n\n12. 软链和硬链\n\n```bash\nln cc ccAgain :硬连接；删除一个，将仍能找到；\nln -s cc ccTo :符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件）\n```\n\n13. 管道\n\n- 批处理命令连接执行，使用 |\n- 串联: 使用分号 ;\n- 前面成功，则执行后面一条，否则，不执行:&&\n- 前面失败，则后一条执行: ||\n\n14. 环境变量\n\n```\n启动帐号后自动执行的是 文件为 .profile，然后通过这个文件可设置自己的环境变量；\n```\n\n\n\n15. 文本处理\n\n\n\n- find 文件查找\n  - [定制搜索](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#id3)\n  - [找到后的后续动作](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#id4)\n  - [-print的定界符](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#print)\n- [grep 文本搜索](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#grep)\n- [xargs 命令行参数转换](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#xargs)\n- [sort 排序](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#sort)\n- [uniq 消除重复行](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#uniq)\n- [用tr进行转换](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#tr)\n- [cut 按列切分文本](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#cut)\n- [paste 按列拼接文本](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#paste)\n- [wc 统计行和字符的工具](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#wc)\n- [sed 文本替换利器](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#sed)\n- [awk 数据流处理工具](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#awk)\n\n16. 磁盘管理\n\n```\n查看磁盘空间 df -h\n\n查看目录大小 du -sh\n\n打包 tar -cvf\n\n解包 tar -xvf\n\n压缩 gzip\n\n解压缩 gunzip bzip\n```\n\n\n\n17. 修改权限\n\n```\nchmod\n\nchrow \n```\n\n\n\n18. 统计qps","source":"_posts/面试/要点整理/linux.md","raw":"---\ntitle: 【第一课】linux命令\ndate: 2019-11-12\ntags:\n- linux\ncategories:\n- 面试\n---\n\n> 本篇文章主要就linux命令的常见问题进行了讨论\n\n<!-- more -->\n\n1. 任务计划格式中，前面5个数字分表表示什么含义？\n\n答：依次表示：分、时、日、月、周\n\n2. Linux 查看端口占用情况可以使用 lsof 和 netstat 命令\n\n3. zcat命令用于不真正解压缩文件，就能显示压缩包中文件的内容的场合。\n\n4. 释放某端口\n\n```bash\nnetstat -tln && lsof -i :9001 && kill -9 9001 && netstat -tln\n```\n\n\n\n5. 删除大于30m的命令\n\n``` bash\nfind ./ -size +50M -exec rm {} \\;\n\n{}是一个特殊的字符串，对于每一个匹配的文件，{}会被替换成相应的文件名；\n```\n\n\n\n6. 从尾部看日志\n\n```bash\ntail -f \n```\n\n\n\n7. 链接远程服务器\n\n```bash\nssh\n```\n\n\n\n8. crontab\n\n```bash\ncrontab [-u user] file crontab [-u user] [ -e | -l | -r ]\n```\n\n\n\n如果不输file的话， 则接受标准输入\n\n9. 远程拷贝\n\n```bash\nscp [参数] [原路径] [目标路径]\n```\n\n\n\n10. 万物皆文件\n\nlsof打开的文件可以是：\n\n1. 普通文件\n\n2. 目录\n\n3. 网络文件系统的文件\n\n4. 字符或设备文件\n\n5. (函数)共享库\n\n6. 管道，命名管道\n\n7. 符号链接\n\n8. 网络文件（例如：NFS file、网络socket，unix域名socket）\n\n9. 还有其它类型的文件，等等\n\n   \n\n11. 设置命令别名\n\n```bash\nalias lsl='ls -lrt'\n```\n\n12. 软链和硬链\n\n```bash\nln cc ccAgain :硬连接；删除一个，将仍能找到；\nln -s cc ccTo :符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件）\n```\n\n13. 管道\n\n- 批处理命令连接执行，使用 |\n- 串联: 使用分号 ;\n- 前面成功，则执行后面一条，否则，不执行:&&\n- 前面失败，则后一条执行: ||\n\n14. 环境变量\n\n```\n启动帐号后自动执行的是 文件为 .profile，然后通过这个文件可设置自己的环境变量；\n```\n\n\n\n15. 文本处理\n\n\n\n- find 文件查找\n  - [定制搜索](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#id3)\n  - [找到后的后续动作](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#id4)\n  - [-print的定界符](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#print)\n- [grep 文本搜索](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#grep)\n- [xargs 命令行参数转换](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#xargs)\n- [sort 排序](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#sort)\n- [uniq 消除重复行](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#uniq)\n- [用tr进行转换](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#tr)\n- [cut 按列切分文本](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#cut)\n- [paste 按列拼接文本](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#paste)\n- [wc 统计行和字符的工具](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#wc)\n- [sed 文本替换利器](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#sed)\n- [awk 数据流处理工具](https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#awk)\n\n16. 磁盘管理\n\n```\n查看磁盘空间 df -h\n\n查看目录大小 du -sh\n\n打包 tar -cvf\n\n解包 tar -xvf\n\n压缩 gzip\n\n解压缩 gunzip bzip\n```\n\n\n\n17. 修改权限\n\n```\nchmod\n\nchrow \n```\n\n\n\n18. 统计qps","slug":"面试/要点整理/linux","published":1,"updated":"2020-03-23T07:22:25.819Z","_id":"ck7cxr5do000n5x8nbcuu5wck","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本篇文章主要就linux命令的常见问题进行了讨论</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<ol>\n<li>任务计划格式中，前面5个数字分表表示什么含义？</li>\n</ol>\n<p>答：依次表示：分、时、日、月、周</p>\n<ol start=\"2\">\n<li><p>Linux 查看端口占用情况可以使用 lsof 和 netstat 命令</p>\n</li>\n<li><p>zcat命令用于不真正解压缩文件，就能显示压缩包中文件的内容的场合。</p>\n</li>\n<li><p>释放某端口</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -tln &amp;&amp; lsof -i :9001 &amp;&amp; <span class=\"built_in\">kill</span> -9 9001 &amp;&amp; netstat -tln</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"5\">\n<li>删除大于30m的命令</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find ./ -size +50M -<span class=\"built_in\">exec</span> rm &#123;&#125; \\;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#125;是一个特殊的字符串，对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名；</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"6\">\n<li>从尾部看日志</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"7\">\n<li>链接远程服务器</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"8\">\n<li>crontab</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab [-u user] file crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果不输file的话， 则接受标准输入</p>\n<ol start=\"9\">\n<li>远程拷贝</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp [参数] [原路径] [目标路径]</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"10\">\n<li>万物皆文件</li>\n</ol>\n<p>lsof打开的文件可以是：</p>\n<ol>\n<li><p>普通文件</p>\n</li>\n<li><p>目录</p>\n</li>\n<li><p>网络文件系统的文件</p>\n</li>\n<li><p>字符或设备文件</p>\n</li>\n<li><p>(函数)共享库</p>\n</li>\n<li><p>管道，命名管道</p>\n</li>\n<li><p>符号链接</p>\n</li>\n<li><p>网络文件（例如：NFS file、网络socket，unix域名socket）</p>\n</li>\n<li><p>还有其它类型的文件，等等</p>\n</li>\n</ol>\n<ol start=\"11\">\n<li>设置命令别名</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> lsl=<span class=\"string\">'ls -lrt'</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"12\">\n<li>软链和硬链</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln cc ccAgain :硬连接；删除一个，将仍能找到；</span><br><span class=\"line\">ln -s cc ccTo :符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件）</span><br></pre></td></tr></table></figure>\n\n<ol start=\"13\">\n<li>管道</li>\n</ol>\n<ul>\n<li>批处理命令连接执行，使用 |</li>\n<li>串联: 使用分号 ;</li>\n<li>前面成功，则执行后面一条，否则，不执行:&amp;&amp;</li>\n<li>前面失败，则后一条执行: ||</li>\n</ul>\n<ol start=\"14\">\n<li>环境变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动帐号后自动执行的是 文件为 .profile，然后通过这个文件可设置自己的环境变量；</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"15\">\n<li>文本处理</li>\n</ol>\n<ul>\n<li>find 文件查找<ul>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#id3\" target=\"_blank\" rel=\"noopener\">定制搜索</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#id4\" target=\"_blank\" rel=\"noopener\">找到后的后续动作</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#print\" target=\"_blank\" rel=\"noopener\">-print的定界符</a></li>\n</ul>\n</li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#grep\" target=\"_blank\" rel=\"noopener\">grep 文本搜索</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#xargs\" target=\"_blank\" rel=\"noopener\">xargs 命令行参数转换</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#sort\" target=\"_blank\" rel=\"noopener\">sort 排序</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#uniq\" target=\"_blank\" rel=\"noopener\">uniq 消除重复行</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#tr\" target=\"_blank\" rel=\"noopener\">用tr进行转换</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#cut\" target=\"_blank\" rel=\"noopener\">cut 按列切分文本</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#paste\" target=\"_blank\" rel=\"noopener\">paste 按列拼接文本</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#wc\" target=\"_blank\" rel=\"noopener\">wc 统计行和字符的工具</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#sed\" target=\"_blank\" rel=\"noopener\">sed 文本替换利器</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#awk\" target=\"_blank\" rel=\"noopener\">awk 数据流处理工具</a></li>\n</ul>\n<ol start=\"16\">\n<li>磁盘管理</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看磁盘空间 df -h</span><br><span class=\"line\"></span><br><span class=\"line\">查看目录大小 du -sh</span><br><span class=\"line\"></span><br><span class=\"line\">打包 tar -cvf</span><br><span class=\"line\"></span><br><span class=\"line\">解包 tar -xvf</span><br><span class=\"line\"></span><br><span class=\"line\">压缩 gzip</span><br><span class=\"line\"></span><br><span class=\"line\">解压缩 gunzip bzip</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"17\">\n<li>修改权限</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod</span><br><span class=\"line\"></span><br><span class=\"line\">chrow</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"18\">\n<li>统计qps</li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本篇文章主要就linux命令的常见问题进行了讨论</p>\n</blockquote>","more":"<ol>\n<li>任务计划格式中，前面5个数字分表表示什么含义？</li>\n</ol>\n<p>答：依次表示：分、时、日、月、周</p>\n<ol start=\"2\">\n<li><p>Linux 查看端口占用情况可以使用 lsof 和 netstat 命令</p>\n</li>\n<li><p>zcat命令用于不真正解压缩文件，就能显示压缩包中文件的内容的场合。</p>\n</li>\n<li><p>释放某端口</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -tln &amp;&amp; lsof -i :9001 &amp;&amp; <span class=\"built_in\">kill</span> -9 9001 &amp;&amp; netstat -tln</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"5\">\n<li>删除大于30m的命令</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find ./ -size +50M -<span class=\"built_in\">exec</span> rm &#123;&#125; \\;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&#125;是一个特殊的字符串，对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名；</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"6\">\n<li>从尾部看日志</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"7\">\n<li>链接远程服务器</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"8\">\n<li>crontab</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab [-u user] file crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果不输file的话， 则接受标准输入</p>\n<ol start=\"9\">\n<li>远程拷贝</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scp [参数] [原路径] [目标路径]</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"10\">\n<li>万物皆文件</li>\n</ol>\n<p>lsof打开的文件可以是：</p>\n<ol>\n<li><p>普通文件</p>\n</li>\n<li><p>目录</p>\n</li>\n<li><p>网络文件系统的文件</p>\n</li>\n<li><p>字符或设备文件</p>\n</li>\n<li><p>(函数)共享库</p>\n</li>\n<li><p>管道，命名管道</p>\n</li>\n<li><p>符号链接</p>\n</li>\n<li><p>网络文件（例如：NFS file、网络socket，unix域名socket）</p>\n</li>\n<li><p>还有其它类型的文件，等等</p>\n</li>\n</ol>\n<ol start=\"11\">\n<li>设置命令别名</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> lsl=<span class=\"string\">'ls -lrt'</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"12\">\n<li>软链和硬链</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln cc ccAgain :硬连接；删除一个，将仍能找到；</span><br><span class=\"line\">ln -s cc ccTo :符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件）</span><br></pre></td></tr></table></figure>\n\n<ol start=\"13\">\n<li>管道</li>\n</ol>\n<ul>\n<li>批处理命令连接执行，使用 |</li>\n<li>串联: 使用分号 ;</li>\n<li>前面成功，则执行后面一条，否则，不执行:&amp;&amp;</li>\n<li>前面失败，则后一条执行: ||</li>\n</ul>\n<ol start=\"14\">\n<li>环境变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">启动帐号后自动执行的是 文件为 .profile，然后通过这个文件可设置自己的环境变量；</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"15\">\n<li>文本处理</li>\n</ol>\n<ul>\n<li>find 文件查找<ul>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#id3\" target=\"_blank\" rel=\"noopener\">定制搜索</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#id4\" target=\"_blank\" rel=\"noopener\">找到后的后续动作</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#print\" target=\"_blank\" rel=\"noopener\">-print的定界符</a></li>\n</ul>\n</li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#grep\" target=\"_blank\" rel=\"noopener\">grep 文本搜索</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#xargs\" target=\"_blank\" rel=\"noopener\">xargs 命令行参数转换</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#sort\" target=\"_blank\" rel=\"noopener\">sort 排序</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#uniq\" target=\"_blank\" rel=\"noopener\">uniq 消除重复行</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#tr\" target=\"_blank\" rel=\"noopener\">用tr进行转换</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#cut\" target=\"_blank\" rel=\"noopener\">cut 按列切分文本</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#paste\" target=\"_blank\" rel=\"noopener\">paste 按列拼接文本</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#wc\" target=\"_blank\" rel=\"noopener\">wc 统计行和字符的工具</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#sed\" target=\"_blank\" rel=\"noopener\">sed 文本替换利器</a></li>\n<li><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#awk\" target=\"_blank\" rel=\"noopener\">awk 数据流处理工具</a></li>\n</ul>\n<ol start=\"16\">\n<li>磁盘管理</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看磁盘空间 df -h</span><br><span class=\"line\"></span><br><span class=\"line\">查看目录大小 du -sh</span><br><span class=\"line\"></span><br><span class=\"line\">打包 tar -cvf</span><br><span class=\"line\"></span><br><span class=\"line\">解包 tar -xvf</span><br><span class=\"line\"></span><br><span class=\"line\">压缩 gzip</span><br><span class=\"line\"></span><br><span class=\"line\">解压缩 gunzip bzip</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"17\">\n<li>修改权限</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod</span><br><span class=\"line\"></span><br><span class=\"line\">chrow</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"18\">\n<li>统计qps</li>\n</ol>"},{"title":"【吊打面试官】HTTP，TCP， socket，RPC 与gRPC都是啥？","date":"2020-01-20T16:00:00.000Z","_content":"\n`大家在面试题里看到过那么多次tcp，http， rpc等等，但是一直没有放到一起对比，今天我们一起对比看下，这几个有什么不同`\n\n####  TCP/HTTP与socket\n\n首先回顾下计算机网络的五(七)层协议：物理层、数据链路层、网络层、传输层、(会话层、表示层)和应用层。那么从协议上来讲：\n\n- TCP是传输层协议，主要解决数据如何在网络中传输\n- HTTP 是应用层协议，主要解决如何包装数据（文本信息），是建立在tcp协议之上的应用。TCP协议是以二进制数据流的形式解决传输层的事儿，但对上层的应用开发极不友好，所以面向应用层的开发又产生了HTTP协议。\n\n而socket 是针对TCP或UDP的具体接口实现，提供了在传输层进行网络编程的方法。\n\n以上内容我们应该都听说的比较多了，下面主要来谈一谈RPC。\n\n#### 什么是RPC？\n\n> RPC(Remote Procedure Call)是远程过程调用，比如说现在有两台服务器A, B，一个在A服务器上的应用想要调用B服务器上的应用提供的某个，由于不在两个方法不在一个内存空间，不能直接调用，需要通过网络表达调用的语义和传达调用的数据。常存在于分布式系统中。\n\n*为何有http协议之后，还要RPC调用？*\n\n> RPC跟HTTP不是对立面，RPC中可以使用HTTP作为通讯协议。**RPC是一种设计、实现框架，通讯协议只是其中一部分。**\n>\n> **RPC的本质是提供了一种轻量无感知的跨进程通信的方式**，在分布式机器上调用其他方法与本地调用无异（远程调用的过程是透明的，你并不知道这个调用的方法是部署在哪里，通过PRC能够解耦服务）。RPC是根据语言的API来定义的，而不是基于网络的应用来定义的，调用更方便，协议私密更安全、内容更小效率更高。\n>\n> http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议 进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先（基于TCP协议的情况下）就是长链接，不必每次通信都要像http 一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统 一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。\n\n*RPC 中要解决的问题：*\n\n- 建立通信：在客户端与服务端建立起数据传输通道，大都是TCP连接（gRPC使用了HTTP2）。\n- 寻址：A服务器上的应用需要告诉RPC框架：B服务器地址、端口，调用函数名称。所以必须实现待调用方法到call ID的映射。\n- 序列化与反序列化：由于网络协议都是二进制的，所以调用方法的参数在进行传递时首先要序列化成二进制，B服务器收到请求后要再对参数进行反序列化。恢复为内存中的表达方式，找到对应的方法进行本地调用，得到返回值。返回值从B到A的传输仍要经过序列化与反序列化的过程。\n\n#### 常见名词小结\n\n| 名词   | 特点                                                         |\n| :----- | :----------------------------------------------------------- |\n| RPC    | 远程过程调用（分布式、微服务间的方法调用）                   |\n| HTTP   | 无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp） |\n| TCP    | 面向连接，三次握手保证通信可靠                               |\n| UDP    | 非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ） |\n| socket | TCP协议的接口实现，面向传输层进行网络编程                    |\n\n#### 单独来谈一谈gRPC\n\ngRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。\n\n- 内容交换格式采用ProtoBuf(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。\n- 传输协议 采用http2，性能比http1.1好了很多\n\n和很多RPC系统一样，服务端负责实现定义好的接口并处理客户端的请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用gPRC支持的不同语言实现。\n\nProtoBuf 具有强大的IDL（interface description language，接口描述语言）和相关工具集（主要是protoc）。用户写好.proto描述文件后，protoc可以将其编译成众多语言的接口代码。\n\n#### 补充：HTTP/2介绍\n\n##### 新特性：\n\n- 新的二进制格式\n\n  HTTP1.X都是基于文本解析，而因为文本表现形式的多样性，基于文本协议的格式解析天然存在健壮性问题。而采用二进制格式后实现方便且健壮。\n\n- 多路复用\n\n  多个request共享一个连接。\n\n- header压缩\n\n  在HTTP1.x中header信息很多，且每次都会重复发送，造成很大浪费。HTTP2.0使用encoder减少了传输的header大小，且通信双方都缓存一份包含了header信息的表，此后的请求可以只发送差异数据，避免信息的重复传输，进一步减少需要传输的内容大小。\n\n- 服务端推送\n\n  主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。也遵守同源策略，且客户端可以拒绝推送过来的资源。\n\n#### 推荐阅读：\n\n- [既然有http 请求，为什么还要用rpc调用？](https://link.jianshu.com/?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F41609070)\n- [HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事](https://link.jianshu.com/?t=http%3A%2F%2Fwww.alloyteam.com%2F2016%2F07%2Fhttphttp2-0spdyhttps-reading-this-is-enough%2F)\n- [HTTP/2协议–特性扫盲篇](https://link.jianshu.com/?t=https%3A%2F%2Fwww.cnblogs.com%2Fyingsmirk%2Fp%2F5248506.html)\n- [HTTP/2.0相比1.0有哪些重大改进](https://link.jianshu.com/?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F34074946)\n\n","source":"_posts/面试/要点整理/HTTP，TCP， socket，RPC 与gRPC都是啥？.md","raw":"---\ntitle: 【吊打面试官】HTTP，TCP， socket，RPC 与gRPC都是啥？\ndate: 2020-01-21 \ntags:\n- http\n- rpc\n- thrift\ncategories:\n- 面试\n---\n\n`大家在面试题里看到过那么多次tcp，http， rpc等等，但是一直没有放到一起对比，今天我们一起对比看下，这几个有什么不同`\n\n####  TCP/HTTP与socket\n\n首先回顾下计算机网络的五(七)层协议：物理层、数据链路层、网络层、传输层、(会话层、表示层)和应用层。那么从协议上来讲：\n\n- TCP是传输层协议，主要解决数据如何在网络中传输\n- HTTP 是应用层协议，主要解决如何包装数据（文本信息），是建立在tcp协议之上的应用。TCP协议是以二进制数据流的形式解决传输层的事儿，但对上层的应用开发极不友好，所以面向应用层的开发又产生了HTTP协议。\n\n而socket 是针对TCP或UDP的具体接口实现，提供了在传输层进行网络编程的方法。\n\n以上内容我们应该都听说的比较多了，下面主要来谈一谈RPC。\n\n#### 什么是RPC？\n\n> RPC(Remote Procedure Call)是远程过程调用，比如说现在有两台服务器A, B，一个在A服务器上的应用想要调用B服务器上的应用提供的某个，由于不在两个方法不在一个内存空间，不能直接调用，需要通过网络表达调用的语义和传达调用的数据。常存在于分布式系统中。\n\n*为何有http协议之后，还要RPC调用？*\n\n> RPC跟HTTP不是对立面，RPC中可以使用HTTP作为通讯协议。**RPC是一种设计、实现框架，通讯协议只是其中一部分。**\n>\n> **RPC的本质是提供了一种轻量无感知的跨进程通信的方式**，在分布式机器上调用其他方法与本地调用无异（远程调用的过程是透明的，你并不知道这个调用的方法是部署在哪里，通过PRC能够解耦服务）。RPC是根据语言的API来定义的，而不是基于网络的应用来定义的，调用更方便，协议私密更安全、内容更小效率更高。\n>\n> http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议 进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先（基于TCP协议的情况下）就是长链接，不必每次通信都要像http 一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统 一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。\n\n*RPC 中要解决的问题：*\n\n- 建立通信：在客户端与服务端建立起数据传输通道，大都是TCP连接（gRPC使用了HTTP2）。\n- 寻址：A服务器上的应用需要告诉RPC框架：B服务器地址、端口，调用函数名称。所以必须实现待调用方法到call ID的映射。\n- 序列化与反序列化：由于网络协议都是二进制的，所以调用方法的参数在进行传递时首先要序列化成二进制，B服务器收到请求后要再对参数进行反序列化。恢复为内存中的表达方式，找到对应的方法进行本地调用，得到返回值。返回值从B到A的传输仍要经过序列化与反序列化的过程。\n\n#### 常见名词小结\n\n| 名词   | 特点                                                         |\n| :----- | :----------------------------------------------------------- |\n| RPC    | 远程过程调用（分布式、微服务间的方法调用）                   |\n| HTTP   | 无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp） |\n| TCP    | 面向连接，三次握手保证通信可靠                               |\n| UDP    | 非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ） |\n| socket | TCP协议的接口实现，面向传输层进行网络编程                    |\n\n#### 单独来谈一谈gRPC\n\ngRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。\n\n- 内容交换格式采用ProtoBuf(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。\n- 传输协议 采用http2，性能比http1.1好了很多\n\n和很多RPC系统一样，服务端负责实现定义好的接口并处理客户端的请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用gPRC支持的不同语言实现。\n\nProtoBuf 具有强大的IDL（interface description language，接口描述语言）和相关工具集（主要是protoc）。用户写好.proto描述文件后，protoc可以将其编译成众多语言的接口代码。\n\n#### 补充：HTTP/2介绍\n\n##### 新特性：\n\n- 新的二进制格式\n\n  HTTP1.X都是基于文本解析，而因为文本表现形式的多样性，基于文本协议的格式解析天然存在健壮性问题。而采用二进制格式后实现方便且健壮。\n\n- 多路复用\n\n  多个request共享一个连接。\n\n- header压缩\n\n  在HTTP1.x中header信息很多，且每次都会重复发送，造成很大浪费。HTTP2.0使用encoder减少了传输的header大小，且通信双方都缓存一份包含了header信息的表，此后的请求可以只发送差异数据，避免信息的重复传输，进一步减少需要传输的内容大小。\n\n- 服务端推送\n\n  主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。也遵守同源策略，且客户端可以拒绝推送过来的资源。\n\n#### 推荐阅读：\n\n- [既然有http 请求，为什么还要用rpc调用？](https://link.jianshu.com/?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F41609070)\n- [HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事](https://link.jianshu.com/?t=http%3A%2F%2Fwww.alloyteam.com%2F2016%2F07%2Fhttphttp2-0spdyhttps-reading-this-is-enough%2F)\n- [HTTP/2协议–特性扫盲篇](https://link.jianshu.com/?t=https%3A%2F%2Fwww.cnblogs.com%2Fyingsmirk%2Fp%2F5248506.html)\n- [HTTP/2.0相比1.0有哪些重大改进](https://link.jianshu.com/?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F34074946)\n\n","slug":"面试/要点整理/HTTP，TCP， socket，RPC 与gRPC都是啥？","published":1,"updated":"2020-01-21T10:00:00.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7cxr5dp000q5x8n2v5v2gb4","content":"<p><code>大家在面试题里看到过那么多次tcp，http， rpc等等，但是一直没有放到一起对比，今天我们一起对比看下，这几个有什么不同</code></p>\n<h4 id=\"TCP-HTTP与socket\"><a href=\"#TCP-HTTP与socket\" class=\"headerlink\" title=\"TCP/HTTP与socket\"></a>TCP/HTTP与socket</h4><p>首先回顾下计算机网络的五(七)层协议：物理层、数据链路层、网络层、传输层、(会话层、表示层)和应用层。那么从协议上来讲：</p>\n<ul>\n<li>TCP是传输层协议，主要解决数据如何在网络中传输</li>\n<li>HTTP 是应用层协议，主要解决如何包装数据（文本信息），是建立在tcp协议之上的应用。TCP协议是以二进制数据流的形式解决传输层的事儿，但对上层的应用开发极不友好，所以面向应用层的开发又产生了HTTP协议。</li>\n</ul>\n<p>而socket 是针对TCP或UDP的具体接口实现，提供了在传输层进行网络编程的方法。</p>\n<p>以上内容我们应该都听说的比较多了，下面主要来谈一谈RPC。</p>\n<h4 id=\"什么是RPC？\"><a href=\"#什么是RPC？\" class=\"headerlink\" title=\"什么是RPC？\"></a>什么是RPC？</h4><blockquote>\n<p>RPC(Remote Procedure Call)是远程过程调用，比如说现在有两台服务器A, B，一个在A服务器上的应用想要调用B服务器上的应用提供的某个，由于不在两个方法不在一个内存空间，不能直接调用，需要通过网络表达调用的语义和传达调用的数据。常存在于分布式系统中。</p>\n</blockquote>\n<p><em>为何有http协议之后，还要RPC调用？</em></p>\n<blockquote>\n<p>RPC跟HTTP不是对立面，RPC中可以使用HTTP作为通讯协议。<strong>RPC是一种设计、实现框架，通讯协议只是其中一部分。</strong></p>\n<p><strong>RPC的本质是提供了一种轻量无感知的跨进程通信的方式</strong>，在分布式机器上调用其他方法与本地调用无异（远程调用的过程是透明的，你并不知道这个调用的方法是部署在哪里，通过PRC能够解耦服务）。RPC是根据语言的API来定义的，而不是基于网络的应用来定义的，调用更方便，协议私密更安全、内容更小效率更高。</p>\n<p>http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议 进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先（基于TCP协议的情况下）就是长链接，不必每次通信都要像http 一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统 一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。</p>\n</blockquote>\n<p><em>RPC 中要解决的问题：</em></p>\n<ul>\n<li>建立通信：在客户端与服务端建立起数据传输通道，大都是TCP连接（gRPC使用了HTTP2）。</li>\n<li>寻址：A服务器上的应用需要告诉RPC框架：B服务器地址、端口，调用函数名称。所以必须实现待调用方法到call ID的映射。</li>\n<li>序列化与反序列化：由于网络协议都是二进制的，所以调用方法的参数在进行传递时首先要序列化成二进制，B服务器收到请求后要再对参数进行反序列化。恢复为内存中的表达方式，找到对应的方法进行本地调用，得到返回值。返回值从B到A的传输仍要经过序列化与反序列化的过程。</li>\n</ul>\n<h4 id=\"常见名词小结\"><a href=\"#常见名词小结\" class=\"headerlink\" title=\"常见名词小结\"></a>常见名词小结</h4><table>\n<thead>\n<tr>\n<th align=\"left\">名词</th>\n<th align=\"left\">特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">RPC</td>\n<td align=\"left\">远程过程调用（分布式、微服务间的方法调用）</td>\n</tr>\n<tr>\n<td align=\"left\">HTTP</td>\n<td align=\"left\">无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp）</td>\n</tr>\n<tr>\n<td align=\"left\">TCP</td>\n<td align=\"left\">面向连接，三次握手保证通信可靠</td>\n</tr>\n<tr>\n<td align=\"left\">UDP</td>\n<td align=\"left\">非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ）</td>\n</tr>\n<tr>\n<td align=\"left\">socket</td>\n<td align=\"left\">TCP协议的接口实现，面向传输层进行网络编程</td>\n</tr>\n</tbody></table>\n<h4 id=\"单独来谈一谈gRPC\"><a href=\"#单独来谈一谈gRPC\" class=\"headerlink\" title=\"单独来谈一谈gRPC\"></a>单独来谈一谈gRPC</h4><p>gRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。</p>\n<ul>\n<li>内容交换格式采用ProtoBuf(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。</li>\n<li>传输协议 采用http2，性能比http1.1好了很多</li>\n</ul>\n<p>和很多RPC系统一样，服务端负责实现定义好的接口并处理客户端的请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用gPRC支持的不同语言实现。</p>\n<p>ProtoBuf 具有强大的IDL（interface description language，接口描述语言）和相关工具集（主要是protoc）。用户写好.proto描述文件后，protoc可以将其编译成众多语言的接口代码。</p>\n<h4 id=\"补充：HTTP-2介绍\"><a href=\"#补充：HTTP-2介绍\" class=\"headerlink\" title=\"补充：HTTP/2介绍\"></a>补充：HTTP/2介绍</h4><h5 id=\"新特性：\"><a href=\"#新特性：\" class=\"headerlink\" title=\"新特性：\"></a>新特性：</h5><ul>\n<li><p>新的二进制格式</p>\n<p>HTTP1.X都是基于文本解析，而因为文本表现形式的多样性，基于文本协议的格式解析天然存在健壮性问题。而采用二进制格式后实现方便且健壮。</p>\n</li>\n<li><p>多路复用</p>\n<p>多个request共享一个连接。</p>\n</li>\n<li><p>header压缩</p>\n<p>在HTTP1.x中header信息很多，且每次都会重复发送，造成很大浪费。HTTP2.0使用encoder减少了传输的header大小，且通信双方都缓存一份包含了header信息的表，此后的请求可以只发送差异数据，避免信息的重复传输，进一步减少需要传输的内容大小。</p>\n</li>\n<li><p>服务端推送</p>\n<p>主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。也遵守同源策略，且客户端可以拒绝推送过来的资源。</p>\n</li>\n</ul>\n<h4 id=\"推荐阅读：\"><a href=\"#推荐阅读：\" class=\"headerlink\" title=\"推荐阅读：\"></a>推荐阅读：</h4><ul>\n<li><a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F41609070\" target=\"_blank\" rel=\"noopener\">既然有http 请求，为什么还要用rpc调用？</a></li>\n<li><a href=\"https://link.jianshu.com/?t=http%3A%2F%2Fwww.alloyteam.com%2F2016%2F07%2Fhttphttp2-0spdyhttps-reading-this-is-enough%2F\" target=\"_blank\" rel=\"noopener\">HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事</a></li>\n<li><a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fwww.cnblogs.com%2Fyingsmirk%2Fp%2F5248506.html\" target=\"_blank\" rel=\"noopener\">HTTP/2协议–特性扫盲篇</a></li>\n<li><a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F34074946\" target=\"_blank\" rel=\"noopener\">HTTP/2.0相比1.0有哪些重大改进</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><code>大家在面试题里看到过那么多次tcp，http， rpc等等，但是一直没有放到一起对比，今天我们一起对比看下，这几个有什么不同</code></p>\n<h4 id=\"TCP-HTTP与socket\"><a href=\"#TCP-HTTP与socket\" class=\"headerlink\" title=\"TCP/HTTP与socket\"></a>TCP/HTTP与socket</h4><p>首先回顾下计算机网络的五(七)层协议：物理层、数据链路层、网络层、传输层、(会话层、表示层)和应用层。那么从协议上来讲：</p>\n<ul>\n<li>TCP是传输层协议，主要解决数据如何在网络中传输</li>\n<li>HTTP 是应用层协议，主要解决如何包装数据（文本信息），是建立在tcp协议之上的应用。TCP协议是以二进制数据流的形式解决传输层的事儿，但对上层的应用开发极不友好，所以面向应用层的开发又产生了HTTP协议。</li>\n</ul>\n<p>而socket 是针对TCP或UDP的具体接口实现，提供了在传输层进行网络编程的方法。</p>\n<p>以上内容我们应该都听说的比较多了，下面主要来谈一谈RPC。</p>\n<h4 id=\"什么是RPC？\"><a href=\"#什么是RPC？\" class=\"headerlink\" title=\"什么是RPC？\"></a>什么是RPC？</h4><blockquote>\n<p>RPC(Remote Procedure Call)是远程过程调用，比如说现在有两台服务器A, B，一个在A服务器上的应用想要调用B服务器上的应用提供的某个，由于不在两个方法不在一个内存空间，不能直接调用，需要通过网络表达调用的语义和传达调用的数据。常存在于分布式系统中。</p>\n</blockquote>\n<p><em>为何有http协议之后，还要RPC调用？</em></p>\n<blockquote>\n<p>RPC跟HTTP不是对立面，RPC中可以使用HTTP作为通讯协议。<strong>RPC是一种设计、实现框架，通讯协议只是其中一部分。</strong></p>\n<p><strong>RPC的本质是提供了一种轻量无感知的跨进程通信的方式</strong>，在分布式机器上调用其他方法与本地调用无异（远程调用的过程是透明的，你并不知道这个调用的方法是部署在哪里，通过PRC能够解耦服务）。RPC是根据语言的API来定义的，而不是基于网络的应用来定义的，调用更方便，协议私密更安全、内容更小效率更高。</p>\n<p>http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议 进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先（基于TCP协议的情况下）就是长链接，不必每次通信都要像http 一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统 一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。</p>\n</blockquote>\n<p><em>RPC 中要解决的问题：</em></p>\n<ul>\n<li>建立通信：在客户端与服务端建立起数据传输通道，大都是TCP连接（gRPC使用了HTTP2）。</li>\n<li>寻址：A服务器上的应用需要告诉RPC框架：B服务器地址、端口，调用函数名称。所以必须实现待调用方法到call ID的映射。</li>\n<li>序列化与反序列化：由于网络协议都是二进制的，所以调用方法的参数在进行传递时首先要序列化成二进制，B服务器收到请求后要再对参数进行反序列化。恢复为内存中的表达方式，找到对应的方法进行本地调用，得到返回值。返回值从B到A的传输仍要经过序列化与反序列化的过程。</li>\n</ul>\n<h4 id=\"常见名词小结\"><a href=\"#常见名词小结\" class=\"headerlink\" title=\"常见名词小结\"></a>常见名词小结</h4><table>\n<thead>\n<tr>\n<th align=\"left\">名词</th>\n<th align=\"left\">特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">RPC</td>\n<td align=\"left\">远程过程调用（分布式、微服务间的方法调用）</td>\n</tr>\n<tr>\n<td align=\"left\">HTTP</td>\n<td align=\"left\">无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp）</td>\n</tr>\n<tr>\n<td align=\"left\">TCP</td>\n<td align=\"left\">面向连接，三次握手保证通信可靠</td>\n</tr>\n<tr>\n<td align=\"left\">UDP</td>\n<td align=\"left\">非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ）</td>\n</tr>\n<tr>\n<td align=\"left\">socket</td>\n<td align=\"left\">TCP协议的接口实现，面向传输层进行网络编程</td>\n</tr>\n</tbody></table>\n<h4 id=\"单独来谈一谈gRPC\"><a href=\"#单独来谈一谈gRPC\" class=\"headerlink\" title=\"单独来谈一谈gRPC\"></a>单独来谈一谈gRPC</h4><p>gRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。</p>\n<ul>\n<li>内容交换格式采用ProtoBuf(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。</li>\n<li>传输协议 采用http2，性能比http1.1好了很多</li>\n</ul>\n<p>和很多RPC系统一样，服务端负责实现定义好的接口并处理客户端的请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用gPRC支持的不同语言实现。</p>\n<p>ProtoBuf 具有强大的IDL（interface description language，接口描述语言）和相关工具集（主要是protoc）。用户写好.proto描述文件后，protoc可以将其编译成众多语言的接口代码。</p>\n<h4 id=\"补充：HTTP-2介绍\"><a href=\"#补充：HTTP-2介绍\" class=\"headerlink\" title=\"补充：HTTP/2介绍\"></a>补充：HTTP/2介绍</h4><h5 id=\"新特性：\"><a href=\"#新特性：\" class=\"headerlink\" title=\"新特性：\"></a>新特性：</h5><ul>\n<li><p>新的二进制格式</p>\n<p>HTTP1.X都是基于文本解析，而因为文本表现形式的多样性，基于文本协议的格式解析天然存在健壮性问题。而采用二进制格式后实现方便且健壮。</p>\n</li>\n<li><p>多路复用</p>\n<p>多个request共享一个连接。</p>\n</li>\n<li><p>header压缩</p>\n<p>在HTTP1.x中header信息很多，且每次都会重复发送，造成很大浪费。HTTP2.0使用encoder减少了传输的header大小，且通信双方都缓存一份包含了header信息的表，此后的请求可以只发送差异数据，避免信息的重复传输，进一步减少需要传输的内容大小。</p>\n</li>\n<li><p>服务端推送</p>\n<p>主要的思想是：当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。这个功能帮助客户端将Z放进缓存以备将来之需。也遵守同源策略，且客户端可以拒绝推送过来的资源。</p>\n</li>\n</ul>\n<h4 id=\"推荐阅读：\"><a href=\"#推荐阅读：\" class=\"headerlink\" title=\"推荐阅读：\"></a>推荐阅读：</h4><ul>\n<li><a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F41609070\" target=\"_blank\" rel=\"noopener\">既然有http 请求，为什么还要用rpc调用？</a></li>\n<li><a href=\"https://link.jianshu.com/?t=http%3A%2F%2Fwww.alloyteam.com%2F2016%2F07%2Fhttphttp2-0spdyhttps-reading-this-is-enough%2F\" target=\"_blank\" rel=\"noopener\">HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事</a></li>\n<li><a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fwww.cnblogs.com%2Fyingsmirk%2Fp%2F5248506.html\" target=\"_blank\" rel=\"noopener\">HTTP/2协议–特性扫盲篇</a></li>\n<li><a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F34074946\" target=\"_blank\" rel=\"noopener\">HTTP/2.0相比1.0有哪些重大改进</a></li>\n</ul>\n"},{"title":"【第一课】数据库","date":"2019-11-08T08:14:00.000Z","_content":"\n\n\n> 本篇文章主要就数据库的常见问题进行了讨论\n\n<!-- more -->\n\n###  事务的特性\n\n```\nacid 原子性，一致性 隔离性 持久性\n事务隔离分为： \n读取未提交数据 读取其他事务提交数据\n可重读 串行化  \n```\n\n\n\n### myisam和innodb的区别\n\n```\n采用MyISAM引擎\n- R/W > 100:1 且update相对较少\n- 并发不高\n- 表数据量小\n- 硬件资源有限\n- 不支持外键\n- 不支持事务\n- 执行selecte较多的时候优先使用\n- 表锁\n- 不会死锁\n\n采用InnoDB引擎\n- R/W比较小，频繁更新大字段\n- 表数据量超过1000万，并发高\n- 安全性和可用性要求高\n- 支持外键\n- 执行update inser较多的时候优先使用\n- delete的时候 innodb会一行一行的删除\n- 行锁\n```\n\n\n\n\n\n### mysql 性能调优\n\n```\n开启查询缓存\nexplain下自己的sql语句并分析\n只用一行数据的话 limit 1\n为搜索字段建索引\n千万不要order by rand()\n避免selecte *\n不要设置null\n尽量少的多表查询\n拆分大的delete和insert语句， 因为这个操作会锁表，最好不要占用太久\n选择合适的存储引擎\n冗余数据\n使用尽可能小的合适的数据类型\n读写分离\n拆分表 垂直拆分和水平拆分\n在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。\n\n分析过程：\n是否有周期性的崩溃-》 增加缓存\n开启profiling查询慢日志和explain来分析\n等待时间长-》对服务器调优\n执行时间长-》对语句调优\n还不行-> 增加硬件\n```\n\n\n\n\n\n### 索引的实现\n\n```\n索引（Index）是帮助MySQL高效获取数据的数据结构\nmysql的索引是b+树\nInnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的\n```\n\n\n\n\n\n### mysql表示时间\n\n数据库中可以用datetime、bigint、timestamp来表示时间\n\n\n\n### 索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？\n\n```\n答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。\n\n第一种情况是表记录比较少 另一种不建议建索引的情况是索引的选择性较低。\n```\n\n\n\n### 什么是脏读，不可重复读，幻读](https://juejin.im/entry/5b835dfbf265da43531d0593)\n\n```\n脏读 一个事务中访问到了另外一个事务未提交的数据\n不可重复读 一个事务读取同一条记录2次，得到的结果不一致\n幻读 一个事务读取2次，得到的记录条数不一致\n```\n\n\n\n\n\n### 乐观锁\n\n使用数据版本来实现。\n\n\n\n### 悲观锁\n\n```\n共享锁\n排它锁\n```\n\n\n\n\n\n### 产生死锁的原因\n\n```\n（1） 因为系统资源不足。\n（2） 进程运行推进的顺序不合适。\n（3） 资源分配不当等。\n```\n\n\n\n### 产生死锁的四个必要条件\n\n```\n（1） 互斥条件：一个资源每次只能被一个进程使用。\n（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。\n（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n```\n\n\n\n\n\n### 死锁\n\n```\n（1）死锁预防：通过确保死锁的一个必要条件不会满足，保证不会发生死锁\n（2）死锁检测：允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉\n（3）死锁避免：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁\n（4）死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。\n```\n\n\n\n\n\n### 存储过程\n\n```\n### mvcc\nhttp://blog.codinglabs.org/articles/theory-of-mysql-index.html\nhttps://www.jianshu.com/p/86a1fd2d7406\n```\n\n","source":"_posts/面试/要点整理/数据库.md","raw":"---\ntitle: 【第一课】数据库\ndate: 2019-11-08 16:14:00\ntags:\n- 数据库\n- MYSQL\ncategories:\n- 面试\n---\n\n\n\n> 本篇文章主要就数据库的常见问题进行了讨论\n\n<!-- more -->\n\n###  事务的特性\n\n```\nacid 原子性，一致性 隔离性 持久性\n事务隔离分为： \n读取未提交数据 读取其他事务提交数据\n可重读 串行化  \n```\n\n\n\n### myisam和innodb的区别\n\n```\n采用MyISAM引擎\n- R/W > 100:1 且update相对较少\n- 并发不高\n- 表数据量小\n- 硬件资源有限\n- 不支持外键\n- 不支持事务\n- 执行selecte较多的时候优先使用\n- 表锁\n- 不会死锁\n\n采用InnoDB引擎\n- R/W比较小，频繁更新大字段\n- 表数据量超过1000万，并发高\n- 安全性和可用性要求高\n- 支持外键\n- 执行update inser较多的时候优先使用\n- delete的时候 innodb会一行一行的删除\n- 行锁\n```\n\n\n\n\n\n### mysql 性能调优\n\n```\n开启查询缓存\nexplain下自己的sql语句并分析\n只用一行数据的话 limit 1\n为搜索字段建索引\n千万不要order by rand()\n避免selecte *\n不要设置null\n尽量少的多表查询\n拆分大的delete和insert语句， 因为这个操作会锁表，最好不要占用太久\n选择合适的存储引擎\n冗余数据\n使用尽可能小的合适的数据类型\n读写分离\n拆分表 垂直拆分和水平拆分\n在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。\n\n分析过程：\n是否有周期性的崩溃-》 增加缓存\n开启profiling查询慢日志和explain来分析\n等待时间长-》对服务器调优\n执行时间长-》对语句调优\n还不行-> 增加硬件\n```\n\n\n\n\n\n### 索引的实现\n\n```\n索引（Index）是帮助MySQL高效获取数据的数据结构\nmysql的索引是b+树\nInnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的\n```\n\n\n\n\n\n### mysql表示时间\n\n数据库中可以用datetime、bigint、timestamp来表示时间\n\n\n\n### 索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？\n\n```\n答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。\n\n第一种情况是表记录比较少 另一种不建议建索引的情况是索引的选择性较低。\n```\n\n\n\n### 什么是脏读，不可重复读，幻读](https://juejin.im/entry/5b835dfbf265da43531d0593)\n\n```\n脏读 一个事务中访问到了另外一个事务未提交的数据\n不可重复读 一个事务读取同一条记录2次，得到的结果不一致\n幻读 一个事务读取2次，得到的记录条数不一致\n```\n\n\n\n\n\n### 乐观锁\n\n使用数据版本来实现。\n\n\n\n### 悲观锁\n\n```\n共享锁\n排它锁\n```\n\n\n\n\n\n### 产生死锁的原因\n\n```\n（1） 因为系统资源不足。\n（2） 进程运行推进的顺序不合适。\n（3） 资源分配不当等。\n```\n\n\n\n### 产生死锁的四个必要条件\n\n```\n（1） 互斥条件：一个资源每次只能被一个进程使用。\n（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。\n（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。\n（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。\n```\n\n\n\n\n\n### 死锁\n\n```\n（1）死锁预防：通过确保死锁的一个必要条件不会满足，保证不会发生死锁\n（2）死锁检测：允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉\n（3）死锁避免：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁\n（4）死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。\n```\n\n\n\n\n\n### 存储过程\n\n```\n### mvcc\nhttp://blog.codinglabs.org/articles/theory-of-mysql-index.html\nhttps://www.jianshu.com/p/86a1fd2d7406\n```\n\n","slug":"面试/要点整理/数据库","published":1,"updated":"2020-03-23T07:17:35.609Z","_id":"ck7cxr5dq000t5x8ng8u5axpm","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本篇文章主要就数据库的常见问题进行了讨论</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acid 原子性，一致性 隔离性 持久性</span><br><span class=\"line\">事务隔离分为： </span><br><span class=\"line\">读取未提交数据 读取其他事务提交数据</span><br><span class=\"line\">可重读 串行化</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"myisam和innodb的区别\"><a href=\"#myisam和innodb的区别\" class=\"headerlink\" title=\"myisam和innodb的区别\"></a>myisam和innodb的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">采用MyISAM引擎</span><br><span class=\"line\">- R&#x2F;W &gt; 100:1 且update相对较少</span><br><span class=\"line\">- 并发不高</span><br><span class=\"line\">- 表数据量小</span><br><span class=\"line\">- 硬件资源有限</span><br><span class=\"line\">- 不支持外键</span><br><span class=\"line\">- 不支持事务</span><br><span class=\"line\">- 执行selecte较多的时候优先使用</span><br><span class=\"line\">- 表锁</span><br><span class=\"line\">- 不会死锁</span><br><span class=\"line\"></span><br><span class=\"line\">采用InnoDB引擎</span><br><span class=\"line\">- R&#x2F;W比较小，频繁更新大字段</span><br><span class=\"line\">- 表数据量超过1000万，并发高</span><br><span class=\"line\">- 安全性和可用性要求高</span><br><span class=\"line\">- 支持外键</span><br><span class=\"line\">- 执行update inser较多的时候优先使用</span><br><span class=\"line\">- delete的时候 innodb会一行一行的删除</span><br><span class=\"line\">- 行锁</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"mysql-性能调优\"><a href=\"#mysql-性能调优\" class=\"headerlink\" title=\"mysql 性能调优\"></a>mysql 性能调优</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开启查询缓存</span><br><span class=\"line\">explain下自己的sql语句并分析</span><br><span class=\"line\">只用一行数据的话 limit 1</span><br><span class=\"line\">为搜索字段建索引</span><br><span class=\"line\">千万不要order by rand()</span><br><span class=\"line\">避免selecte *</span><br><span class=\"line\">不要设置null</span><br><span class=\"line\">尽量少的多表查询</span><br><span class=\"line\">拆分大的delete和insert语句， 因为这个操作会锁表，最好不要占用太久</span><br><span class=\"line\">选择合适的存储引擎</span><br><span class=\"line\">冗余数据</span><br><span class=\"line\">使用尽可能小的合适的数据类型</span><br><span class=\"line\">读写分离</span><br><span class=\"line\">拆分表 垂直拆分和水平拆分</span><br><span class=\"line\">在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</span><br><span class=\"line\"></span><br><span class=\"line\">分析过程：</span><br><span class=\"line\">是否有周期性的崩溃-》 增加缓存</span><br><span class=\"line\">开启profiling查询慢日志和explain来分析</span><br><span class=\"line\">等待时间长-》对服务器调优</span><br><span class=\"line\">执行时间长-》对语句调优</span><br><span class=\"line\">还不行-&gt; 增加硬件</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"索引的实现\"><a href=\"#索引的实现\" class=\"headerlink\" title=\"索引的实现\"></a>索引的实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">索引（Index）是帮助MySQL高效获取数据的数据结构</span><br><span class=\"line\">mysql的索引是b+树</span><br><span class=\"line\">InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"mysql表示时间\"><a href=\"#mysql表示时间\" class=\"headerlink\" title=\"mysql表示时间\"></a>mysql表示时间</h3><p>数据库中可以用datetime、bigint、timestamp来表示时间</p>\n<h3 id=\"索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？\"><a href=\"#索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？\" class=\"headerlink\" title=\"索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？\"></a>索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</span><br><span class=\"line\"></span><br><span class=\"line\">第一种情况是表记录比较少 另一种不建议建索引的情况是索引的选择性较低。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"什么是脏读，不可重复读，幻读-https-juejin-im-entry-5b835dfbf265da43531d0593\"><a href=\"#什么是脏读，不可重复读，幻读-https-juejin-im-entry-5b835dfbf265da43531d0593\" class=\"headerlink\" title=\"什么是脏读，不可重复读，幻读](https://juejin.im/entry/5b835dfbf265da43531d0593)\"></a>什么是脏读，不可重复读，幻读](<a href=\"https://juejin.im/entry/5b835dfbf265da43531d0593\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5b835dfbf265da43531d0593</a>)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">脏读 一个事务中访问到了另外一个事务未提交的数据</span><br><span class=\"line\">不可重复读 一个事务读取同一条记录2次，得到的结果不一致</span><br><span class=\"line\">幻读 一个事务读取2次，得到的记录条数不一致</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h3><p>使用数据版本来实现。</p>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">共享锁</span><br><span class=\"line\">排它锁</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"产生死锁的原因\"><a href=\"#产生死锁的原因\" class=\"headerlink\" title=\"产生死锁的原因\"></a>产生死锁的原因</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1） 因为系统资源不足。</span><br><span class=\"line\">（2） 进程运行推进的顺序不合适。</span><br><span class=\"line\">（3） 资源分配不当等。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"产生死锁的四个必要条件\"><a href=\"#产生死锁的四个必要条件\" class=\"headerlink\" title=\"产生死锁的四个必要条件\"></a>产生死锁的四个必要条件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1） 互斥条件：一个资源每次只能被一个进程使用。</span><br><span class=\"line\">（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span><br><span class=\"line\">（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</span><br><span class=\"line\">（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）死锁预防：通过确保死锁的一个必要条件不会满足，保证不会发生死锁</span><br><span class=\"line\">（2）死锁检测：允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉</span><br><span class=\"line\">（3）死锁避免：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁</span><br><span class=\"line\">（4）死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### mvcc</span><br><span class=\"line\">http:&#x2F;&#x2F;blog.codinglabs.org&#x2F;articles&#x2F;theory-of-mysql-index.html</span><br><span class=\"line\">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;86a1fd2d7406</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本篇文章主要就数据库的常见问题进行了讨论</p>\n</blockquote>","more":"<h3 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acid 原子性，一致性 隔离性 持久性</span><br><span class=\"line\">事务隔离分为： </span><br><span class=\"line\">读取未提交数据 读取其他事务提交数据</span><br><span class=\"line\">可重读 串行化</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"myisam和innodb的区别\"><a href=\"#myisam和innodb的区别\" class=\"headerlink\" title=\"myisam和innodb的区别\"></a>myisam和innodb的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">采用MyISAM引擎</span><br><span class=\"line\">- R&#x2F;W &gt; 100:1 且update相对较少</span><br><span class=\"line\">- 并发不高</span><br><span class=\"line\">- 表数据量小</span><br><span class=\"line\">- 硬件资源有限</span><br><span class=\"line\">- 不支持外键</span><br><span class=\"line\">- 不支持事务</span><br><span class=\"line\">- 执行selecte较多的时候优先使用</span><br><span class=\"line\">- 表锁</span><br><span class=\"line\">- 不会死锁</span><br><span class=\"line\"></span><br><span class=\"line\">采用InnoDB引擎</span><br><span class=\"line\">- R&#x2F;W比较小，频繁更新大字段</span><br><span class=\"line\">- 表数据量超过1000万，并发高</span><br><span class=\"line\">- 安全性和可用性要求高</span><br><span class=\"line\">- 支持外键</span><br><span class=\"line\">- 执行update inser较多的时候优先使用</span><br><span class=\"line\">- delete的时候 innodb会一行一行的删除</span><br><span class=\"line\">- 行锁</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"mysql-性能调优\"><a href=\"#mysql-性能调优\" class=\"headerlink\" title=\"mysql 性能调优\"></a>mysql 性能调优</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开启查询缓存</span><br><span class=\"line\">explain下自己的sql语句并分析</span><br><span class=\"line\">只用一行数据的话 limit 1</span><br><span class=\"line\">为搜索字段建索引</span><br><span class=\"line\">千万不要order by rand()</span><br><span class=\"line\">避免selecte *</span><br><span class=\"line\">不要设置null</span><br><span class=\"line\">尽量少的多表查询</span><br><span class=\"line\">拆分大的delete和insert语句， 因为这个操作会锁表，最好不要占用太久</span><br><span class=\"line\">选择合适的存储引擎</span><br><span class=\"line\">冗余数据</span><br><span class=\"line\">使用尽可能小的合适的数据类型</span><br><span class=\"line\">读写分离</span><br><span class=\"line\">拆分表 垂直拆分和水平拆分</span><br><span class=\"line\">在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</span><br><span class=\"line\"></span><br><span class=\"line\">分析过程：</span><br><span class=\"line\">是否有周期性的崩溃-》 增加缓存</span><br><span class=\"line\">开启profiling查询慢日志和explain来分析</span><br><span class=\"line\">等待时间长-》对服务器调优</span><br><span class=\"line\">执行时间长-》对语句调优</span><br><span class=\"line\">还不行-&gt; 增加硬件</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"索引的实现\"><a href=\"#索引的实现\" class=\"headerlink\" title=\"索引的实现\"></a>索引的实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">索引（Index）是帮助MySQL高效获取数据的数据结构</span><br><span class=\"line\">mysql的索引是b+树</span><br><span class=\"line\">InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"mysql表示时间\"><a href=\"#mysql表示时间\" class=\"headerlink\" title=\"mysql表示时间\"></a>mysql表示时间</h3><p>数据库中可以用datetime、bigint、timestamp来表示时间</p>\n<h3 id=\"索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？\"><a href=\"#索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？\" class=\"headerlink\" title=\"索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？\"></a>索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</span><br><span class=\"line\"></span><br><span class=\"line\">第一种情况是表记录比较少 另一种不建议建索引的情况是索引的选择性较低。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"什么是脏读，不可重复读，幻读-https-juejin-im-entry-5b835dfbf265da43531d0593\"><a href=\"#什么是脏读，不可重复读，幻读-https-juejin-im-entry-5b835dfbf265da43531d0593\" class=\"headerlink\" title=\"什么是脏读，不可重复读，幻读](https://juejin.im/entry/5b835dfbf265da43531d0593)\"></a>什么是脏读，不可重复读，幻读](<a href=\"https://juejin.im/entry/5b835dfbf265da43531d0593\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5b835dfbf265da43531d0593</a>)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">脏读 一个事务中访问到了另外一个事务未提交的数据</span><br><span class=\"line\">不可重复读 一个事务读取同一条记录2次，得到的结果不一致</span><br><span class=\"line\">幻读 一个事务读取2次，得到的记录条数不一致</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h3><p>使用数据版本来实现。</p>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">共享锁</span><br><span class=\"line\">排它锁</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"产生死锁的原因\"><a href=\"#产生死锁的原因\" class=\"headerlink\" title=\"产生死锁的原因\"></a>产生死锁的原因</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1） 因为系统资源不足。</span><br><span class=\"line\">（2） 进程运行推进的顺序不合适。</span><br><span class=\"line\">（3） 资源分配不当等。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"产生死锁的四个必要条件\"><a href=\"#产生死锁的四个必要条件\" class=\"headerlink\" title=\"产生死锁的四个必要条件\"></a>产生死锁的四个必要条件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1） 互斥条件：一个资源每次只能被一个进程使用。</span><br><span class=\"line\">（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</span><br><span class=\"line\">（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</span><br><span class=\"line\">（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）死锁预防：通过确保死锁的一个必要条件不会满足，保证不会发生死锁</span><br><span class=\"line\">（2）死锁检测：允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉</span><br><span class=\"line\">（3）死锁避免：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁</span><br><span class=\"line\">（4）死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### mvcc</span><br><span class=\"line\">http:&#x2F;&#x2F;blog.codinglabs.org&#x2F;articles&#x2F;theory-of-mysql-index.html</span><br><span class=\"line\">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;86a1fd2d7406</span><br></pre></td></tr></table></figure>"},{"title":"【第一课】缓存","date":"2019-11-04T16:00:00.000Z","_content":"\n> 本篇文章主要就redis的常见面试问题进行了讨论\n\n<!-- more -->\n\n## 为什么用redis？\n\n```\n因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有 **Redis** 和 **Memcached** 不过中和考虑了他们的优缺点，最后选择了Redis。\n```\n\n## redis和memecache的区别\n\n```\n存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。\n数据支持类型 Memcache对数据类型支持相对简单。Redis有复杂的数据类型。redis的数据类型更多string,set,zset, list, hash, ， memcache只支持简单字符串\n使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。\nvalue大小 redis最大可以达到1GB，而memcache只有1MB\nredis支持数据备份 即主从备份\nredis支持数据的持久化 可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\n```\n\n\n\n## 为什么要用缓存？\n\n```\n对于一个服务其性能瓶颈往往都在DB，传统关系型存储尤甚。我们在创建表的时候，并不会未所有的字段创建索引，这意味着如果我们需要读取非缓存数据就要从磁盘拿数据。这个过程至少需要十几毫秒的时间。而缓存往往是基于内存的，这要比DB读数据快两个数量级。这是我们用缓存的根本原因原因。\n```\n\n\n\n## 缓存这么好，为什么不都用缓存\n\n```\n内存这东西虽然很快，同时它还很贵。动辄百十来G的数据都扔内存这有点太浪费。依据二八定律，我们只需找到那最紧俏的百分之二十就行了。这是非常重要的。否则你加了缓存效果反而更差。对于缓存有一个衡量指标，叫做缓存命中率。这个指标高说明我们请求的数据大部分来自缓存。证明我们加缓存这件事的收益越高。\n```\n\n\n\n## 缓存适用的场景\n\n```\n会话缓存 如存储用户购物车中的数据的时候，利用redis持久化的特点，使其不会丢失数据。\n全页缓存 缓存页内数据\n队列 利用redis的list数据结构的push/pop操作， 对数据进行操作\n排行榜 利用zset数据结构进行rank排行操作\n计数器 使用set来统计集合内的数据量\n订阅发布 利用订阅发布功能功能甚至可以搭建聊天室\n```\n\n## 缓存穿透\n\n```\n缓存穿透指的是如果我们访问一个缓存中没有的数据的时候就会去查询数据库， 如果数据库里也没有的话，一般是不更新缓存的， 这时候如果用户一直刷就会造成缓存穿透\n缓存空对象 或者缓存预测\n```\n\n\n\n## 缓存击穿\n\n```\n多个用户同时访问一个热点缓存，在这个key失效的瞬间 就会造成多次访问数据库， 造成缓存击穿。\n缓存预热 缓存加锁\n```\n\n\n\n## 缓存防雪崩\n\n```\n缓存服务暂时崩溃，导致大量请求访问数据库。\n采用高可用的缓存方案 限流\n```\n\n\n\n## redis的新增数据结构\n\n```\ngeo 地理索引 基于zset\nHyperLogLog 寻找集合中的基数，即去重后的数据\npub/sub 发布订阅，如上文\n```\n\n\n\n## 如果有大量的key需要设置同一时间过期，一般需要注意什么？\n\n```\n如果我们过期时间设在同一时间，很有可能会造成缓存雪崩，大量访问指向数据库， 我们给定时时间一个随机值\n```\n\n\n\n## 那你使用过Redis分布式锁么，它是什么回事？\n\n```\n先使用setnx争抢锁 用expire给这个key添加过期时间，防止忘记释放。\n```\n\n\n\n## 然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？\n\n```\n这时候这个锁就永远无法释放了。 可以通过set里的nx,ex两个命令行参数来进行原子化操作。\n```\n\n\n\n## 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？\n\n```\n使用keys命令可以扫出制定模式的\n```\n\n\n\n## 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？\n\n```\nredis是单线程的，线上会停顿，直到这个指令结束。 使用scan可以无阻塞的提出指定模式的keys，但是可能会重复\n```\n\n\n\n## 使用redis怎么实现异步队列？\n\n```\n使用list数据类型， rpush 发送消息， lpop接收消息， 接收不到消息的时候适当的sleep一段时间\n```\n\n\n\n## 可不可以不用sleep\n\n```\nlist有个指令 blpop 可以在消息不来的时候阻塞住知道消息到来\n```\n\n\n\n## 能不能一次生产 多次消费\n\n```\n使用pub/sub模式，可以实现1:n的消息队列\n```\n\n\n\n## pub/sub有什么缺点\n\n```\n一旦消费者下线， 消息就会丢失。 建议还是使用专业的消息队列， \\**RocketMQ rabbitmq\\*\n```\n\n\n\n## Redis如何实现延时队列？\n\n```\n使用zset 值为时间戳 key为消息内容 使用zadd添加消息 使用zrangebyscore获取n秒前的数据。\n```\n\n\n\n## redis怎么持久化的 主从数据怎么进行交互？\n\n```\nrdb进行镜像全量同步， aof做增量持久化。 因为rdb耗费时间较久 需要配合aof来使用。 当redis重启时， 使用rdb持久化文件重新构建内存， 再用aof重放近期的操作指令来恢复重启前的状态\n```\n\n\n\n## 突然停电怎么办\n\n```\n取决于 aof的sync配置，如果不考虑性能的话每条指令后都sync下就不会丢失，但是一般来说，不会这么配置，如果配置每秒同步一次的话，丢失的就是这一秒的数据\n```\n\n\n\n## rdb的原理\n\n```\nfork 和 cow 父进程fork一个子进程，并且开始进行rdb， 子进程创建后，父子共享数据段， 父进程继续进行读写操作。\nredis每隔几分钟形成一个快照\n\n- rdb\n保存了redis某个时间点的数据集合， 体积较小\n适合用于灾难回复 恢复大量数据的时候比aof快 但是会丢失数据\n\n- aof\n同步频率快且不影响redis性能。\n有序追加对redis的操作指令\n但是体积较大\n```\n\n\n\n## Pipline的好处是什么\n\n```\n可以把多次io缩减为1次\n```\n\n\n\n## redis的同步机制\n\n```\n主从同步和从从同步， 主节点做一次bgsave，生成rdb镜像， 并保存后续的操作记录。 待完成后，主节点把rdb全量同步给复制节点， 复制节点加载完rdb后， 增量数据使用aof同步。\n```\n\n\n\n## redis集群的高可用怎么保证， 原理是什么\n\n```\nRedis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。   \nRedis Cluster  着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。\n```\n\n\n\n## pika和redis\n\n```\npika相对于redis，最大的不同就是pika是持久化存储，数据存在磁盘上，而redis是内存存储，由此不同也给pika带来了相对于redis的优势和劣势**\n\n大容量redis 遇到的问题\n\n- 恢复时间长\n- 一主多从, 主从切换代价大\n- 缓冲区写满问题\n- 内存太贵\n\nPika的特点\n\n1. 容量大，支持百G数据量的存储\n2. 兼容Redis，不用修改代码即可平滑从Redis迁移到Pika\n3. 支持主从(slaveof)\n4. 完善的运维命令\n\n优势:\n\n- 容量大：Pika没有Redis的内存限制, 最大使用空间等于磁盘空间的大小**\n- 加载db速度快：Pika 在写入的时候, 数据是落盘的, 所以即使节点挂了, 不需要rbd或者aof，pika 重启不用重新加载数据到内存而是直接使用已经持久化在磁盘上的数据, 不需要任何数据回放操作，这大大降低了重启成本。**\n- 备份速度快：Pika备份的速度大致等同于cp的速度（拷贝数据文件后还有一个快照的恢复过程，会花费一些时间），这样在对于百G大库的备份是快捷的，更快的备份速度更好的解决了主从的全同步问题\n\n劣势：\n\n由于Pika是基于内存和文件来存放数据, 所以性能肯定比Redis低一些, 但是我们一般使用SSD盘来存放数据, 尽可能跟上Redis的性能。\n\n从以上的对比可以看出, 如果你的业务场景的数据比较大，Redis 很难支撑， 比如大于50G，或者你的数据很重要，不允许断电丢失，那么使用Pika 就可以解决你的问题。\n而在实际使用中，大多数场景下pika的性能大约是Redis的50%~80%，在某些特定场景下，例如range 500，pika的性能只有redis的20%，针对这些场景我们仍然在改进\n```\n\n\n\n## 从pika迁移到pika\n\n```markdown\n DBA需要做的\n\n1. DBA迁移Redis数据到Pika\n2. DBA将Redis的数据实时同步到Pika，确保Redis与Pika的数据始终一致\n3. DBA切换LVS后端ip，由Pika替换Redis\n\n\n```\n\n## redis数据过期的问题\n\n```markdown\n在单机版Redis中，存在两种删除策略：\n\n- 惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。\n- 定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。\n\n在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。\n```\n\n\n\n## 如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？\n\n```markdown\n内存淘汰机制。\n\nredis 内存淘汰机制有以下几个：\n\n- noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。\n- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。\n- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。\n- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。\n- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。\n- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。\n```\n\n\n\n## 实现lru\n\n```\n使用链表来实现， 当命中某个值的时候 把它移到链表头部， 淘汰尾部\n\nlru-k 使用两个队列，一个是访问历史队列，先进先出\n\n一个lru队列\n```\n\n\n\n## 哨兵机制\n\n```markdown\n为了解决redis主从复制模式致命缺点，当主节点宕机，影响整个系统运行，引入哨兵机制Sentinel。\n\nSentinel哨兵主要解决以下问题：\n\n- 监控，监控每个节点以及哨兵运行状态\n- 报警，当发现某个节点或哨兵出现问题，通知其他哨兵\n- 自动故障转化，当主节点宕机时，哨兵从原主节点下的所有可用从节点中选举出一个作为主节点，原主节点降为从节点，并将其他从节点的主节点配置改为指定新主节点\n- 配置中心，客户端初始化连接的是哨兵节点集合\n```\n\n\n\n******\n********\n\n","source":"_posts/面试/要点整理/缓存.md","raw":"---\ntitle: 【第一课】缓存\ndate: 2019-11-05\ntags:\n- redis\n- memcache\n- 缓存\ncategories:\n- 面试\n---\n\n> 本篇文章主要就redis的常见面试问题进行了讨论\n\n<!-- more -->\n\n## 为什么用redis？\n\n```\n因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有 **Redis** 和 **Memcached** 不过中和考虑了他们的优缺点，最后选择了Redis。\n```\n\n## redis和memecache的区别\n\n```\n存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。\n数据支持类型 Memcache对数据类型支持相对简单。Redis有复杂的数据类型。redis的数据类型更多string,set,zset, list, hash, ， memcache只支持简单字符串\n使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。\nvalue大小 redis最大可以达到1GB，而memcache只有1MB\nredis支持数据备份 即主从备份\nredis支持数据的持久化 可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\n```\n\n\n\n## 为什么要用缓存？\n\n```\n对于一个服务其性能瓶颈往往都在DB，传统关系型存储尤甚。我们在创建表的时候，并不会未所有的字段创建索引，这意味着如果我们需要读取非缓存数据就要从磁盘拿数据。这个过程至少需要十几毫秒的时间。而缓存往往是基于内存的，这要比DB读数据快两个数量级。这是我们用缓存的根本原因原因。\n```\n\n\n\n## 缓存这么好，为什么不都用缓存\n\n```\n内存这东西虽然很快，同时它还很贵。动辄百十来G的数据都扔内存这有点太浪费。依据二八定律，我们只需找到那最紧俏的百分之二十就行了。这是非常重要的。否则你加了缓存效果反而更差。对于缓存有一个衡量指标，叫做缓存命中率。这个指标高说明我们请求的数据大部分来自缓存。证明我们加缓存这件事的收益越高。\n```\n\n\n\n## 缓存适用的场景\n\n```\n会话缓存 如存储用户购物车中的数据的时候，利用redis持久化的特点，使其不会丢失数据。\n全页缓存 缓存页内数据\n队列 利用redis的list数据结构的push/pop操作， 对数据进行操作\n排行榜 利用zset数据结构进行rank排行操作\n计数器 使用set来统计集合内的数据量\n订阅发布 利用订阅发布功能功能甚至可以搭建聊天室\n```\n\n## 缓存穿透\n\n```\n缓存穿透指的是如果我们访问一个缓存中没有的数据的时候就会去查询数据库， 如果数据库里也没有的话，一般是不更新缓存的， 这时候如果用户一直刷就会造成缓存穿透\n缓存空对象 或者缓存预测\n```\n\n\n\n## 缓存击穿\n\n```\n多个用户同时访问一个热点缓存，在这个key失效的瞬间 就会造成多次访问数据库， 造成缓存击穿。\n缓存预热 缓存加锁\n```\n\n\n\n## 缓存防雪崩\n\n```\n缓存服务暂时崩溃，导致大量请求访问数据库。\n采用高可用的缓存方案 限流\n```\n\n\n\n## redis的新增数据结构\n\n```\ngeo 地理索引 基于zset\nHyperLogLog 寻找集合中的基数，即去重后的数据\npub/sub 发布订阅，如上文\n```\n\n\n\n## 如果有大量的key需要设置同一时间过期，一般需要注意什么？\n\n```\n如果我们过期时间设在同一时间，很有可能会造成缓存雪崩，大量访问指向数据库， 我们给定时时间一个随机值\n```\n\n\n\n## 那你使用过Redis分布式锁么，它是什么回事？\n\n```\n先使用setnx争抢锁 用expire给这个key添加过期时间，防止忘记释放。\n```\n\n\n\n## 然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？\n\n```\n这时候这个锁就永远无法释放了。 可以通过set里的nx,ex两个命令行参数来进行原子化操作。\n```\n\n\n\n## 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？\n\n```\n使用keys命令可以扫出制定模式的\n```\n\n\n\n## 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？\n\n```\nredis是单线程的，线上会停顿，直到这个指令结束。 使用scan可以无阻塞的提出指定模式的keys，但是可能会重复\n```\n\n\n\n## 使用redis怎么实现异步队列？\n\n```\n使用list数据类型， rpush 发送消息， lpop接收消息， 接收不到消息的时候适当的sleep一段时间\n```\n\n\n\n## 可不可以不用sleep\n\n```\nlist有个指令 blpop 可以在消息不来的时候阻塞住知道消息到来\n```\n\n\n\n## 能不能一次生产 多次消费\n\n```\n使用pub/sub模式，可以实现1:n的消息队列\n```\n\n\n\n## pub/sub有什么缺点\n\n```\n一旦消费者下线， 消息就会丢失。 建议还是使用专业的消息队列， \\**RocketMQ rabbitmq\\*\n```\n\n\n\n## Redis如何实现延时队列？\n\n```\n使用zset 值为时间戳 key为消息内容 使用zadd添加消息 使用zrangebyscore获取n秒前的数据。\n```\n\n\n\n## redis怎么持久化的 主从数据怎么进行交互？\n\n```\nrdb进行镜像全量同步， aof做增量持久化。 因为rdb耗费时间较久 需要配合aof来使用。 当redis重启时， 使用rdb持久化文件重新构建内存， 再用aof重放近期的操作指令来恢复重启前的状态\n```\n\n\n\n## 突然停电怎么办\n\n```\n取决于 aof的sync配置，如果不考虑性能的话每条指令后都sync下就不会丢失，但是一般来说，不会这么配置，如果配置每秒同步一次的话，丢失的就是这一秒的数据\n```\n\n\n\n## rdb的原理\n\n```\nfork 和 cow 父进程fork一个子进程，并且开始进行rdb， 子进程创建后，父子共享数据段， 父进程继续进行读写操作。\nredis每隔几分钟形成一个快照\n\n- rdb\n保存了redis某个时间点的数据集合， 体积较小\n适合用于灾难回复 恢复大量数据的时候比aof快 但是会丢失数据\n\n- aof\n同步频率快且不影响redis性能。\n有序追加对redis的操作指令\n但是体积较大\n```\n\n\n\n## Pipline的好处是什么\n\n```\n可以把多次io缩减为1次\n```\n\n\n\n## redis的同步机制\n\n```\n主从同步和从从同步， 主节点做一次bgsave，生成rdb镜像， 并保存后续的操作记录。 待完成后，主节点把rdb全量同步给复制节点， 复制节点加载完rdb后， 增量数据使用aof同步。\n```\n\n\n\n## redis集群的高可用怎么保证， 原理是什么\n\n```\nRedis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。   \nRedis Cluster  着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。\n```\n\n\n\n## pika和redis\n\n```\npika相对于redis，最大的不同就是pika是持久化存储，数据存在磁盘上，而redis是内存存储，由此不同也给pika带来了相对于redis的优势和劣势**\n\n大容量redis 遇到的问题\n\n- 恢复时间长\n- 一主多从, 主从切换代价大\n- 缓冲区写满问题\n- 内存太贵\n\nPika的特点\n\n1. 容量大，支持百G数据量的存储\n2. 兼容Redis，不用修改代码即可平滑从Redis迁移到Pika\n3. 支持主从(slaveof)\n4. 完善的运维命令\n\n优势:\n\n- 容量大：Pika没有Redis的内存限制, 最大使用空间等于磁盘空间的大小**\n- 加载db速度快：Pika 在写入的时候, 数据是落盘的, 所以即使节点挂了, 不需要rbd或者aof，pika 重启不用重新加载数据到内存而是直接使用已经持久化在磁盘上的数据, 不需要任何数据回放操作，这大大降低了重启成本。**\n- 备份速度快：Pika备份的速度大致等同于cp的速度（拷贝数据文件后还有一个快照的恢复过程，会花费一些时间），这样在对于百G大库的备份是快捷的，更快的备份速度更好的解决了主从的全同步问题\n\n劣势：\n\n由于Pika是基于内存和文件来存放数据, 所以性能肯定比Redis低一些, 但是我们一般使用SSD盘来存放数据, 尽可能跟上Redis的性能。\n\n从以上的对比可以看出, 如果你的业务场景的数据比较大，Redis 很难支撑， 比如大于50G，或者你的数据很重要，不允许断电丢失，那么使用Pika 就可以解决你的问题。\n而在实际使用中，大多数场景下pika的性能大约是Redis的50%~80%，在某些特定场景下，例如range 500，pika的性能只有redis的20%，针对这些场景我们仍然在改进\n```\n\n\n\n## 从pika迁移到pika\n\n```markdown\n DBA需要做的\n\n1. DBA迁移Redis数据到Pika\n2. DBA将Redis的数据实时同步到Pika，确保Redis与Pika的数据始终一致\n3. DBA切换LVS后端ip，由Pika替换Redis\n\n\n```\n\n## redis数据过期的问题\n\n```markdown\n在单机版Redis中，存在两种删除策略：\n\n- 惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。\n- 定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。\n\n在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。\n```\n\n\n\n## 如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？\n\n```markdown\n内存淘汰机制。\n\nredis 内存淘汰机制有以下几个：\n\n- noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。\n- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。\n- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。\n- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。\n- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。\n- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。\n```\n\n\n\n## 实现lru\n\n```\n使用链表来实现， 当命中某个值的时候 把它移到链表头部， 淘汰尾部\n\nlru-k 使用两个队列，一个是访问历史队列，先进先出\n\n一个lru队列\n```\n\n\n\n## 哨兵机制\n\n```markdown\n为了解决redis主从复制模式致命缺点，当主节点宕机，影响整个系统运行，引入哨兵机制Sentinel。\n\nSentinel哨兵主要解决以下问题：\n\n- 监控，监控每个节点以及哨兵运行状态\n- 报警，当发现某个节点或哨兵出现问题，通知其他哨兵\n- 自动故障转化，当主节点宕机时，哨兵从原主节点下的所有可用从节点中选举出一个作为主节点，原主节点降为从节点，并将其他从节点的主节点配置改为指定新主节点\n- 配置中心，客户端初始化连接的是哨兵节点集合\n```\n\n\n\n******\n********\n\n","slug":"面试/要点整理/缓存","published":1,"updated":"2020-03-23T11:47:17.659Z","_id":"ck7cxr5dt000w5x8n3co43bj1","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本篇文章主要就redis的常见面试问题进行了讨论</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h2 id=\"为什么用redis？\"><a href=\"#为什么用redis？\" class=\"headerlink\" title=\"为什么用redis？\"></a>为什么用redis？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有 **Redis** 和 **Memcached** 不过中和考虑了他们的优缺点，最后选择了Redis。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"redis和memecache的区别\"><a href=\"#redis和memecache的区别\" class=\"headerlink\" title=\"redis和memecache的区别\"></a>redis和memecache的区别</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。</span><br><span class=\"line\">数据支持类型 Memcache对数据类型支持相对简单。Redis有复杂的数据类型。redis的数据类型更多string,set,zset, list, hash, ， memcache只支持简单字符串</span><br><span class=\"line\">使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</span><br><span class=\"line\">value大小 redis最大可以达到1GB，而memcache只有1MB</span><br><span class=\"line\">redis支持数据备份 即主从备份</span><br><span class=\"line\">redis支持数据的持久化 可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"为什么要用缓存？\"><a href=\"#为什么要用缓存？\" class=\"headerlink\" title=\"为什么要用缓存？\"></a>为什么要用缓存？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于一个服务其性能瓶颈往往都在DB，传统关系型存储尤甚。我们在创建表的时候，并不会未所有的字段创建索引，这意味着如果我们需要读取非缓存数据就要从磁盘拿数据。这个过程至少需要十几毫秒的时间。而缓存往往是基于内存的，这要比DB读数据快两个数量级。这是我们用缓存的根本原因原因。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"缓存这么好，为什么不都用缓存\"><a href=\"#缓存这么好，为什么不都用缓存\" class=\"headerlink\" title=\"缓存这么好，为什么不都用缓存\"></a>缓存这么好，为什么不都用缓存</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内存这东西虽然很快，同时它还很贵。动辄百十来G的数据都扔内存这有点太浪费。依据二八定律，我们只需找到那最紧俏的百分之二十就行了。这是非常重要的。否则你加了缓存效果反而更差。对于缓存有一个衡量指标，叫做缓存命中率。这个指标高说明我们请求的数据大部分来自缓存。证明我们加缓存这件事的收益越高。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"缓存适用的场景\"><a href=\"#缓存适用的场景\" class=\"headerlink\" title=\"缓存适用的场景\"></a>缓存适用的场景</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">会话缓存 如存储用户购物车中的数据的时候，利用redis持久化的特点，使其不会丢失数据。</span><br><span class=\"line\">全页缓存 缓存页内数据</span><br><span class=\"line\">队列 利用redis的list数据结构的push&#x2F;pop操作， 对数据进行操作</span><br><span class=\"line\">排行榜 利用zset数据结构进行rank排行操作</span><br><span class=\"line\">计数器 使用set来统计集合内的数据量</span><br><span class=\"line\">订阅发布 利用订阅发布功能功能甚至可以搭建聊天室</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缓存穿透指的是如果我们访问一个缓存中没有的数据的时候就会去查询数据库， 如果数据库里也没有的话，一般是不更新缓存的， 这时候如果用户一直刷就会造成缓存穿透</span><br><span class=\"line\">缓存空对象 或者缓存预测</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多个用户同时访问一个热点缓存，在这个key失效的瞬间 就会造成多次访问数据库， 造成缓存击穿。</span><br><span class=\"line\">缓存预热 缓存加锁</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"缓存防雪崩\"><a href=\"#缓存防雪崩\" class=\"headerlink\" title=\"缓存防雪崩\"></a>缓存防雪崩</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缓存服务暂时崩溃，导致大量请求访问数据库。</span><br><span class=\"line\">采用高可用的缓存方案 限流</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"redis的新增数据结构\"><a href=\"#redis的新增数据结构\" class=\"headerlink\" title=\"redis的新增数据结构\"></a>redis的新增数据结构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">geo 地理索引 基于zset</span><br><span class=\"line\">HyperLogLog 寻找集合中的基数，即去重后的数据</span><br><span class=\"line\">pub&#x2F;sub 发布订阅，如上文</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如果有大量的key需要设置同一时间过期，一般需要注意什么？\"><a href=\"#如果有大量的key需要设置同一时间过期，一般需要注意什么？\" class=\"headerlink\" title=\"如果有大量的key需要设置同一时间过期，一般需要注意什么？\"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果我们过期时间设在同一时间，很有可能会造成缓存雪崩，大量访问指向数据库， 我们给定时时间一个随机值</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"那你使用过Redis分布式锁么，它是什么回事？\"><a href=\"#那你使用过Redis分布式锁么，它是什么回事？\" class=\"headerlink\" title=\"那你使用过Redis分布式锁么，它是什么回事？\"></a>那你使用过Redis分布式锁么，它是什么回事？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先使用setnx争抢锁 用expire给这个key添加过期时间，防止忘记释放。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？\"><a href=\"#然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？\" class=\"headerlink\" title=\"然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？\"></a>然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这时候这个锁就永远无法释放了。 可以通过set里的nx,ex两个命令行参数来进行原子化操作。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？\"><a href=\"#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？\" class=\"headerlink\" title=\"假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？\"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用keys命令可以扫出制定模式的</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？\"><a href=\"#如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？\" class=\"headerlink\" title=\"如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？\"></a>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis是单线程的，线上会停顿，直到这个指令结束。 使用scan可以无阻塞的提出指定模式的keys，但是可能会重复</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"使用redis怎么实现异步队列？\"><a href=\"#使用redis怎么实现异步队列？\" class=\"headerlink\" title=\"使用redis怎么实现异步队列？\"></a>使用redis怎么实现异步队列？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用list数据类型， rpush 发送消息， lpop接收消息， 接收不到消息的时候适当的sleep一段时间</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"可不可以不用sleep\"><a href=\"#可不可以不用sleep\" class=\"headerlink\" title=\"可不可以不用sleep\"></a>可不可以不用sleep</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list有个指令 blpop 可以在消息不来的时候阻塞住知道消息到来</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"能不能一次生产-多次消费\"><a href=\"#能不能一次生产-多次消费\" class=\"headerlink\" title=\"能不能一次生产 多次消费\"></a>能不能一次生产 多次消费</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用pub&#x2F;sub模式，可以实现1:n的消息队列</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"pub-sub有什么缺点\"><a href=\"#pub-sub有什么缺点\" class=\"headerlink\" title=\"pub/sub有什么缺点\"></a>pub/sub有什么缺点</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一旦消费者下线， 消息就会丢失。 建议还是使用专业的消息队列， \\**RocketMQ rabbitmq\\*</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Redis如何实现延时队列？\"><a href=\"#Redis如何实现延时队列？\" class=\"headerlink\" title=\"Redis如何实现延时队列？\"></a>Redis如何实现延时队列？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用zset 值为时间戳 key为消息内容 使用zadd添加消息 使用zrangebyscore获取n秒前的数据。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"redis怎么持久化的-主从数据怎么进行交互？\"><a href=\"#redis怎么持久化的-主从数据怎么进行交互？\" class=\"headerlink\" title=\"redis怎么持久化的 主从数据怎么进行交互？\"></a>redis怎么持久化的 主从数据怎么进行交互？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rdb进行镜像全量同步， aof做增量持久化。 因为rdb耗费时间较久 需要配合aof来使用。 当redis重启时， 使用rdb持久化文件重新构建内存， 再用aof重放近期的操作指令来恢复重启前的状态</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"突然停电怎么办\"><a href=\"#突然停电怎么办\" class=\"headerlink\" title=\"突然停电怎么办\"></a>突然停电怎么办</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">取决于 aof的sync配置，如果不考虑性能的话每条指令后都sync下就不会丢失，但是一般来说，不会这么配置，如果配置每秒同步一次的话，丢失的就是这一秒的数据</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"rdb的原理\"><a href=\"#rdb的原理\" class=\"headerlink\" title=\"rdb的原理\"></a>rdb的原理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fork 和 cow 父进程fork一个子进程，并且开始进行rdb， 子进程创建后，父子共享数据段， 父进程继续进行读写操作。</span><br><span class=\"line\">redis每隔几分钟形成一个快照</span><br><span class=\"line\"></span><br><span class=\"line\">- rdb</span><br><span class=\"line\">保存了redis某个时间点的数据集合， 体积较小</span><br><span class=\"line\">适合用于灾难回复 恢复大量数据的时候比aof快 但是会丢失数据</span><br><span class=\"line\"></span><br><span class=\"line\">- aof</span><br><span class=\"line\">同步频率快且不影响redis性能。</span><br><span class=\"line\">有序追加对redis的操作指令</span><br><span class=\"line\">但是体积较大</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Pipline的好处是什么\"><a href=\"#Pipline的好处是什么\" class=\"headerlink\" title=\"Pipline的好处是什么\"></a>Pipline的好处是什么</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以把多次io缩减为1次</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"redis的同步机制\"><a href=\"#redis的同步机制\" class=\"headerlink\" title=\"redis的同步机制\"></a>redis的同步机制</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主从同步和从从同步， 主节点做一次bgsave，生成rdb镜像， 并保存后续的操作记录。 待完成后，主节点把rdb全量同步给复制节点， 复制节点加载完rdb后， 增量数据使用aof同步。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"redis集群的高可用怎么保证，-原理是什么\"><a href=\"#redis集群的高可用怎么保证，-原理是什么\" class=\"headerlink\" title=\"redis集群的高可用怎么保证， 原理是什么\"></a>redis集群的高可用怎么保证， 原理是什么</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Redis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。   </span><br><span class=\"line\">Redis Cluster  着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"pika和redis\"><a href=\"#pika和redis\" class=\"headerlink\" title=\"pika和redis\"></a>pika和redis</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pika相对于redis，最大的不同就是pika是持久化存储，数据存在磁盘上，而redis是内存存储，由此不同也给pika带来了相对于redis的优势和劣势**</span><br><span class=\"line\"></span><br><span class=\"line\">大容量redis 遇到的问题</span><br><span class=\"line\"></span><br><span class=\"line\">- 恢复时间长</span><br><span class=\"line\">- 一主多从, 主从切换代价大</span><br><span class=\"line\">- 缓冲区写满问题</span><br><span class=\"line\">- 内存太贵</span><br><span class=\"line\"></span><br><span class=\"line\">Pika的特点</span><br><span class=\"line\"></span><br><span class=\"line\">1. 容量大，支持百G数据量的存储</span><br><span class=\"line\">2. 兼容Redis，不用修改代码即可平滑从Redis迁移到Pika</span><br><span class=\"line\">3. 支持主从(slaveof)</span><br><span class=\"line\">4. 完善的运维命令</span><br><span class=\"line\"></span><br><span class=\"line\">优势:</span><br><span class=\"line\"></span><br><span class=\"line\">- 容量大：Pika没有Redis的内存限制, 最大使用空间等于磁盘空间的大小**</span><br><span class=\"line\">- 加载db速度快：Pika 在写入的时候, 数据是落盘的, 所以即使节点挂了, 不需要rbd或者aof，pika 重启不用重新加载数据到内存而是直接使用已经持久化在磁盘上的数据, 不需要任何数据回放操作，这大大降低了重启成本。**</span><br><span class=\"line\">- 备份速度快：Pika备份的速度大致等同于cp的速度（拷贝数据文件后还有一个快照的恢复过程，会花费一些时间），这样在对于百G大库的备份是快捷的，更快的备份速度更好的解决了主从的全同步问题</span><br><span class=\"line\"></span><br><span class=\"line\">劣势：</span><br><span class=\"line\"></span><br><span class=\"line\">由于Pika是基于内存和文件来存放数据, 所以性能肯定比Redis低一些, 但是我们一般使用SSD盘来存放数据, 尽可能跟上Redis的性能。</span><br><span class=\"line\"></span><br><span class=\"line\">从以上的对比可以看出, 如果你的业务场景的数据比较大，Redis 很难支撑， 比如大于50G，或者你的数据很重要，不允许断电丢失，那么使用Pika 就可以解决你的问题。</span><br><span class=\"line\">而在实际使用中，大多数场景下pika的性能大约是Redis的50%~80%，在某些特定场景下，例如range 500，pika的性能只有redis的20%，针对这些场景我们仍然在改进</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从pika迁移到pika\"><a href=\"#从pika迁移到pika\" class=\"headerlink\" title=\"从pika迁移到pika\"></a>从pika迁移到pika</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> DBA需要做的</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">1. </span>DBA迁移Redis数据到Pika</span><br><span class=\"line\"><span class=\"bullet\">2. </span>DBA将Redis的数据实时同步到Pika，确保Redis与Pika的数据始终一致</span><br><span class=\"line\"><span class=\"bullet\">3. </span>DBA切换LVS后端ip，由Pika替换Redis</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"redis数据过期的问题\"><a href=\"#redis数据过期的问题\" class=\"headerlink\" title=\"redis数据过期的问题\"></a>redis数据过期的问题</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在单机版Redis中，存在两种删除策略：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</span><br><span class=\"line\"><span class=\"bullet\">- </span>定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</span><br><span class=\"line\"></span><br><span class=\"line\">在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如果定期删除漏掉了很多过期-key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期-key-堆积在内存里，导致-redis-内存块耗尽了，咋整？\"><a href=\"#如果定期删除漏掉了很多过期-key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期-key-堆积在内存里，导致-redis-内存块耗尽了，咋整？\" class=\"headerlink\" title=\"如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？\"></a>如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内存淘汰机制。</span><br><span class=\"line\"></span><br><span class=\"line\">redis 内存淘汰机制有以下几个：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</span><br><span class=\"line\"><span class=\"bullet\">- </span>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</span><br><span class=\"line\"><span class=\"bullet\">- </span>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</span><br><span class=\"line\"><span class=\"bullet\">- </span>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。</span><br><span class=\"line\"><span class=\"bullet\">- </span>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。</span><br><span class=\"line\"><span class=\"bullet\">- </span>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"实现lru\"><a href=\"#实现lru\" class=\"headerlink\" title=\"实现lru\"></a>实现lru</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用链表来实现， 当命中某个值的时候 把它移到链表头部， 淘汰尾部</span><br><span class=\"line\"></span><br><span class=\"line\">lru-k 使用两个队列，一个是访问历史队列，先进先出</span><br><span class=\"line\"></span><br><span class=\"line\">一个lru队列</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"哨兵机制\"><a href=\"#哨兵机制\" class=\"headerlink\" title=\"哨兵机制\"></a>哨兵机制</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了解决redis主从复制模式致命缺点，当主节点宕机，影响整个系统运行，引入哨兵机制Sentinel。</span><br><span class=\"line\"></span><br><span class=\"line\">Sentinel哨兵主要解决以下问题：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>监控，监控每个节点以及哨兵运行状态</span><br><span class=\"line\"><span class=\"bullet\">- </span>报警，当发现某个节点或哨兵出现问题，通知其他哨兵</span><br><span class=\"line\"><span class=\"bullet\">- </span>自动故障转化，当主节点宕机时，哨兵从原主节点下的所有可用从节点中选举出一个作为主节点，原主节点降为从节点，并将其他从节点的主节点配置改为指定新主节点</span><br><span class=\"line\"><span class=\"bullet\">- </span>配置中心，客户端初始化连接的是哨兵节点集合</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<hr>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本篇文章主要就redis的常见面试问题进行了讨论</p>\n</blockquote>","more":"<h2 id=\"为什么用redis？\"><a href=\"#为什么用redis？\" class=\"headerlink\" title=\"为什么用redis？\"></a>为什么用redis？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有 **Redis** 和 **Memcached** 不过中和考虑了他们的优缺点，最后选择了Redis。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"redis和memecache的区别\"><a href=\"#redis和memecache的区别\" class=\"headerlink\" title=\"redis和memecache的区别\"></a>redis和memecache的区别</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性。</span><br><span class=\"line\">数据支持类型 Memcache对数据类型支持相对简单。Redis有复杂的数据类型。redis的数据类型更多string,set,zset, list, hash, ， memcache只支持简单字符串</span><br><span class=\"line\">使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</span><br><span class=\"line\">value大小 redis最大可以达到1GB，而memcache只有1MB</span><br><span class=\"line\">redis支持数据备份 即主从备份</span><br><span class=\"line\">redis支持数据的持久化 可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"为什么要用缓存？\"><a href=\"#为什么要用缓存？\" class=\"headerlink\" title=\"为什么要用缓存？\"></a>为什么要用缓存？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于一个服务其性能瓶颈往往都在DB，传统关系型存储尤甚。我们在创建表的时候，并不会未所有的字段创建索引，这意味着如果我们需要读取非缓存数据就要从磁盘拿数据。这个过程至少需要十几毫秒的时间。而缓存往往是基于内存的，这要比DB读数据快两个数量级。这是我们用缓存的根本原因原因。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"缓存这么好，为什么不都用缓存\"><a href=\"#缓存这么好，为什么不都用缓存\" class=\"headerlink\" title=\"缓存这么好，为什么不都用缓存\"></a>缓存这么好，为什么不都用缓存</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内存这东西虽然很快，同时它还很贵。动辄百十来G的数据都扔内存这有点太浪费。依据二八定律，我们只需找到那最紧俏的百分之二十就行了。这是非常重要的。否则你加了缓存效果反而更差。对于缓存有一个衡量指标，叫做缓存命中率。这个指标高说明我们请求的数据大部分来自缓存。证明我们加缓存这件事的收益越高。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"缓存适用的场景\"><a href=\"#缓存适用的场景\" class=\"headerlink\" title=\"缓存适用的场景\"></a>缓存适用的场景</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">会话缓存 如存储用户购物车中的数据的时候，利用redis持久化的特点，使其不会丢失数据。</span><br><span class=\"line\">全页缓存 缓存页内数据</span><br><span class=\"line\">队列 利用redis的list数据结构的push&#x2F;pop操作， 对数据进行操作</span><br><span class=\"line\">排行榜 利用zset数据结构进行rank排行操作</span><br><span class=\"line\">计数器 使用set来统计集合内的数据量</span><br><span class=\"line\">订阅发布 利用订阅发布功能功能甚至可以搭建聊天室</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缓存穿透指的是如果我们访问一个缓存中没有的数据的时候就会去查询数据库， 如果数据库里也没有的话，一般是不更新缓存的， 这时候如果用户一直刷就会造成缓存穿透</span><br><span class=\"line\">缓存空对象 或者缓存预测</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多个用户同时访问一个热点缓存，在这个key失效的瞬间 就会造成多次访问数据库， 造成缓存击穿。</span><br><span class=\"line\">缓存预热 缓存加锁</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"缓存防雪崩\"><a href=\"#缓存防雪崩\" class=\"headerlink\" title=\"缓存防雪崩\"></a>缓存防雪崩</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">缓存服务暂时崩溃，导致大量请求访问数据库。</span><br><span class=\"line\">采用高可用的缓存方案 限流</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"redis的新增数据结构\"><a href=\"#redis的新增数据结构\" class=\"headerlink\" title=\"redis的新增数据结构\"></a>redis的新增数据结构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">geo 地理索引 基于zset</span><br><span class=\"line\">HyperLogLog 寻找集合中的基数，即去重后的数据</span><br><span class=\"line\">pub&#x2F;sub 发布订阅，如上文</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如果有大量的key需要设置同一时间过期，一般需要注意什么？\"><a href=\"#如果有大量的key需要设置同一时间过期，一般需要注意什么？\" class=\"headerlink\" title=\"如果有大量的key需要设置同一时间过期，一般需要注意什么？\"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果我们过期时间设在同一时间，很有可能会造成缓存雪崩，大量访问指向数据库， 我们给定时时间一个随机值</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"那你使用过Redis分布式锁么，它是什么回事？\"><a href=\"#那你使用过Redis分布式锁么，它是什么回事？\" class=\"headerlink\" title=\"那你使用过Redis分布式锁么，它是什么回事？\"></a>那你使用过Redis分布式锁么，它是什么回事？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先使用setnx争抢锁 用expire给这个key添加过期时间，防止忘记释放。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？\"><a href=\"#然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？\" class=\"headerlink\" title=\"然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？\"></a>然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这时候这个锁就永远无法释放了。 可以通过set里的nx,ex两个命令行参数来进行原子化操作。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？\"><a href=\"#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？\" class=\"headerlink\" title=\"假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？\"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用keys命令可以扫出制定模式的</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？\"><a href=\"#如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？\" class=\"headerlink\" title=\"如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？\"></a>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis是单线程的，线上会停顿，直到这个指令结束。 使用scan可以无阻塞的提出指定模式的keys，但是可能会重复</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"使用redis怎么实现异步队列？\"><a href=\"#使用redis怎么实现异步队列？\" class=\"headerlink\" title=\"使用redis怎么实现异步队列？\"></a>使用redis怎么实现异步队列？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用list数据类型， rpush 发送消息， lpop接收消息， 接收不到消息的时候适当的sleep一段时间</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"可不可以不用sleep\"><a href=\"#可不可以不用sleep\" class=\"headerlink\" title=\"可不可以不用sleep\"></a>可不可以不用sleep</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list有个指令 blpop 可以在消息不来的时候阻塞住知道消息到来</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"能不能一次生产-多次消费\"><a href=\"#能不能一次生产-多次消费\" class=\"headerlink\" title=\"能不能一次生产 多次消费\"></a>能不能一次生产 多次消费</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用pub&#x2F;sub模式，可以实现1:n的消息队列</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"pub-sub有什么缺点\"><a href=\"#pub-sub有什么缺点\" class=\"headerlink\" title=\"pub/sub有什么缺点\"></a>pub/sub有什么缺点</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一旦消费者下线， 消息就会丢失。 建议还是使用专业的消息队列， \\**RocketMQ rabbitmq\\*</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Redis如何实现延时队列？\"><a href=\"#Redis如何实现延时队列？\" class=\"headerlink\" title=\"Redis如何实现延时队列？\"></a>Redis如何实现延时队列？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用zset 值为时间戳 key为消息内容 使用zadd添加消息 使用zrangebyscore获取n秒前的数据。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"redis怎么持久化的-主从数据怎么进行交互？\"><a href=\"#redis怎么持久化的-主从数据怎么进行交互？\" class=\"headerlink\" title=\"redis怎么持久化的 主从数据怎么进行交互？\"></a>redis怎么持久化的 主从数据怎么进行交互？</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rdb进行镜像全量同步， aof做增量持久化。 因为rdb耗费时间较久 需要配合aof来使用。 当redis重启时， 使用rdb持久化文件重新构建内存， 再用aof重放近期的操作指令来恢复重启前的状态</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"突然停电怎么办\"><a href=\"#突然停电怎么办\" class=\"headerlink\" title=\"突然停电怎么办\"></a>突然停电怎么办</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">取决于 aof的sync配置，如果不考虑性能的话每条指令后都sync下就不会丢失，但是一般来说，不会这么配置，如果配置每秒同步一次的话，丢失的就是这一秒的数据</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"rdb的原理\"><a href=\"#rdb的原理\" class=\"headerlink\" title=\"rdb的原理\"></a>rdb的原理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fork 和 cow 父进程fork一个子进程，并且开始进行rdb， 子进程创建后，父子共享数据段， 父进程继续进行读写操作。</span><br><span class=\"line\">redis每隔几分钟形成一个快照</span><br><span class=\"line\"></span><br><span class=\"line\">- rdb</span><br><span class=\"line\">保存了redis某个时间点的数据集合， 体积较小</span><br><span class=\"line\">适合用于灾难回复 恢复大量数据的时候比aof快 但是会丢失数据</span><br><span class=\"line\"></span><br><span class=\"line\">- aof</span><br><span class=\"line\">同步频率快且不影响redis性能。</span><br><span class=\"line\">有序追加对redis的操作指令</span><br><span class=\"line\">但是体积较大</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Pipline的好处是什么\"><a href=\"#Pipline的好处是什么\" class=\"headerlink\" title=\"Pipline的好处是什么\"></a>Pipline的好处是什么</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以把多次io缩减为1次</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"redis的同步机制\"><a href=\"#redis的同步机制\" class=\"headerlink\" title=\"redis的同步机制\"></a>redis的同步机制</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">主从同步和从从同步， 主节点做一次bgsave，生成rdb镜像， 并保存后续的操作记录。 待完成后，主节点把rdb全量同步给复制节点， 复制节点加载完rdb后， 增量数据使用aof同步。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"redis集群的高可用怎么保证，-原理是什么\"><a href=\"#redis集群的高可用怎么保证，-原理是什么\" class=\"headerlink\" title=\"redis集群的高可用怎么保证， 原理是什么\"></a>redis集群的高可用怎么保证， 原理是什么</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Redis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。   </span><br><span class=\"line\">Redis Cluster  着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"pika和redis\"><a href=\"#pika和redis\" class=\"headerlink\" title=\"pika和redis\"></a>pika和redis</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pika相对于redis，最大的不同就是pika是持久化存储，数据存在磁盘上，而redis是内存存储，由此不同也给pika带来了相对于redis的优势和劣势**</span><br><span class=\"line\"></span><br><span class=\"line\">大容量redis 遇到的问题</span><br><span class=\"line\"></span><br><span class=\"line\">- 恢复时间长</span><br><span class=\"line\">- 一主多从, 主从切换代价大</span><br><span class=\"line\">- 缓冲区写满问题</span><br><span class=\"line\">- 内存太贵</span><br><span class=\"line\"></span><br><span class=\"line\">Pika的特点</span><br><span class=\"line\"></span><br><span class=\"line\">1. 容量大，支持百G数据量的存储</span><br><span class=\"line\">2. 兼容Redis，不用修改代码即可平滑从Redis迁移到Pika</span><br><span class=\"line\">3. 支持主从(slaveof)</span><br><span class=\"line\">4. 完善的运维命令</span><br><span class=\"line\"></span><br><span class=\"line\">优势:</span><br><span class=\"line\"></span><br><span class=\"line\">- 容量大：Pika没有Redis的内存限制, 最大使用空间等于磁盘空间的大小**</span><br><span class=\"line\">- 加载db速度快：Pika 在写入的时候, 数据是落盘的, 所以即使节点挂了, 不需要rbd或者aof，pika 重启不用重新加载数据到内存而是直接使用已经持久化在磁盘上的数据, 不需要任何数据回放操作，这大大降低了重启成本。**</span><br><span class=\"line\">- 备份速度快：Pika备份的速度大致等同于cp的速度（拷贝数据文件后还有一个快照的恢复过程，会花费一些时间），这样在对于百G大库的备份是快捷的，更快的备份速度更好的解决了主从的全同步问题</span><br><span class=\"line\"></span><br><span class=\"line\">劣势：</span><br><span class=\"line\"></span><br><span class=\"line\">由于Pika是基于内存和文件来存放数据, 所以性能肯定比Redis低一些, 但是我们一般使用SSD盘来存放数据, 尽可能跟上Redis的性能。</span><br><span class=\"line\"></span><br><span class=\"line\">从以上的对比可以看出, 如果你的业务场景的数据比较大，Redis 很难支撑， 比如大于50G，或者你的数据很重要，不允许断电丢失，那么使用Pika 就可以解决你的问题。</span><br><span class=\"line\">而在实际使用中，大多数场景下pika的性能大约是Redis的50%~80%，在某些特定场景下，例如range 500，pika的性能只有redis的20%，针对这些场景我们仍然在改进</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从pika迁移到pika\"><a href=\"#从pika迁移到pika\" class=\"headerlink\" title=\"从pika迁移到pika\"></a>从pika迁移到pika</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> DBA需要做的</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">1. </span>DBA迁移Redis数据到Pika</span><br><span class=\"line\"><span class=\"bullet\">2. </span>DBA将Redis的数据实时同步到Pika，确保Redis与Pika的数据始终一致</span><br><span class=\"line\"><span class=\"bullet\">3. </span>DBA切换LVS后端ip，由Pika替换Redis</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"redis数据过期的问题\"><a href=\"#redis数据过期的问题\" class=\"headerlink\" title=\"redis数据过期的问题\"></a>redis数据过期的问题</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在单机版Redis中，存在两种删除策略：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</span><br><span class=\"line\"><span class=\"bullet\">- </span>定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</span><br><span class=\"line\"></span><br><span class=\"line\">在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"如果定期删除漏掉了很多过期-key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期-key-堆积在内存里，导致-redis-内存块耗尽了，咋整？\"><a href=\"#如果定期删除漏掉了很多过期-key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期-key-堆积在内存里，导致-redis-内存块耗尽了，咋整？\" class=\"headerlink\" title=\"如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？\"></a>如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 redis 内存块耗尽了，咋整？</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内存淘汰机制。</span><br><span class=\"line\"></span><br><span class=\"line\">redis 内存淘汰机制有以下几个：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</span><br><span class=\"line\"><span class=\"bullet\">- </span>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</span><br><span class=\"line\"><span class=\"bullet\">- </span>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</span><br><span class=\"line\"><span class=\"bullet\">- </span>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。</span><br><span class=\"line\"><span class=\"bullet\">- </span>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。</span><br><span class=\"line\"><span class=\"bullet\">- </span>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"实现lru\"><a href=\"#实现lru\" class=\"headerlink\" title=\"实现lru\"></a>实现lru</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用链表来实现， 当命中某个值的时候 把它移到链表头部， 淘汰尾部</span><br><span class=\"line\"></span><br><span class=\"line\">lru-k 使用两个队列，一个是访问历史队列，先进先出</span><br><span class=\"line\"></span><br><span class=\"line\">一个lru队列</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"哨兵机制\"><a href=\"#哨兵机制\" class=\"headerlink\" title=\"哨兵机制\"></a>哨兵机制</h2><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了解决redis主从复制模式致命缺点，当主节点宕机，影响整个系统运行，引入哨兵机制Sentinel。</span><br><span class=\"line\"></span><br><span class=\"line\">Sentinel哨兵主要解决以下问题：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>监控，监控每个节点以及哨兵运行状态</span><br><span class=\"line\"><span class=\"bullet\">- </span>报警，当发现某个节点或哨兵出现问题，通知其他哨兵</span><br><span class=\"line\"><span class=\"bullet\">- </span>自动故障转化，当主节点宕机时，哨兵从原主节点下的所有可用从节点中选举出一个作为主节点，原主节点降为从节点，并将其他从节点的主节点配置改为指定新主节点</span><br><span class=\"line\"><span class=\"bullet\">- </span>配置中心，客户端初始化连接的是哨兵节点集合</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<hr>"},{"title":"【第一课】操作系统","date":"2019-11-12T16:00:00.000Z","_content":"\n> 本篇文章主要就操作系统的常见面试题进行了讨论\n\n<!-- more -->\n\n###  进程同步\n\n同步机制需要遵循的原则：\n\n1. 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请\n\n2. 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问\n\n3. 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等\n\n4. 让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等\n\n   \n\n###  死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。\n\n死锁原因：\n\n1. 竞争资源：请求同一有限资源的进程数多于可用资源数\n2. 进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链\n\n死锁产生的必要条件：\n\n1. 互斥条件:进程对所分配的资源进行排他性的使用\n2. 请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源\n3. 不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺\n4. 环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链\n\n死锁处理：\n\n1. 预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量\n\n2. 避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法\n\n3. 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大\n\n4. 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大\n\n   \n\n### 进程调度算法\n\n先来先服务调度算法FCFS：既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；\n\n短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；\n\n高相应比算法HRN：响应比=(等待时间+要求服务时间)/要求服务时间；\n\n时间片轮转调度RR：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;\n\n多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。\n\n\n\n### 分段分页\n\n页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制\n\n页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定\n\n分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。\n\n为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。\n\n### 页面置换算法\n\n最佳置换算法：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。\n\n先进先出置换算法：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。\n\n最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。\n\n时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。\n\n改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。\n\n最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。","source":"_posts/面试/要点整理/操作系统.md","raw":"---\ntitle: 【第一课】操作系统\ndate: 2019-11-13\ntags:\n- linux\ncategories:\n- 面试\n---\n\n> 本篇文章主要就操作系统的常见面试题进行了讨论\n\n<!-- more -->\n\n###  进程同步\n\n同步机制需要遵循的原则：\n\n1. 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请\n\n2. 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问\n\n3. 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等\n\n4. 让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等\n\n   \n\n###  死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。\n\n死锁原因：\n\n1. 竞争资源：请求同一有限资源的进程数多于可用资源数\n2. 进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链\n\n死锁产生的必要条件：\n\n1. 互斥条件:进程对所分配的资源进行排他性的使用\n2. 请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源\n3. 不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺\n4. 环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链\n\n死锁处理：\n\n1. 预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量\n\n2. 避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法\n\n3. 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大\n\n4. 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大\n\n   \n\n### 进程调度算法\n\n先来先服务调度算法FCFS：既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；\n\n短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；\n\n高相应比算法HRN：响应比=(等待时间+要求服务时间)/要求服务时间；\n\n时间片轮转调度RR：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;\n\n多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。\n\n\n\n### 分段分页\n\n页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制\n\n页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定\n\n分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。\n\n为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。\n\n### 页面置换算法\n\n最佳置换算法：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。\n\n先进先出置换算法：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。\n\n最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。\n\n时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。\n\n改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。\n\n最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。","slug":"面试/要点整理/操作系统","published":1,"updated":"2020-01-21T09:41:20.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7cxr5du000z5x8nexym5n3z","content":"<blockquote>\n<p>本篇文章主要就操作系统的常见面试题进行了讨论</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h3><p>同步机制需要遵循的原则：</p>\n<ol>\n<li><p>空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请</p>\n</li>\n<li><p>忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问</p>\n</li>\n<li><p>有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等</p>\n</li>\n<li><p>让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等</p>\n</li>\n</ol>\n<h3 id=\"死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。\"><a href=\"#死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。\" class=\"headerlink\" title=\"死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。\"></a>死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。</h3><p>死锁原因：</p>\n<ol>\n<li>竞争资源：请求同一有限资源的进程数多于可用资源数</li>\n<li>进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链</li>\n</ol>\n<p>死锁产生的必要条件：</p>\n<ol>\n<li>互斥条件:进程对所分配的资源进行排他性的使用</li>\n<li>请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源</li>\n<li>不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺</li>\n<li>环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链</li>\n</ol>\n<p>死锁处理：</p>\n<ol>\n<li><p>预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量</p>\n</li>\n<li><p>避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法</p>\n</li>\n<li><p>检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大</p>\n</li>\n<li><p>解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大</p>\n</li>\n</ol>\n<h3 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h3><p>先来先服务调度算法FCFS：既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；</p>\n<p>短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；</p>\n<p>高相应比算法HRN：响应比=(等待时间+要求服务时间)/要求服务时间；</p>\n<p>时间片轮转调度RR：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;</p>\n<p>多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。</p>\n<h3 id=\"分段分页\"><a href=\"#分段分页\" class=\"headerlink\" title=\"分段分页\"></a>分段分页</h3><p>页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制</p>\n<p>页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定</p>\n<p>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</p>\n<p>为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。</p>\n<h3 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h3><p>最佳置换算法：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</p>\n<p>先进先出置换算法：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。</p>\n<p>最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。</p>\n<p>时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。</p>\n<p>改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。</p>\n<p>最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本篇文章主要就操作系统的常见面试题进行了讨论</p>\n</blockquote>","more":"<h3 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h3><p>同步机制需要遵循的原则：</p>\n<ol>\n<li><p>空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请</p>\n</li>\n<li><p>忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问</p>\n</li>\n<li><p>有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等</p>\n</li>\n<li><p>让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等</p>\n</li>\n</ol>\n<h3 id=\"死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。\"><a href=\"#死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。\" class=\"headerlink\" title=\"死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。\"></a>死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。</h3><p>死锁原因：</p>\n<ol>\n<li>竞争资源：请求同一有限资源的进程数多于可用资源数</li>\n<li>进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链</li>\n</ol>\n<p>死锁产生的必要条件：</p>\n<ol>\n<li>互斥条件:进程对所分配的资源进行排他性的使用</li>\n<li>请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源</li>\n<li>不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺</li>\n<li>环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链</li>\n</ol>\n<p>死锁处理：</p>\n<ol>\n<li><p>预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量</p>\n</li>\n<li><p>避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法</p>\n</li>\n<li><p>检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大</p>\n</li>\n<li><p>解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大</p>\n</li>\n</ol>\n<h3 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h3><p>先来先服务调度算法FCFS：既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利；</p>\n<p>短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；</p>\n<p>高相应比算法HRN：响应比=(等待时间+要求服务时间)/要求服务时间；</p>\n<p>时间片轮转调度RR：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;</p>\n<p>多级反馈队列调度算法：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。</p>\n<h3 id=\"分段分页\"><a href=\"#分段分页\" class=\"headerlink\" title=\"分段分页\"></a>分段分页</h3><p>页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制</p>\n<p>页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定</p>\n<p>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</p>\n<p>为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。</p>\n<h3 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h3><p>最佳置换算法：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</p>\n<p>先进先出置换算法：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。</p>\n<p>最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。</p>\n<p>时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。</p>\n<p>改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。</p>\n<p>最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。</p>"},{"title":"【第一课】设计模式","date":"2019-11-13T16:00:00.000Z","_content":"\n> 本篇文章主要就设计模式的常见问题进行了讨论\n\n<!-- more -->\n\n## 六大原则\n\n1. 单一原则 每个类尽量实现独立的功能\n\n2. 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 针对继承\n\n3. 依赖倒置原则 避免高层依赖底层\n\n4. 接口隔离原则 接口往小了拆分\n\n5. 迪米特法则 每个单元对其他单元了解要尽可能小\n\n6. 开闭原则 尽量用扩展的方法，不去修改原来逻辑\n\n##  \n\n## 观察者模式\n\n对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n## 1. 策略模式( Strategy )\n\n定义个策略接口，不同的实现类提供不同的具体策略算法, 同时它们之间可以互相替换.\n\n> IStrategy 接口定义了策略方法，Strategy1 和 Strategy2 通过实现 IStrategy 提供不同的策略，而 User 组合了 IStrategy ，可以通过给 User 对象设置不同具体实现类来让其获得不同的策略\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/aa41f6375b2ddd59c91432e0a2145c25.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 策略模式.PNG\n\n## 2. 简单工厂模式( Simple Factory )\n\n定义一个用以创建对象的工厂, 根据不同的条件生成不同的对象\n\n\n\n> 注意简单工厂模式与策略模式是不同的，工厂模式是根据给定的条件返回相应的对象，而策略模式是将不同的策略对象传递给使用者以实现不同策略,*（好吧，我差点分不清了）*详细不同点分析可转[这里](http://blog.csdn.net/fwj380891124/article/details/7552305)\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/01dabedb62594e22287c10c8b6061a21.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 简单工厂模式.PNG\n\n## 3. 工厂模式( Factory )\n\n针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例\n\n> 与简单工厂模式不同点是它要为每一种产品提供一个工厂类，不同工厂类实现同一个工厂接口，返回不同产品，详细分析可转[这里](http://blog.csdn.net/superbeck/article/details/4446177)\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/08ca128f9c8a495acf5efafce66fa23e.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 工厂模式.PNG\n\n## 4. 抽象工厂模式( Abstract Factory )\n\n应对产品族概念而生\n\n> 与工厂模式相比，抽象工厂模式是为了应对产品族\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/946f97ce52089c1b3301deea2ced3aad.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 抽象工厂模式.PNG\n\n## 5. 装饰者模式( Decorator )\n\n动态的给一个对象添加一些额外的功能\n\n> ComponentImpl 和 Decorator 类都实现了 IComponent 接口，不同的是 ComponentImpl 提供了具体实现，而 Decorator 是先聚合 ComponentImpl 接着在自己的实现方法即 `operation()` 方法中做些处理*（即装饰）*后再调用 ComponentImpl 对象的具体实现\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/843c9c69723d1f4a9343239efaca216a.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 装饰者模式.PNG\n\n## 6. 代理模式( Proxy )\n\n封装被代理对象并限制外界对被代理对象的访问\n\n> 注意区分装饰者模式和代理模式的区别。在代理模式中，ComponentImpl 和 Proxy 类都实现了 IComponent 接口，Proxy 对象中虽然也维护着一个 ComponentImpl 对象，但一般情况下它是代理类自己初始化的，不像装饰者模式是通过 `set` 进去的，同时在接口方法即 `operation()` 中代理对象会限制外界对被代理对象的访问，而装饰者模式是装饰者给被装饰者添加额外的行为，详细不同点分析可转[这里](http://www.cnblogs.com/jaredlam/archive/2011/11/08/2241089.html)\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/4fcd2e4ee7cfed2d079fb4b95ed27dab.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 代理模式.PNG\n\n## 7. 模板方法模式( Template )\n\n定义一个操作的算法骨架, 并将一些步骤延迟到子类中\n\n> AbsTemplate 抽象类中定义了一系列的方法，其中外界唯一能调用的 `operation()` 方法是 final 的*（即不可重写）*，在该方法中分别调用了 `first()` 、`second()` 、`third()` 方法*（即搭好算法框架）*，子类通过继承抽象类重写不同的方法来添加各自的行为\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/704e0cbaff34c187fec9afb55b0e60f9.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 模板方法模式.PNG\n\n## 8. 外观模式( Facade )\n\n为系统向外界提供一个统一的接口\n\n> Fracade 为 ComponentA 、ComponentB 、ComponentC 向外即 ClientA 、ClientB 提供统一的接口\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/33ca2f6aa4335c6fea29ce104dc6d75c.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 外观模式.PNG\n\n## 9. 适配器模式( Adapter )\n\n将一个类的接口转换成客户希望的另一个接口\n\n> 比如项目引入第三方类库后应该先封装起来转换成自己需要的接口再使用，防止以后类库出现变更。AdapterA 先将 LibraryClass 封装起来，其对外提供的 `operation()` 方法中调用 LibraryClass 对象的方法，若以后换类库，只需改 AdapterA 类或者创建新的 Adapter 实现类即可\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/1db7eb2746546ba047d0628898b3d2ce.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 适配器模式.PNG\n\n## 10. 桥接模式( Bridge )\n\n将抽象部分与实现部分分离，使它们都可以独立的变化\n\n> 将原本要耦合的上下层抽象出来，上层和下层以组合的方式连接，然后上下层抽象可派生出许多不同方向的子类。AbsShape 封装了 IDrawProgram 接口，这样它的子类想从 DPA 切换到 DPB 或者别的，只需 `set` 进去就行啦*（你看，这 UML 图多像座桥）*\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/0d76883319ee8cd0839e2d6f2c3f916d.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 桥接模式.PNG\n>\n> \n> 注： [适配器、桥接与外观三模式之间关系](http://blog.itpub.net/7243794/viewspace-837018/)\n\n## 11. 建造者模式( Builder )\n\n将一个复杂对象的构建与它的表示分离.\n\n> 作为 Product 的内部类，Builder 统一了 Product 的整个构建过程，同时在 `build` 过程中，可以由于 `set` 值顺序不同等原因产生不同的效果\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/cf070a5fb8111b1314aced631631197c.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 建造者模式.PNG\n\n## 12. 观察者模式( Observer )\n\n定义了一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象,在它的状态发生变化时,会通知所有的观察者.\n\n> 先将 Observer 注册到 Observable ，那么当 Observable 状态改变时会通知它持有的所有 Observer ,对了，最好 Observable 中的 mList 的泛型是 `WeakReference` ,防止内存泄漏\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/b1fe5f63e817d328c1f7e750cd5d93b4.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 观察者模式.PNG\n\n## 13. 单例模式( Singleton )\n\n保证一个类仅有一个实例,并提供一个访问它的全局控制点.\n\n> 下图是利用 Java 的语言特性实现的线程安全且能延迟初始化的单例模式，Singleton 中维护着静态私有的 SingleHolder 类， SingleHolder 类中持有个静态常量 sHolder ，Client 若通过 getSingleInstance 方法获取 Singleton 对象则直接返回 SingleHolder 类的 sHolder ，详细分析可转[这里](http://www.race604.com/java-double-checked-singleton/)\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/e30d9327210aceecf9bf5cb04269bf85.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 单例模式.PNG\n\n## 14. 命令模式( Command )\n\n将一个请求封装成为一个对象, 使可以用不同的请求对客户进行参数化\n\n> Action 封装了具体行为，Command 封装了 Action 并提供空方法 `execute()` ，它的子类通过重写该方法可在方法里调用 mAction 不同行为达到封装命令的目的，最后 Client 封装了一系列的 Command 对象，并可以通过 `notify()` 方法一个接着一个调用所持有 Command 对象们的 `execute()` 方法达到给 Action 传达命令的目的\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/98452fb637f4ad49b822cd6dcf01e364.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 命令模式.PNG","source":"_posts/面试/要点整理/设计模式.md","raw":"---\ntitle: 【第一课】设计模式\ndate: 2019-11-14\ntags:\n- 设计模式\ncategories:\n- 面试\n---\n\n> 本篇文章主要就设计模式的常见问题进行了讨论\n\n<!-- more -->\n\n## 六大原则\n\n1. 单一原则 每个类尽量实现独立的功能\n\n2. 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 针对继承\n\n3. 依赖倒置原则 避免高层依赖底层\n\n4. 接口隔离原则 接口往小了拆分\n\n5. 迪米特法则 每个单元对其他单元了解要尽可能小\n\n6. 开闭原则 尽量用扩展的方法，不去修改原来逻辑\n\n##  \n\n## 观察者模式\n\n对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n## 1. 策略模式( Strategy )\n\n定义个策略接口，不同的实现类提供不同的具体策略算法, 同时它们之间可以互相替换.\n\n> IStrategy 接口定义了策略方法，Strategy1 和 Strategy2 通过实现 IStrategy 提供不同的策略，而 User 组合了 IStrategy ，可以通过给 User 对象设置不同具体实现类来让其获得不同的策略\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/aa41f6375b2ddd59c91432e0a2145c25.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 策略模式.PNG\n\n## 2. 简单工厂模式( Simple Factory )\n\n定义一个用以创建对象的工厂, 根据不同的条件生成不同的对象\n\n\n\n> 注意简单工厂模式与策略模式是不同的，工厂模式是根据给定的条件返回相应的对象，而策略模式是将不同的策略对象传递给使用者以实现不同策略,*（好吧，我差点分不清了）*详细不同点分析可转[这里](http://blog.csdn.net/fwj380891124/article/details/7552305)\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/01dabedb62594e22287c10c8b6061a21.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 简单工厂模式.PNG\n\n## 3. 工厂模式( Factory )\n\n针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例\n\n> 与简单工厂模式不同点是它要为每一种产品提供一个工厂类，不同工厂类实现同一个工厂接口，返回不同产品，详细分析可转[这里](http://blog.csdn.net/superbeck/article/details/4446177)\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/08ca128f9c8a495acf5efafce66fa23e.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 工厂模式.PNG\n\n## 4. 抽象工厂模式( Abstract Factory )\n\n应对产品族概念而生\n\n> 与工厂模式相比，抽象工厂模式是为了应对产品族\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/946f97ce52089c1b3301deea2ced3aad.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 抽象工厂模式.PNG\n\n## 5. 装饰者模式( Decorator )\n\n动态的给一个对象添加一些额外的功能\n\n> ComponentImpl 和 Decorator 类都实现了 IComponent 接口，不同的是 ComponentImpl 提供了具体实现，而 Decorator 是先聚合 ComponentImpl 接着在自己的实现方法即 `operation()` 方法中做些处理*（即装饰）*后再调用 ComponentImpl 对象的具体实现\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/843c9c69723d1f4a9343239efaca216a.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 装饰者模式.PNG\n\n## 6. 代理模式( Proxy )\n\n封装被代理对象并限制外界对被代理对象的访问\n\n> 注意区分装饰者模式和代理模式的区别。在代理模式中，ComponentImpl 和 Proxy 类都实现了 IComponent 接口，Proxy 对象中虽然也维护着一个 ComponentImpl 对象，但一般情况下它是代理类自己初始化的，不像装饰者模式是通过 `set` 进去的，同时在接口方法即 `operation()` 中代理对象会限制外界对被代理对象的访问，而装饰者模式是装饰者给被装饰者添加额外的行为，详细不同点分析可转[这里](http://www.cnblogs.com/jaredlam/archive/2011/11/08/2241089.html)\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/4fcd2e4ee7cfed2d079fb4b95ed27dab.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 代理模式.PNG\n\n## 7. 模板方法模式( Template )\n\n定义一个操作的算法骨架, 并将一些步骤延迟到子类中\n\n> AbsTemplate 抽象类中定义了一系列的方法，其中外界唯一能调用的 `operation()` 方法是 final 的*（即不可重写）*，在该方法中分别调用了 `first()` 、`second()` 、`third()` 方法*（即搭好算法框架）*，子类通过继承抽象类重写不同的方法来添加各自的行为\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/704e0cbaff34c187fec9afb55b0e60f9.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 模板方法模式.PNG\n\n## 8. 外观模式( Facade )\n\n为系统向外界提供一个统一的接口\n\n> Fracade 为 ComponentA 、ComponentB 、ComponentC 向外即 ClientA 、ClientB 提供统一的接口\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/33ca2f6aa4335c6fea29ce104dc6d75c.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 外观模式.PNG\n\n## 9. 适配器模式( Adapter )\n\n将一个类的接口转换成客户希望的另一个接口\n\n> 比如项目引入第三方类库后应该先封装起来转换成自己需要的接口再使用，防止以后类库出现变更。AdapterA 先将 LibraryClass 封装起来，其对外提供的 `operation()` 方法中调用 LibraryClass 对象的方法，若以后换类库，只需改 AdapterA 类或者创建新的 Adapter 实现类即可\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/1db7eb2746546ba047d0628898b3d2ce.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 适配器模式.PNG\n\n## 10. 桥接模式( Bridge )\n\n将抽象部分与实现部分分离，使它们都可以独立的变化\n\n> 将原本要耦合的上下层抽象出来，上层和下层以组合的方式连接，然后上下层抽象可派生出许多不同方向的子类。AbsShape 封装了 IDrawProgram 接口，这样它的子类想从 DPA 切换到 DPB 或者别的，只需 `set` 进去就行啦*（你看，这 UML 图多像座桥）*\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/0d76883319ee8cd0839e2d6f2c3f916d.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 桥接模式.PNG\n>\n> \n> 注： [适配器、桥接与外观三模式之间关系](http://blog.itpub.net/7243794/viewspace-837018/)\n\n## 11. 建造者模式( Builder )\n\n将一个复杂对象的构建与它的表示分离.\n\n> 作为 Product 的内部类，Builder 统一了 Product 的整个构建过程，同时在 `build` 过程中，可以由于 `set` 值顺序不同等原因产生不同的效果\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/cf070a5fb8111b1314aced631631197c.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 建造者模式.PNG\n\n## 12. 观察者模式( Observer )\n\n定义了一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象,在它的状态发生变化时,会通知所有的观察者.\n\n> 先将 Observer 注册到 Observable ，那么当 Observable 状态改变时会通知它持有的所有 Observer ,对了，最好 Observable 中的 mList 的泛型是 `WeakReference` ,防止内存泄漏\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/b1fe5f63e817d328c1f7e750cd5d93b4.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 观察者模式.PNG\n\n## 13. 单例模式( Singleton )\n\n保证一个类仅有一个实例,并提供一个访问它的全局控制点.\n\n> 下图是利用 Java 的语言特性实现的线程安全且能延迟初始化的单例模式，Singleton 中维护着静态私有的 SingleHolder 类， SingleHolder 类中持有个静态常量 sHolder ，Client 若通过 getSingleInstance 方法获取 Singleton 对象则直接返回 SingleHolder 类的 sHolder ，详细分析可转[这里](http://www.race604.com/java-double-checked-singleton/)\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/e30d9327210aceecf9bf5cb04269bf85.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 单例模式.PNG\n\n## 14. 命令模式( Command )\n\n将一个请求封装成为一个对象, 使可以用不同的请求对客户进行参数化\n\n> Action 封装了具体行为，Command 封装了 Action 并提供空方法 `execute()` ，它的子类通过重写该方法可在方法里调用 mAction 不同行为达到封装命令的目的，最后 Client 封装了一系列的 Command 对象，并可以通过 `notify()` 方法一个接着一个调用所持有 Command 对象们的 `execute()` 方法达到给 Action 传达命令的目的\n>\n> ![img](https://user-gold-cdn.xitu.io/2016/11/29/98452fb637f4ad49b822cd6dcf01e364.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n>\n> 命令模式.PNG","slug":"面试/要点整理/设计模式","published":1,"updated":"2020-01-21T09:41:35.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7cxr5dw00125x8nhnrmfp0j","content":"<blockquote>\n<p>本篇文章主要就设计模式的常见问题进行了讨论</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h2 id=\"六大原则\"><a href=\"#六大原则\" class=\"headerlink\" title=\"六大原则\"></a>六大原则</h2><ol>\n<li><p>单一原则 每个类尽量实现独立的功能</p>\n</li>\n<li><p>里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 针对继承</p>\n</li>\n<li><p>依赖倒置原则 避免高层依赖底层</p>\n</li>\n<li><p>接口隔离原则 接口往小了拆分</p>\n</li>\n<li><p>迪米特法则 每个单元对其他单元了解要尽可能小</p>\n</li>\n<li><p>开闭原则 尽量用扩展的方法，不去修改原来逻辑</p>\n</li>\n</ol>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>\n<h2 id=\"1-策略模式-Strategy\"><a href=\"#1-策略模式-Strategy\" class=\"headerlink\" title=\"1. 策略模式( Strategy )\"></a>1. 策略模式( Strategy )</h2><p>定义个策略接口，不同的实现类提供不同的具体策略算法, 同时它们之间可以互相替换.</p>\n<blockquote>\n<p>IStrategy 接口定义了策略方法，Strategy1 和 Strategy2 通过实现 IStrategy 提供不同的策略，而 User 组合了 IStrategy ，可以通过给 User 对象设置不同具体实现类来让其获得不同的策略</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/aa41f6375b2ddd59c91432e0a2145c25.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>策略模式.PNG</p>\n</blockquote>\n<h2 id=\"2-简单工厂模式-Simple-Factory\"><a href=\"#2-简单工厂模式-Simple-Factory\" class=\"headerlink\" title=\"2. 简单工厂模式( Simple Factory )\"></a>2. 简单工厂模式( Simple Factory )</h2><p>定义一个用以创建对象的工厂, 根据不同的条件生成不同的对象</p>\n<blockquote>\n<p>注意简单工厂模式与策略模式是不同的，工厂模式是根据给定的条件返回相应的对象，而策略模式是将不同的策略对象传递给使用者以实现不同策略,<em>（好吧，我差点分不清了）</em>详细不同点分析可转<a href=\"http://blog.csdn.net/fwj380891124/article/details/7552305\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/01dabedb62594e22287c10c8b6061a21.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>简单工厂模式.PNG</p>\n</blockquote>\n<h2 id=\"3-工厂模式-Factory\"><a href=\"#3-工厂模式-Factory\" class=\"headerlink\" title=\"3. 工厂模式( Factory )\"></a>3. 工厂模式( Factory )</h2><p>针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例</p>\n<blockquote>\n<p>与简单工厂模式不同点是它要为每一种产品提供一个工厂类，不同工厂类实现同一个工厂接口，返回不同产品，详细分析可转<a href=\"http://blog.csdn.net/superbeck/article/details/4446177\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/08ca128f9c8a495acf5efafce66fa23e.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>工厂模式.PNG</p>\n</blockquote>\n<h2 id=\"4-抽象工厂模式-Abstract-Factory\"><a href=\"#4-抽象工厂模式-Abstract-Factory\" class=\"headerlink\" title=\"4. 抽象工厂模式( Abstract Factory )\"></a>4. 抽象工厂模式( Abstract Factory )</h2><p>应对产品族概念而生</p>\n<blockquote>\n<p>与工厂模式相比，抽象工厂模式是为了应对产品族</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/946f97ce52089c1b3301deea2ced3aad.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>抽象工厂模式.PNG</p>\n</blockquote>\n<h2 id=\"5-装饰者模式-Decorator\"><a href=\"#5-装饰者模式-Decorator\" class=\"headerlink\" title=\"5. 装饰者模式( Decorator )\"></a>5. 装饰者模式( Decorator )</h2><p>动态的给一个对象添加一些额外的功能</p>\n<blockquote>\n<p>ComponentImpl 和 Decorator 类都实现了 IComponent 接口，不同的是 ComponentImpl 提供了具体实现，而 Decorator 是先聚合 ComponentImpl 接着在自己的实现方法即 <code>operation()</code> 方法中做些处理<em>（即装饰）</em>后再调用 ComponentImpl 对象的具体实现</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/843c9c69723d1f4a9343239efaca216a.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>装饰者模式.PNG</p>\n</blockquote>\n<h2 id=\"6-代理模式-Proxy\"><a href=\"#6-代理模式-Proxy\" class=\"headerlink\" title=\"6. 代理模式( Proxy )\"></a>6. 代理模式( Proxy )</h2><p>封装被代理对象并限制外界对被代理对象的访问</p>\n<blockquote>\n<p>注意区分装饰者模式和代理模式的区别。在代理模式中，ComponentImpl 和 Proxy 类都实现了 IComponent 接口，Proxy 对象中虽然也维护着一个 ComponentImpl 对象，但一般情况下它是代理类自己初始化的，不像装饰者模式是通过 <code>set</code> 进去的，同时在接口方法即 <code>operation()</code> 中代理对象会限制外界对被代理对象的访问，而装饰者模式是装饰者给被装饰者添加额外的行为，详细不同点分析可转<a href=\"http://www.cnblogs.com/jaredlam/archive/2011/11/08/2241089.html\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/4fcd2e4ee7cfed2d079fb4b95ed27dab.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>代理模式.PNG</p>\n</blockquote>\n<h2 id=\"7-模板方法模式-Template\"><a href=\"#7-模板方法模式-Template\" class=\"headerlink\" title=\"7. 模板方法模式( Template )\"></a>7. 模板方法模式( Template )</h2><p>定义一个操作的算法骨架, 并将一些步骤延迟到子类中</p>\n<blockquote>\n<p>AbsTemplate 抽象类中定义了一系列的方法，其中外界唯一能调用的 <code>operation()</code> 方法是 final 的<em>（即不可重写）</em>，在该方法中分别调用了 <code>first()</code> 、<code>second()</code> 、<code>third()</code> 方法<em>（即搭好算法框架）</em>，子类通过继承抽象类重写不同的方法来添加各自的行为</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/704e0cbaff34c187fec9afb55b0e60f9.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>模板方法模式.PNG</p>\n</blockquote>\n<h2 id=\"8-外观模式-Facade\"><a href=\"#8-外观模式-Facade\" class=\"headerlink\" title=\"8. 外观模式( Facade )\"></a>8. 外观模式( Facade )</h2><p>为系统向外界提供一个统一的接口</p>\n<blockquote>\n<p>Fracade 为 ComponentA 、ComponentB 、ComponentC 向外即 ClientA 、ClientB 提供统一的接口</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/33ca2f6aa4335c6fea29ce104dc6d75c.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>外观模式.PNG</p>\n</blockquote>\n<h2 id=\"9-适配器模式-Adapter\"><a href=\"#9-适配器模式-Adapter\" class=\"headerlink\" title=\"9. 适配器模式( Adapter )\"></a>9. 适配器模式( Adapter )</h2><p>将一个类的接口转换成客户希望的另一个接口</p>\n<blockquote>\n<p>比如项目引入第三方类库后应该先封装起来转换成自己需要的接口再使用，防止以后类库出现变更。AdapterA 先将 LibraryClass 封装起来，其对外提供的 <code>operation()</code> 方法中调用 LibraryClass 对象的方法，若以后换类库，只需改 AdapterA 类或者创建新的 Adapter 实现类即可</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/1db7eb2746546ba047d0628898b3d2ce.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>适配器模式.PNG</p>\n</blockquote>\n<h2 id=\"10-桥接模式-Bridge\"><a href=\"#10-桥接模式-Bridge\" class=\"headerlink\" title=\"10. 桥接模式( Bridge )\"></a>10. 桥接模式( Bridge )</h2><p>将抽象部分与实现部分分离，使它们都可以独立的变化</p>\n<blockquote>\n<p>将原本要耦合的上下层抽象出来，上层和下层以组合的方式连接，然后上下层抽象可派生出许多不同方向的子类。AbsShape 封装了 IDrawProgram 接口，这样它的子类想从 DPA 切换到 DPB 或者别的，只需 <code>set</code> 进去就行啦<em>（你看，这 UML 图多像座桥）</em></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/0d76883319ee8cd0839e2d6f2c3f916d.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>桥接模式.PNG</p>\n<p>注： <a href=\"http://blog.itpub.net/7243794/viewspace-837018/\" target=\"_blank\" rel=\"noopener\">适配器、桥接与外观三模式之间关系</a></p>\n</blockquote>\n<h2 id=\"11-建造者模式-Builder\"><a href=\"#11-建造者模式-Builder\" class=\"headerlink\" title=\"11. 建造者模式( Builder )\"></a>11. 建造者模式( Builder )</h2><p>将一个复杂对象的构建与它的表示分离.</p>\n<blockquote>\n<p>作为 Product 的内部类，Builder 统一了 Product 的整个构建过程，同时在 <code>build</code> 过程中，可以由于 <code>set</code> 值顺序不同等原因产生不同的效果</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/cf070a5fb8111b1314aced631631197c.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>建造者模式.PNG</p>\n</blockquote>\n<h2 id=\"12-观察者模式-Observer\"><a href=\"#12-观察者模式-Observer\" class=\"headerlink\" title=\"12. 观察者模式( Observer )\"></a>12. 观察者模式( Observer )</h2><p>定义了一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象,在它的状态发生变化时,会通知所有的观察者.</p>\n<blockquote>\n<p>先将 Observer 注册到 Observable ，那么当 Observable 状态改变时会通知它持有的所有 Observer ,对了，最好 Observable 中的 mList 的泛型是 <code>WeakReference</code> ,防止内存泄漏</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/b1fe5f63e817d328c1f7e750cd5d93b4.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>观察者模式.PNG</p>\n</blockquote>\n<h2 id=\"13-单例模式-Singleton\"><a href=\"#13-单例模式-Singleton\" class=\"headerlink\" title=\"13. 单例模式( Singleton )\"></a>13. 单例模式( Singleton )</h2><p>保证一个类仅有一个实例,并提供一个访问它的全局控制点.</p>\n<blockquote>\n<p>下图是利用 Java 的语言特性实现的线程安全且能延迟初始化的单例模式，Singleton 中维护着静态私有的 SingleHolder 类， SingleHolder 类中持有个静态常量 sHolder ，Client 若通过 getSingleInstance 方法获取 Singleton 对象则直接返回 SingleHolder 类的 sHolder ，详细分析可转<a href=\"http://www.race604.com/java-double-checked-singleton/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/e30d9327210aceecf9bf5cb04269bf85.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>单例模式.PNG</p>\n</blockquote>\n<h2 id=\"14-命令模式-Command\"><a href=\"#14-命令模式-Command\" class=\"headerlink\" title=\"14. 命令模式( Command )\"></a>14. 命令模式( Command )</h2><p>将一个请求封装成为一个对象, 使可以用不同的请求对客户进行参数化</p>\n<blockquote>\n<p>Action 封装了具体行为，Command 封装了 Action 并提供空方法 <code>execute()</code> ，它的子类通过重写该方法可在方法里调用 mAction 不同行为达到封装命令的目的，最后 Client 封装了一系列的 Command 对象，并可以通过 <code>notify()</code> 方法一个接着一个调用所持有 Command 对象们的 <code>execute()</code> 方法达到给 Action 传达命令的目的</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/98452fb637f4ad49b822cd6dcf01e364.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>命令模式.PNG</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本篇文章主要就设计模式的常见问题进行了讨论</p>\n</blockquote>","more":"<h2 id=\"六大原则\"><a href=\"#六大原则\" class=\"headerlink\" title=\"六大原则\"></a>六大原则</h2><ol>\n<li><p>单一原则 每个类尽量实现独立的功能</p>\n</li>\n<li><p>里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能 针对继承</p>\n</li>\n<li><p>依赖倒置原则 避免高层依赖底层</p>\n</li>\n<li><p>接口隔离原则 接口往小了拆分</p>\n</li>\n<li><p>迪米特法则 每个单元对其他单元了解要尽可能小</p>\n</li>\n<li><p>开闭原则 尽量用扩展的方法，不去修改原来逻辑</p>\n</li>\n</ol>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>\n<h2 id=\"1-策略模式-Strategy\"><a href=\"#1-策略模式-Strategy\" class=\"headerlink\" title=\"1. 策略模式( Strategy )\"></a>1. 策略模式( Strategy )</h2><p>定义个策略接口，不同的实现类提供不同的具体策略算法, 同时它们之间可以互相替换.</p>\n<blockquote>\n<p>IStrategy 接口定义了策略方法，Strategy1 和 Strategy2 通过实现 IStrategy 提供不同的策略，而 User 组合了 IStrategy ，可以通过给 User 对象设置不同具体实现类来让其获得不同的策略</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/aa41f6375b2ddd59c91432e0a2145c25.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>策略模式.PNG</p>\n</blockquote>\n<h2 id=\"2-简单工厂模式-Simple-Factory\"><a href=\"#2-简单工厂模式-Simple-Factory\" class=\"headerlink\" title=\"2. 简单工厂模式( Simple Factory )\"></a>2. 简单工厂模式( Simple Factory )</h2><p>定义一个用以创建对象的工厂, 根据不同的条件生成不同的对象</p>\n<blockquote>\n<p>注意简单工厂模式与策略模式是不同的，工厂模式是根据给定的条件返回相应的对象，而策略模式是将不同的策略对象传递给使用者以实现不同策略,<em>（好吧，我差点分不清了）</em>详细不同点分析可转<a href=\"http://blog.csdn.net/fwj380891124/article/details/7552305\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/01dabedb62594e22287c10c8b6061a21.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>简单工厂模式.PNG</p>\n</blockquote>\n<h2 id=\"3-工厂模式-Factory\"><a href=\"#3-工厂模式-Factory\" class=\"headerlink\" title=\"3. 工厂模式( Factory )\"></a>3. 工厂模式( Factory )</h2><p>针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例</p>\n<blockquote>\n<p>与简单工厂模式不同点是它要为每一种产品提供一个工厂类，不同工厂类实现同一个工厂接口，返回不同产品，详细分析可转<a href=\"http://blog.csdn.net/superbeck/article/details/4446177\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/08ca128f9c8a495acf5efafce66fa23e.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>工厂模式.PNG</p>\n</blockquote>\n<h2 id=\"4-抽象工厂模式-Abstract-Factory\"><a href=\"#4-抽象工厂模式-Abstract-Factory\" class=\"headerlink\" title=\"4. 抽象工厂模式( Abstract Factory )\"></a>4. 抽象工厂模式( Abstract Factory )</h2><p>应对产品族概念而生</p>\n<blockquote>\n<p>与工厂模式相比，抽象工厂模式是为了应对产品族</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/946f97ce52089c1b3301deea2ced3aad.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>抽象工厂模式.PNG</p>\n</blockquote>\n<h2 id=\"5-装饰者模式-Decorator\"><a href=\"#5-装饰者模式-Decorator\" class=\"headerlink\" title=\"5. 装饰者模式( Decorator )\"></a>5. 装饰者模式( Decorator )</h2><p>动态的给一个对象添加一些额外的功能</p>\n<blockquote>\n<p>ComponentImpl 和 Decorator 类都实现了 IComponent 接口，不同的是 ComponentImpl 提供了具体实现，而 Decorator 是先聚合 ComponentImpl 接着在自己的实现方法即 <code>operation()</code> 方法中做些处理<em>（即装饰）</em>后再调用 ComponentImpl 对象的具体实现</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/843c9c69723d1f4a9343239efaca216a.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>装饰者模式.PNG</p>\n</blockquote>\n<h2 id=\"6-代理模式-Proxy\"><a href=\"#6-代理模式-Proxy\" class=\"headerlink\" title=\"6. 代理模式( Proxy )\"></a>6. 代理模式( Proxy )</h2><p>封装被代理对象并限制外界对被代理对象的访问</p>\n<blockquote>\n<p>注意区分装饰者模式和代理模式的区别。在代理模式中，ComponentImpl 和 Proxy 类都实现了 IComponent 接口，Proxy 对象中虽然也维护着一个 ComponentImpl 对象，但一般情况下它是代理类自己初始化的，不像装饰者模式是通过 <code>set</code> 进去的，同时在接口方法即 <code>operation()</code> 中代理对象会限制外界对被代理对象的访问，而装饰者模式是装饰者给被装饰者添加额外的行为，详细不同点分析可转<a href=\"http://www.cnblogs.com/jaredlam/archive/2011/11/08/2241089.html\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/4fcd2e4ee7cfed2d079fb4b95ed27dab.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>代理模式.PNG</p>\n</blockquote>\n<h2 id=\"7-模板方法模式-Template\"><a href=\"#7-模板方法模式-Template\" class=\"headerlink\" title=\"7. 模板方法模式( Template )\"></a>7. 模板方法模式( Template )</h2><p>定义一个操作的算法骨架, 并将一些步骤延迟到子类中</p>\n<blockquote>\n<p>AbsTemplate 抽象类中定义了一系列的方法，其中外界唯一能调用的 <code>operation()</code> 方法是 final 的<em>（即不可重写）</em>，在该方法中分别调用了 <code>first()</code> 、<code>second()</code> 、<code>third()</code> 方法<em>（即搭好算法框架）</em>，子类通过继承抽象类重写不同的方法来添加各自的行为</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/704e0cbaff34c187fec9afb55b0e60f9.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>模板方法模式.PNG</p>\n</blockquote>\n<h2 id=\"8-外观模式-Facade\"><a href=\"#8-外观模式-Facade\" class=\"headerlink\" title=\"8. 外观模式( Facade )\"></a>8. 外观模式( Facade )</h2><p>为系统向外界提供一个统一的接口</p>\n<blockquote>\n<p>Fracade 为 ComponentA 、ComponentB 、ComponentC 向外即 ClientA 、ClientB 提供统一的接口</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/33ca2f6aa4335c6fea29ce104dc6d75c.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>外观模式.PNG</p>\n</blockquote>\n<h2 id=\"9-适配器模式-Adapter\"><a href=\"#9-适配器模式-Adapter\" class=\"headerlink\" title=\"9. 适配器模式( Adapter )\"></a>9. 适配器模式( Adapter )</h2><p>将一个类的接口转换成客户希望的另一个接口</p>\n<blockquote>\n<p>比如项目引入第三方类库后应该先封装起来转换成自己需要的接口再使用，防止以后类库出现变更。AdapterA 先将 LibraryClass 封装起来，其对外提供的 <code>operation()</code> 方法中调用 LibraryClass 对象的方法，若以后换类库，只需改 AdapterA 类或者创建新的 Adapter 实现类即可</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/1db7eb2746546ba047d0628898b3d2ce.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>适配器模式.PNG</p>\n</blockquote>\n<h2 id=\"10-桥接模式-Bridge\"><a href=\"#10-桥接模式-Bridge\" class=\"headerlink\" title=\"10. 桥接模式( Bridge )\"></a>10. 桥接模式( Bridge )</h2><p>将抽象部分与实现部分分离，使它们都可以独立的变化</p>\n<blockquote>\n<p>将原本要耦合的上下层抽象出来，上层和下层以组合的方式连接，然后上下层抽象可派生出许多不同方向的子类。AbsShape 封装了 IDrawProgram 接口，这样它的子类想从 DPA 切换到 DPB 或者别的，只需 <code>set</code> 进去就行啦<em>（你看，这 UML 图多像座桥）</em></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/0d76883319ee8cd0839e2d6f2c3f916d.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>桥接模式.PNG</p>\n<p>注： <a href=\"http://blog.itpub.net/7243794/viewspace-837018/\" target=\"_blank\" rel=\"noopener\">适配器、桥接与外观三模式之间关系</a></p>\n</blockquote>\n<h2 id=\"11-建造者模式-Builder\"><a href=\"#11-建造者模式-Builder\" class=\"headerlink\" title=\"11. 建造者模式( Builder )\"></a>11. 建造者模式( Builder )</h2><p>将一个复杂对象的构建与它的表示分离.</p>\n<blockquote>\n<p>作为 Product 的内部类，Builder 统一了 Product 的整个构建过程，同时在 <code>build</code> 过程中，可以由于 <code>set</code> 值顺序不同等原因产生不同的效果</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/cf070a5fb8111b1314aced631631197c.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>建造者模式.PNG</p>\n</blockquote>\n<h2 id=\"12-观察者模式-Observer\"><a href=\"#12-观察者模式-Observer\" class=\"headerlink\" title=\"12. 观察者模式( Observer )\"></a>12. 观察者模式( Observer )</h2><p>定义了一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象,在它的状态发生变化时,会通知所有的观察者.</p>\n<blockquote>\n<p>先将 Observer 注册到 Observable ，那么当 Observable 状态改变时会通知它持有的所有 Observer ,对了，最好 Observable 中的 mList 的泛型是 <code>WeakReference</code> ,防止内存泄漏</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/b1fe5f63e817d328c1f7e750cd5d93b4.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>观察者模式.PNG</p>\n</blockquote>\n<h2 id=\"13-单例模式-Singleton\"><a href=\"#13-单例模式-Singleton\" class=\"headerlink\" title=\"13. 单例模式( Singleton )\"></a>13. 单例模式( Singleton )</h2><p>保证一个类仅有一个实例,并提供一个访问它的全局控制点.</p>\n<blockquote>\n<p>下图是利用 Java 的语言特性实现的线程安全且能延迟初始化的单例模式，Singleton 中维护着静态私有的 SingleHolder 类， SingleHolder 类中持有个静态常量 sHolder ，Client 若通过 getSingleInstance 方法获取 Singleton 对象则直接返回 SingleHolder 类的 sHolder ，详细分析可转<a href=\"http://www.race604.com/java-double-checked-singleton/\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/e30d9327210aceecf9bf5cb04269bf85.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>单例模式.PNG</p>\n</blockquote>\n<h2 id=\"14-命令模式-Command\"><a href=\"#14-命令模式-Command\" class=\"headerlink\" title=\"14. 命令模式( Command )\"></a>14. 命令模式( Command )</h2><p>将一个请求封装成为一个对象, 使可以用不同的请求对客户进行参数化</p>\n<blockquote>\n<p>Action 封装了具体行为，Command 封装了 Action 并提供空方法 <code>execute()</code> ，它的子类通过重写该方法可在方法里调用 mAction 不同行为达到封装命令的目的，最后 Client 封装了一系列的 Command 对象，并可以通过 <code>notify()</code> 方法一个接着一个调用所持有 Command 对象们的 <code>execute()</code> 方法达到给 Action 传达命令的目的</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"https://user-gold-cdn.xitu.io/2016/11/29/98452fb637f4ad49b822cd6dcf01e364.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"img\" title=\"\">\n                </div>\n                <div class=\"image-caption\">img</div>\n            </figure>\n\n<p>命令模式.PNG</p>\n</blockquote>"},{"title":"【第一课】网络","date":"2019-11-05T16:00:00.000Z","_content":"\n\n\n> 本篇文章主要就网络的常见问题进行了讨论\n\n<!-- more -->\n\n1. http的特性\n\n```\n无连接无状态。建立在tcp/ip协议上 的应用层上。\n\nhttp请求包含三个部分：状态头，请求头，消息主体。\n\nhttp的基本方法包含 get post put delete\n\n响应报文包含三个状态：状态行，响应头，响应正文。\n\n缺点是明文传输\n```\n\n\n\n2. 什么是会话\n\n```\n客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。\n\n会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。\n\n会话跟踪常用的方法：\n\n   i. url携带参数\n\n  ii. 隐藏表单域\n\n  iii. cookie\n\n  iv. session\n\ncookie是可以被客户端禁用的，session的实现依赖cookie，如果cookie被禁用，session就会失效。\n```\n\n\n\n3. 跨站攻击\n\n```\ncsrf 伪造用户请求， 可以通过检查reffer，token，验证码等方式避免\n\nxss 通过正常的交互将脚本嵌入页面，用户访问的时候即可启用。\n```\n\n\n\n4. https\n\n```\nhttps又称HTTP over SSL 在http协议上增加了ssl https安全的基础是ssl \n\n- 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全\n- 对网站服务器进行真实身份认证\n\n在交换密钥环节使用非对称加密方式解密证书（安全性高），之后的建立通信交换报文阶段则使用对称加密方式（解密效率高）。 \n\n缺点是 消耗资源较大和节省证书开销\n```\n\n\n\n5. spdy\n\n```\n多路复用：HTTP 1.x 在一条 TCP 连接上，多个请求只能串行执行。而 SPDY 使多个请求 stream 共享一个 TCP 连接的方式，做到了同时响应多个请求，解决了队头阻塞的问题。\n\n请求优先级\nheader压缩\n服务端推送\n强制使用https\n```\n\n6. http2.0\n\n```\n多路复用\n\n压缩header\n\n服务端推送\n\n与spdy的区别：\n\n新的二进制格式\n\n支持明文传输\n\nheader压缩方式不一样\n\n不强制使用https\n```\n\n\n\n7. osi七层模型\n\n```\n物理层->数据链路层->网络层->传输层->会话层->表示层->应用层\n```\n\n\n\n8. tcp/ip协议五层模型\n\n```\n物理层->数据链路层->网络层->传输层->应用层\n```\n\n\n\n9. 建立连接需要三次握手 四次挥手\n\n```\n为什么不用两次，如果网络不好，报文因为时间太久已失效。如果不三次握手，那么服务端同意连接，那么连接就会被连接起来，但是客户端一直不发送消息过来，服务端资源就会被占用了。\n```\n\n\n\n10. tcp和udp的区别\n\n```markdown\n- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\n\n- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付\n- TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的\n\n- 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信\n- TCP首部开销20字节;UDP的首部开销小，只有8个字节\n- TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\n```\n\n\n\n11. 什么叫syn攻击\n\n```\n攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。  SYN 攻击是一种典型的 DoS/DDoS 攻击。\n```\n\n\n\n12. tcp\n\n```markdown\n- TCP 提供一种面向连接的、可靠的**字节流服务**\n- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP\n- TCP 使用校验和，确认和重传机制来保证可靠传输\n- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复\n- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制\n\nkeep-alive 是服务端每隔一段时间对客户端发一个检测包，如果收到ACK，则认为该链接还存活。类似soaagent的健康检查。由此引出小米网俄罗斯的问题。\n```\n\n\n\n13. udp\n\n```markdown\n- udp不具有可靠性的数据报协议\n- udp是无连接的\n- udp的数据包是有边界的，且大小会随着数据包传过去的\n- 可以多播或者广播\n```\n\n\n\n14. keepalive和websocket\n\n```\n keep-alive 只是一种为了达到复用tcp连接的“协商”行为，双方并没有建立正真的连接会话，服务端也可以不认可，也可以随时（在任何一次请求完成后）关闭掉。WebSocket 不同，它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。\n\nkeep-alive 一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header\n\nwebsocket 通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接\n```\n\n\n\n15. tcp拥塞控制\n\n```\n慢开始 拥塞避免\n\n快重传 快恢复\n```\n\n\n\n16. 路由控制\n\n```\n路由控制(Routing)是指将分组数据发送到目标地址的功能，这个功能一般由路由器完成\n\n如果路由形成一个环路。\n```\n\n\n\n17. 子网掩码\n\n18. rpc.grpc\n\n| 名词   | 特点                                                         |\n| :----- | :----------------------------------------------------------- |\n| RPC    | 远程过程调用（分布式、微服务间的方法调用）                   |\n| HTTP   | 无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp） |\n| TCP    | 面向连接，三次握手保证通信可靠                               |\n| UDP    | 非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ） |\n| socket | TCP协议的接口实现，面向传输层进行网络编程                    |\n\n---\n\n\n\n#### 单独来谈一谈gRPC\n\ngRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。\n\n- 内容交换格式采用ProtoBuf(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。\n- 传输协议 采用http2，性能比http1.1好了很多\n\n\n[thrift](https://thrift.apache.org/)是Apache的一个跨语言的高性能的服务框架 这是一种描述语言，也是一个中间语言，IDL 一个使命就是规范和约束，规范使用类型，提供跨语言特性。通过工具分析 IDL 文件，生成各种语言代码\n\n事实上的跨语言序列化方案只有三个： protobuf, thrift, json。\n\n- json体积太大，并且缺少类型信息，实际上只用在RESTful接口上，并没有看到RPC框架会默认选json做序列化的。\n\n国内一些大公司的使用情况：\n\n- protobuf ，腾迅，百度等\n- thrift，小米，美团等","source":"_posts/面试/要点整理/网络.md","raw":"---\ntitle: 【第一课】网络\ndate: 2019-11-06\ntags:\n- http\n- 网络\ncategories:\n- 面试\n---\n\n\n\n> 本篇文章主要就网络的常见问题进行了讨论\n\n<!-- more -->\n\n1. http的特性\n\n```\n无连接无状态。建立在tcp/ip协议上 的应用层上。\n\nhttp请求包含三个部分：状态头，请求头，消息主体。\n\nhttp的基本方法包含 get post put delete\n\n响应报文包含三个状态：状态行，响应头，响应正文。\n\n缺点是明文传输\n```\n\n\n\n2. 什么是会话\n\n```\n客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。\n\n会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。\n\n会话跟踪常用的方法：\n\n   i. url携带参数\n\n  ii. 隐藏表单域\n\n  iii. cookie\n\n  iv. session\n\ncookie是可以被客户端禁用的，session的实现依赖cookie，如果cookie被禁用，session就会失效。\n```\n\n\n\n3. 跨站攻击\n\n```\ncsrf 伪造用户请求， 可以通过检查reffer，token，验证码等方式避免\n\nxss 通过正常的交互将脚本嵌入页面，用户访问的时候即可启用。\n```\n\n\n\n4. https\n\n```\nhttps又称HTTP over SSL 在http协议上增加了ssl https安全的基础是ssl \n\n- 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全\n- 对网站服务器进行真实身份认证\n\n在交换密钥环节使用非对称加密方式解密证书（安全性高），之后的建立通信交换报文阶段则使用对称加密方式（解密效率高）。 \n\n缺点是 消耗资源较大和节省证书开销\n```\n\n\n\n5. spdy\n\n```\n多路复用：HTTP 1.x 在一条 TCP 连接上，多个请求只能串行执行。而 SPDY 使多个请求 stream 共享一个 TCP 连接的方式，做到了同时响应多个请求，解决了队头阻塞的问题。\n\n请求优先级\nheader压缩\n服务端推送\n强制使用https\n```\n\n6. http2.0\n\n```\n多路复用\n\n压缩header\n\n服务端推送\n\n与spdy的区别：\n\n新的二进制格式\n\n支持明文传输\n\nheader压缩方式不一样\n\n不强制使用https\n```\n\n\n\n7. osi七层模型\n\n```\n物理层->数据链路层->网络层->传输层->会话层->表示层->应用层\n```\n\n\n\n8. tcp/ip协议五层模型\n\n```\n物理层->数据链路层->网络层->传输层->应用层\n```\n\n\n\n9. 建立连接需要三次握手 四次挥手\n\n```\n为什么不用两次，如果网络不好，报文因为时间太久已失效。如果不三次握手，那么服务端同意连接，那么连接就会被连接起来，但是客户端一直不发送消息过来，服务端资源就会被占用了。\n```\n\n\n\n10. tcp和udp的区别\n\n```markdown\n- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\n\n- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付\n- TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的\n\n- 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信\n- TCP首部开销20字节;UDP的首部开销小，只有8个字节\n- TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道\n```\n\n\n\n11. 什么叫syn攻击\n\n```\n攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。  SYN 攻击是一种典型的 DoS/DDoS 攻击。\n```\n\n\n\n12. tcp\n\n```markdown\n- TCP 提供一种面向连接的、可靠的**字节流服务**\n- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP\n- TCP 使用校验和，确认和重传机制来保证可靠传输\n- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复\n- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制\n\nkeep-alive 是服务端每隔一段时间对客户端发一个检测包，如果收到ACK，则认为该链接还存活。类似soaagent的健康检查。由此引出小米网俄罗斯的问题。\n```\n\n\n\n13. udp\n\n```markdown\n- udp不具有可靠性的数据报协议\n- udp是无连接的\n- udp的数据包是有边界的，且大小会随着数据包传过去的\n- 可以多播或者广播\n```\n\n\n\n14. keepalive和websocket\n\n```\n keep-alive 只是一种为了达到复用tcp连接的“协商”行为，双方并没有建立正真的连接会话，服务端也可以不认可，也可以随时（在任何一次请求完成后）关闭掉。WebSocket 不同，它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。\n\nkeep-alive 一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header\n\nwebsocket 通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接\n```\n\n\n\n15. tcp拥塞控制\n\n```\n慢开始 拥塞避免\n\n快重传 快恢复\n```\n\n\n\n16. 路由控制\n\n```\n路由控制(Routing)是指将分组数据发送到目标地址的功能，这个功能一般由路由器完成\n\n如果路由形成一个环路。\n```\n\n\n\n17. 子网掩码\n\n18. rpc.grpc\n\n| 名词   | 特点                                                         |\n| :----- | :----------------------------------------------------------- |\n| RPC    | 远程过程调用（分布式、微服务间的方法调用）                   |\n| HTTP   | 无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp） |\n| TCP    | 面向连接，三次握手保证通信可靠                               |\n| UDP    | 非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ） |\n| socket | TCP协议的接口实现，面向传输层进行网络编程                    |\n\n---\n\n\n\n#### 单独来谈一谈gRPC\n\ngRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。\n\n- 内容交换格式采用ProtoBuf(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。\n- 传输协议 采用http2，性能比http1.1好了很多\n\n\n[thrift](https://thrift.apache.org/)是Apache的一个跨语言的高性能的服务框架 这是一种描述语言，也是一个中间语言，IDL 一个使命就是规范和约束，规范使用类型，提供跨语言特性。通过工具分析 IDL 文件，生成各种语言代码\n\n事实上的跨语言序列化方案只有三个： protobuf, thrift, json。\n\n- json体积太大，并且缺少类型信息，实际上只用在RESTful接口上，并没有看到RPC框架会默认选json做序列化的。\n\n国内一些大公司的使用情况：\n\n- protobuf ，腾迅，百度等\n- thrift，小米，美团等","slug":"面试/要点整理/网络","published":1,"updated":"2020-01-21T09:40:46.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7cxr5dy00185x8nhdd93fie","content":"<blockquote>\n<p>本篇文章主要就网络的常见问题进行了讨论</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<ol>\n<li>http的特性</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无连接无状态。建立在tcp&#x2F;ip协议上 的应用层上。</span><br><span class=\"line\"></span><br><span class=\"line\">http请求包含三个部分：状态头，请求头，消息主体。</span><br><span class=\"line\"></span><br><span class=\"line\">http的基本方法包含 get post put delete</span><br><span class=\"line\"></span><br><span class=\"line\">响应报文包含三个状态：状态行，响应头，响应正文。</span><br><span class=\"line\"></span><br><span class=\"line\">缺点是明文传输</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"2\">\n<li>什么是会话</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。</span><br><span class=\"line\"></span><br><span class=\"line\">会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。</span><br><span class=\"line\"></span><br><span class=\"line\">会话跟踪常用的方法：</span><br><span class=\"line\"></span><br><span class=\"line\">   i. url携带参数</span><br><span class=\"line\"></span><br><span class=\"line\">  ii. 隐藏表单域</span><br><span class=\"line\"></span><br><span class=\"line\">  iii. cookie</span><br><span class=\"line\"></span><br><span class=\"line\">  iv. session</span><br><span class=\"line\"></span><br><span class=\"line\">cookie是可以被客户端禁用的，session的实现依赖cookie，如果cookie被禁用，session就会失效。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li>跨站攻击</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">csrf 伪造用户请求， 可以通过检查reffer，token，验证码等方式避免</span><br><span class=\"line\"></span><br><span class=\"line\">xss 通过正常的交互将脚本嵌入页面，用户访问的时候即可启用。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"4\">\n<li>https</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https又称HTTP over SSL 在http协议上增加了ssl https安全的基础是ssl </span><br><span class=\"line\"></span><br><span class=\"line\">- 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全</span><br><span class=\"line\">- 对网站服务器进行真实身份认证</span><br><span class=\"line\"></span><br><span class=\"line\">在交换密钥环节使用非对称加密方式解密证书（安全性高），之后的建立通信交换报文阶段则使用对称加密方式（解密效率高）。 </span><br><span class=\"line\"></span><br><span class=\"line\">缺点是 消耗资源较大和节省证书开销</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"5\">\n<li>spdy</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多路复用：HTTP 1.x 在一条 TCP 连接上，多个请求只能串行执行。而 SPDY 使多个请求 stream 共享一个 TCP 连接的方式，做到了同时响应多个请求，解决了队头阻塞的问题。</span><br><span class=\"line\"></span><br><span class=\"line\">请求优先级</span><br><span class=\"line\">header压缩</span><br><span class=\"line\">服务端推送</span><br><span class=\"line\">强制使用https</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>http2.0</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多路复用</span><br><span class=\"line\"></span><br><span class=\"line\">压缩header</span><br><span class=\"line\"></span><br><span class=\"line\">服务端推送</span><br><span class=\"line\"></span><br><span class=\"line\">与spdy的区别：</span><br><span class=\"line\"></span><br><span class=\"line\">新的二进制格式</span><br><span class=\"line\"></span><br><span class=\"line\">支持明文传输</span><br><span class=\"line\"></span><br><span class=\"line\">header压缩方式不一样</span><br><span class=\"line\"></span><br><span class=\"line\">不强制使用https</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"7\">\n<li>osi七层模型</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"8\">\n<li>tcp/ip协议五层模型</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用层</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"9\">\n<li>建立连接需要三次握手 四次挥手</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么不用两次，如果网络不好，报文因为时间太久已失效。如果不三次握手，那么服务端同意连接，那么连接就会被连接起来，但是客户端一直不发送消息过来，服务端资源就会被占用了。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"10\">\n<li>tcp和udp的区别</li>\n</ol>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">- </span>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP首部开销20字节;UDP的首部开销小，只有8个字节</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"11\">\n<li>什么叫syn攻击</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。  SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"12\">\n<li>tcp</li>\n</ol>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">- </span>TCP 提供一种面向连接的、可靠的<span class=\"strong\">**字节流服务**</span></span><br><span class=\"line\"><span class=\"bullet\">- </span>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP 使用校验和，确认和重传机制来保证可靠传输</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</span><br><span class=\"line\"></span><br><span class=\"line\">keep-alive 是服务端每隔一段时间对客户端发一个检测包，如果收到ACK，则认为该链接还存活。类似soaagent的健康检查。由此引出小米网俄罗斯的问题。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"13\">\n<li>udp</li>\n</ol>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">- </span>udp不具有可靠性的数据报协议</span><br><span class=\"line\"><span class=\"bullet\">- </span>udp是无连接的</span><br><span class=\"line\"><span class=\"bullet\">- </span>udp的数据包是有边界的，且大小会随着数据包传过去的</span><br><span class=\"line\"><span class=\"bullet\">- </span>可以多播或者广播</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"14\">\n<li>keepalive和websocket</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> keep-alive 只是一种为了达到复用tcp连接的“协商”行为，双方并没有建立正真的连接会话，服务端也可以不认可，也可以随时（在任何一次请求完成后）关闭掉。WebSocket 不同，它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。</span><br><span class=\"line\"></span><br><span class=\"line\">keep-alive 一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header</span><br><span class=\"line\"></span><br><span class=\"line\">websocket 通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"15\">\n<li>tcp拥塞控制</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">慢开始 拥塞避免</span><br><span class=\"line\"></span><br><span class=\"line\">快重传 快恢复</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"16\">\n<li>路由控制</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">路由控制(Routing)是指将分组数据发送到目标地址的功能，这个功能一般由路由器完成</span><br><span class=\"line\"></span><br><span class=\"line\">如果路由形成一个环路。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"17\">\n<li><p>子网掩码</p>\n</li>\n<li><p>rpc.grpc</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名词</th>\n<th align=\"left\">特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">RPC</td>\n<td align=\"left\">远程过程调用（分布式、微服务间的方法调用）</td>\n</tr>\n<tr>\n<td align=\"left\">HTTP</td>\n<td align=\"left\">无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp）</td>\n</tr>\n<tr>\n<td align=\"left\">TCP</td>\n<td align=\"left\">面向连接，三次握手保证通信可靠</td>\n</tr>\n<tr>\n<td align=\"left\">UDP</td>\n<td align=\"left\">非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ）</td>\n</tr>\n<tr>\n<td align=\"left\">socket</td>\n<td align=\"left\">TCP协议的接口实现，面向传输层进行网络编程</td>\n</tr>\n</tbody></table>\n<hr>\n<h4 id=\"单独来谈一谈gRPC\"><a href=\"#单独来谈一谈gRPC\" class=\"headerlink\" title=\"单独来谈一谈gRPC\"></a>单独来谈一谈gRPC</h4><p>gRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。</p>\n<ul>\n<li>内容交换格式采用ProtoBuf(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。</li>\n<li>传输协议 采用http2，性能比http1.1好了很多</li>\n</ul>\n<p><a href=\"https://thrift.apache.org/\" target=\"_blank\" rel=\"noopener\">thrift</a>是Apache的一个跨语言的高性能的服务框架 这是一种描述语言，也是一个中间语言，IDL 一个使命就是规范和约束，规范使用类型，提供跨语言特性。通过工具分析 IDL 文件，生成各种语言代码</p>\n<p>事实上的跨语言序列化方案只有三个： protobuf, thrift, json。</p>\n<ul>\n<li>json体积太大，并且缺少类型信息，实际上只用在RESTful接口上，并没有看到RPC框架会默认选json做序列化的。</li>\n</ul>\n<p>国内一些大公司的使用情况：</p>\n<ul>\n<li>protobuf ，腾迅，百度等</li>\n<li>thrift，小米，美团等</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本篇文章主要就网络的常见问题进行了讨论</p>\n</blockquote>","more":"<ol>\n<li>http的特性</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无连接无状态。建立在tcp&#x2F;ip协议上 的应用层上。</span><br><span class=\"line\"></span><br><span class=\"line\">http请求包含三个部分：状态头，请求头，消息主体。</span><br><span class=\"line\"></span><br><span class=\"line\">http的基本方法包含 get post put delete</span><br><span class=\"line\"></span><br><span class=\"line\">响应报文包含三个状态：状态行，响应头，响应正文。</span><br><span class=\"line\"></span><br><span class=\"line\">缺点是明文传输</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"2\">\n<li>什么是会话</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。</span><br><span class=\"line\"></span><br><span class=\"line\">会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。</span><br><span class=\"line\"></span><br><span class=\"line\">会话跟踪常用的方法：</span><br><span class=\"line\"></span><br><span class=\"line\">   i. url携带参数</span><br><span class=\"line\"></span><br><span class=\"line\">  ii. 隐藏表单域</span><br><span class=\"line\"></span><br><span class=\"line\">  iii. cookie</span><br><span class=\"line\"></span><br><span class=\"line\">  iv. session</span><br><span class=\"line\"></span><br><span class=\"line\">cookie是可以被客户端禁用的，session的实现依赖cookie，如果cookie被禁用，session就会失效。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"3\">\n<li>跨站攻击</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">csrf 伪造用户请求， 可以通过检查reffer，token，验证码等方式避免</span><br><span class=\"line\"></span><br><span class=\"line\">xss 通过正常的交互将脚本嵌入页面，用户访问的时候即可启用。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"4\">\n<li>https</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https又称HTTP over SSL 在http协议上增加了ssl https安全的基础是ssl </span><br><span class=\"line\"></span><br><span class=\"line\">- 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全</span><br><span class=\"line\">- 对网站服务器进行真实身份认证</span><br><span class=\"line\"></span><br><span class=\"line\">在交换密钥环节使用非对称加密方式解密证书（安全性高），之后的建立通信交换报文阶段则使用对称加密方式（解密效率高）。 </span><br><span class=\"line\"></span><br><span class=\"line\">缺点是 消耗资源较大和节省证书开销</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"5\">\n<li>spdy</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多路复用：HTTP 1.x 在一条 TCP 连接上，多个请求只能串行执行。而 SPDY 使多个请求 stream 共享一个 TCP 连接的方式，做到了同时响应多个请求，解决了队头阻塞的问题。</span><br><span class=\"line\"></span><br><span class=\"line\">请求优先级</span><br><span class=\"line\">header压缩</span><br><span class=\"line\">服务端推送</span><br><span class=\"line\">强制使用https</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>http2.0</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多路复用</span><br><span class=\"line\"></span><br><span class=\"line\">压缩header</span><br><span class=\"line\"></span><br><span class=\"line\">服务端推送</span><br><span class=\"line\"></span><br><span class=\"line\">与spdy的区别：</span><br><span class=\"line\"></span><br><span class=\"line\">新的二进制格式</span><br><span class=\"line\"></span><br><span class=\"line\">支持明文传输</span><br><span class=\"line\"></span><br><span class=\"line\">header压缩方式不一样</span><br><span class=\"line\"></span><br><span class=\"line\">不强制使用https</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"7\">\n<li>osi七层模型</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"8\">\n<li>tcp/ip协议五层模型</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用层</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"9\">\n<li>建立连接需要三次握手 四次挥手</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为什么不用两次，如果网络不好，报文因为时间太久已失效。如果不三次握手，那么服务端同意连接，那么连接就会被连接起来，但是客户端一直不发送消息过来，服务端资源就会被占用了。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"10\">\n<li>tcp和udp的区别</li>\n</ol>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">- </span>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP首部开销20字节;UDP的首部开销小，只有8个字节</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"11\">\n<li>什么叫syn攻击</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。  SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"12\">\n<li>tcp</li>\n</ol>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">- </span>TCP 提供一种面向连接的、可靠的<span class=\"strong\">**字节流服务**</span></span><br><span class=\"line\"><span class=\"bullet\">- </span>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP 使用校验和，确认和重传机制来保证可靠传输</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</span><br><span class=\"line\"><span class=\"bullet\">- </span>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</span><br><span class=\"line\"></span><br><span class=\"line\">keep-alive 是服务端每隔一段时间对客户端发一个检测包，如果收到ACK，则认为该链接还存活。类似soaagent的健康检查。由此引出小米网俄罗斯的问题。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"13\">\n<li>udp</li>\n</ol>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">- </span>udp不具有可靠性的数据报协议</span><br><span class=\"line\"><span class=\"bullet\">- </span>udp是无连接的</span><br><span class=\"line\"><span class=\"bullet\">- </span>udp的数据包是有边界的，且大小会随着数据包传过去的</span><br><span class=\"line\"><span class=\"bullet\">- </span>可以多播或者广播</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"14\">\n<li>keepalive和websocket</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> keep-alive 只是一种为了达到复用tcp连接的“协商”行为，双方并没有建立正真的连接会话，服务端也可以不认可，也可以随时（在任何一次请求完成后）关闭掉。WebSocket 不同，它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。</span><br><span class=\"line\"></span><br><span class=\"line\">keep-alive 一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header</span><br><span class=\"line\"></span><br><span class=\"line\">websocket 通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"15\">\n<li>tcp拥塞控制</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">慢开始 拥塞避免</span><br><span class=\"line\"></span><br><span class=\"line\">快重传 快恢复</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"16\">\n<li>路由控制</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">路由控制(Routing)是指将分组数据发送到目标地址的功能，这个功能一般由路由器完成</span><br><span class=\"line\"></span><br><span class=\"line\">如果路由形成一个环路。</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"17\">\n<li><p>子网掩码</p>\n</li>\n<li><p>rpc.grpc</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名词</th>\n<th align=\"left\">特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">RPC</td>\n<td align=\"left\">远程过程调用（分布式、微服务间的方法调用）</td>\n</tr>\n<tr>\n<td align=\"left\">HTTP</td>\n<td align=\"left\">无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp）</td>\n</tr>\n<tr>\n<td align=\"left\">TCP</td>\n<td align=\"left\">面向连接，三次握手保证通信可靠</td>\n</tr>\n<tr>\n<td align=\"left\">UDP</td>\n<td align=\"left\">非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ）</td>\n</tr>\n<tr>\n<td align=\"left\">socket</td>\n<td align=\"left\">TCP协议的接口实现，面向传输层进行网络编程</td>\n</tr>\n</tbody></table>\n<hr>\n<h4 id=\"单独来谈一谈gRPC\"><a href=\"#单独来谈一谈gRPC\" class=\"headerlink\" title=\"单独来谈一谈gRPC\"></a>单独来谈一谈gRPC</h4><p>gRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。</p>\n<ul>\n<li>内容交换格式采用ProtoBuf(Google Protocol Buffers)，开源已久，提供了一种灵活、高效、自动序列化结构数据的机制，作用与XML，Json类似，但使用二进制，（反）序列化速度快，压缩效率高。</li>\n<li>传输协议 采用http2，性能比http1.1好了很多</li>\n</ul>\n<p><a href=\"https://thrift.apache.org/\" target=\"_blank\" rel=\"noopener\">thrift</a>是Apache的一个跨语言的高性能的服务框架 这是一种描述语言，也是一个中间语言，IDL 一个使命就是规范和约束，规范使用类型，提供跨语言特性。通过工具分析 IDL 文件，生成各种语言代码</p>\n<p>事实上的跨语言序列化方案只有三个： protobuf, thrift, json。</p>\n<ul>\n<li>json体积太大，并且缺少类型信息，实际上只用在RESTful接口上，并没有看到RPC框架会默认选json做序列化的。</li>\n</ul>\n<p>国内一些大公司的使用情况：</p>\n<ul>\n<li>protobuf ，腾迅，百度等</li>\n<li>thrift，小米，美团等</li>\n</ul>"},{"title":"【第一课】高频面试点","date":"2020-02-29T16:00:00.000Z","_content":"\n\n\n排序\n\n二分变形\n\n递归搜索\n\n二叉树遍历\n\n\n\n排序可以扩展出多种排序 如堆排序 合并排序\n\n\n\ngo的sync包和 多线程 多协程并发控制\n\n\n\n网络编程 NIO 网络模型\n\n\n\n高并发系统设计， API层设计 存储设计 容灾设计 数据流 模块设计\n\n\n\n","source":"_posts/面试/要点整理/高频面试点.md","raw":"---\ntitle: 【第一课】高频面试点\ndate: 2020-3-1\ntags:\n- linux\ncategories:\n- 面试\n---\n\n\n\n排序\n\n二分变形\n\n递归搜索\n\n二叉树遍历\n\n\n\n排序可以扩展出多种排序 如堆排序 合并排序\n\n\n\ngo的sync包和 多线程 多协程并发控制\n\n\n\n网络编程 NIO 网络模型\n\n\n\n高并发系统设计， API层设计 存储设计 容灾设计 数据流 模块设计\n\n\n\n","slug":"面试/要点整理/高频面试点","published":1,"updated":"2020-03-01T03:36:31.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7cxr5dz001b5x8ne3sp17hz","content":"<p>排序</p>\n<p>二分变形</p>\n<p>递归搜索</p>\n<p>二叉树遍历</p>\n<p>排序可以扩展出多种排序 如堆排序 合并排序</p>\n<p>go的sync包和 多线程 多协程并发控制</p>\n<p>网络编程 NIO 网络模型</p>\n<p>高并发系统设计， API层设计 存储设计 容灾设计 数据流 模块设计</p>\n","site":{"data":{}},"excerpt":"","more":"<p>排序</p>\n<p>二分变形</p>\n<p>递归搜索</p>\n<p>二叉树遍历</p>\n<p>排序可以扩展出多种排序 如堆排序 合并排序</p>\n<p>go的sync包和 多线程 多协程并发控制</p>\n<p>网络编程 NIO 网络模型</p>\n<p>高并发系统设计， API层设计 存储设计 容灾设计 数据流 模块设计</p>\n"},{"title":"【面试复盘】百度面试","date":"2020-02-29T16:00:00.000Z","_content":"\n\n\n### etcd和redis\n\n``` \n数据库版本控制\n\n高可用 \n```\n\n","source":"_posts/面试/复盘/3.18百度面试.md","raw":"---\ntitle: 【面试复盘】百度面试\ndate: 2020-03-1\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n### etcd和redis\n\n``` \n数据库版本控制\n\n高可用 \n```\n\n","slug":"面试/复盘/3.18百度面试","published":1,"updated":"2020-03-18T05:25:25.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck845eiwz0000ny8nan4edl6j","content":"<h3 id=\"etcd和redis\"><a href=\"#etcd和redis\" class=\"headerlink\" title=\"etcd和redis\"></a>etcd和redis</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据库版本控制</span><br><span class=\"line\"></span><br><span class=\"line\">高可用</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"etcd和redis\"><a href=\"#etcd和redis\" class=\"headerlink\" title=\"etcd和redis\"></a>etcd和redis</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据库版本控制</span><br><span class=\"line\"></span><br><span class=\"line\">高可用</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【面试复盘】腾讯面试","date":"2020-03-13T16:00:00.000Z","_content":"\n\n\n### redis 常用数据类型\n\n\n\n### redis的删除机制\n\n### mysql 查询数据量较大的时候\n\n\n\n\n\n### cap\n\n","source":"_posts/面试/复盘/3.14腾讯面试.md","raw":"---\ntitle: 【面试复盘】腾讯面试\ndate: 2020-03-14\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n### redis 常用数据类型\n\n\n\n### redis的删除机制\n\n### mysql 查询数据量较大的时候\n\n\n\n\n\n### cap\n\n","slug":"面试/复盘/3.14腾讯面试","published":1,"updated":"2020-03-17T06:46:26.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck845eix30001ny8na01y8cxy","content":"<h3 id=\"redis-常用数据类型\"><a href=\"#redis-常用数据类型\" class=\"headerlink\" title=\"redis 常用数据类型\"></a>redis 常用数据类型</h3><h3 id=\"redis的删除机制\"><a href=\"#redis的删除机制\" class=\"headerlink\" title=\"redis的删除机制\"></a>redis的删除机制</h3><h3 id=\"mysql-查询数据量较大的时候\"><a href=\"#mysql-查询数据量较大的时候\" class=\"headerlink\" title=\"mysql 查询数据量较大的时候\"></a>mysql 查询数据量较大的时候</h3><h3 id=\"cap\"><a href=\"#cap\" class=\"headerlink\" title=\"cap\"></a>cap</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"redis-常用数据类型\"><a href=\"#redis-常用数据类型\" class=\"headerlink\" title=\"redis 常用数据类型\"></a>redis 常用数据类型</h3><h3 id=\"redis的删除机制\"><a href=\"#redis的删除机制\" class=\"headerlink\" title=\"redis的删除机制\"></a>redis的删除机制</h3><h3 id=\"mysql-查询数据量较大的时候\"><a href=\"#mysql-查询数据量较大的时候\" class=\"headerlink\" title=\"mysql 查询数据量较大的时候\"></a>mysql 查询数据量较大的时候</h3><h3 id=\"cap\"><a href=\"#cap\" class=\"headerlink\" title=\"cap\"></a>cap</h3>"},{"title":"【面试复盘】腾讯面试","date":"2020-03-12T16:00:00.000Z","_content":"\n\n\n```\n//where a=1 and b=2 and c=3\n   //where a=1 and b<2 and c=3\n   //where a<2 and b=2\n   //where b=1 and c=2\n   //where a=1 and b=2 order by c<3\n\n   //var funcList []func()\n   //for i := 0; i < 3; i++ {\n   // funcList = append(funcList, func() {\n   //    println(i)\n   // })\n   //\n   //}\n   //\n   //for j := 0; j < 3; j++ {\n   // funcList[j]()\n   //}\n```\n\n\n\n\n\n### 消息队列推拉分别的利弊\n\n```\nPush方式：\n优点：有消息就推给消费者。延迟小,几乎可以做到实时。等等。。。。\n\n缺点：Server端接收到消息后，主动把消息推送给Client端，实时性高。对于一个提供队列服务的Server来说，用Push方式主动推送有很多弊端；首先是加大Server端的工作量，进而影响Server的性能，其次Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题。\n\n菠萝科技注：意思是1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点。\n\nPull方式：\n优点：对比push优点就是消费者可以根据自己能力拉取消息处理。。。\n\n缺点：Client端循环地从Server端拉取消息，主动权在Client手里，自己拉取到一定量消息后，处理妥当了再接着取。Pull方式的问题是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。\n\n菠萝科技注：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull。\n\n长轮询：\nCMQ (腾讯)提供了长轮询的优化方法，用以平衡 Pull/Push 模型各自的缺点。\n\n```\n\n\n\n### nginx\n\n\n\n### Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。\n\n### redis cluster \n\nCodis 需要通过 Proxy 来定位目标节点，RedisCluster 是直接定位。客户端为了可以直接定位某个具体的 key 所在的节点，它就需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。\n\nCluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。\n\n\n\n### 线程 进程和携程\n\n```\n协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）\n对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。\n\n内存消耗方面\n每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。\ngoroutine：2KB（官方）\n线程：8MB（参考网络）\n\n线程和 goroutine 切换调度开销方面\n线程/goroutine 切换开销方面，goroutine 远比线程小\n线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。\ngoroutine：只有三个寄存器的值修改 - PC / SP / DX.\n```\n\n","source":"_posts/面试/复盘/3.13腾讯面试.md","raw":"---\ntitle: 【面试复盘】腾讯面试\ndate: 2020-03-13\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n```\n//where a=1 and b=2 and c=3\n   //where a=1 and b<2 and c=3\n   //where a<2 and b=2\n   //where b=1 and c=2\n   //where a=1 and b=2 order by c<3\n\n   //var funcList []func()\n   //for i := 0; i < 3; i++ {\n   // funcList = append(funcList, func() {\n   //    println(i)\n   // })\n   //\n   //}\n   //\n   //for j := 0; j < 3; j++ {\n   // funcList[j]()\n   //}\n```\n\n\n\n\n\n### 消息队列推拉分别的利弊\n\n```\nPush方式：\n优点：有消息就推给消费者。延迟小,几乎可以做到实时。等等。。。。\n\n缺点：Server端接收到消息后，主动把消息推送给Client端，实时性高。对于一个提供队列服务的Server来说，用Push方式主动推送有很多弊端；首先是加大Server端的工作量，进而影响Server的性能，其次Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题。\n\n菠萝科技注：意思是1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点。\n\nPull方式：\n优点：对比push优点就是消费者可以根据自己能力拉取消息处理。。。\n\n缺点：Client端循环地从Server端拉取消息，主动权在Client手里，自己拉取到一定量消息后，处理妥当了再接着取。Pull方式的问题是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。\n\n菠萝科技注：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull。\n\n长轮询：\nCMQ (腾讯)提供了长轮询的优化方法，用以平衡 Pull/Push 模型各自的缺点。\n\n```\n\n\n\n### nginx\n\n\n\n### Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。\n\n### redis cluster \n\nCodis 需要通过 Proxy 来定位目标节点，RedisCluster 是直接定位。客户端为了可以直接定位某个具体的 key 所在的节点，它就需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。\n\nCluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。\n\n\n\n### 线程 进程和携程\n\n```\n协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）\n对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。\n\n内存消耗方面\n每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。\ngoroutine：2KB（官方）\n线程：8MB（参考网络）\n\n线程和 goroutine 切换调度开销方面\n线程/goroutine 切换开销方面，goroutine 远比线程小\n线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。\ngoroutine：只有三个寄存器的值修改 - PC / SP / DX.\n```\n\n","slug":"面试/复盘/3.13腾讯面试","published":1,"updated":"2020-03-18T06:20:08.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck845eix50003ny8nals8fozq","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;where a&#x3D;1 and b&#x3D;2 and c&#x3D;3</span><br><span class=\"line\">   &#x2F;&#x2F;where a&#x3D;1 and b&lt;2 and c&#x3D;3</span><br><span class=\"line\">   &#x2F;&#x2F;where a&lt;2 and b&#x3D;2</span><br><span class=\"line\">   &#x2F;&#x2F;where b&#x3D;1 and c&#x3D;2</span><br><span class=\"line\">   &#x2F;&#x2F;where a&#x3D;1 and b&#x3D;2 order by c&lt;3</span><br><span class=\"line\"></span><br><span class=\"line\">   &#x2F;&#x2F;var funcList []func()</span><br><span class=\"line\">   &#x2F;&#x2F;for i :&#x3D; 0; i &lt; 3; i++ &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; funcList &#x3D; append(funcList, func() &#123;</span><br><span class=\"line\">   &#x2F;&#x2F;    println(i)</span><br><span class=\"line\">   &#x2F;&#x2F; &#125;)</span><br><span class=\"line\">   &#x2F;&#x2F;</span><br><span class=\"line\">   &#x2F;&#x2F;&#125;</span><br><span class=\"line\">   &#x2F;&#x2F;</span><br><span class=\"line\">   &#x2F;&#x2F;for j :&#x3D; 0; j &lt; 3; j++ &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; funcList[j]()</span><br><span class=\"line\">   &#x2F;&#x2F;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"消息队列推拉分别的利弊\"><a href=\"#消息队列推拉分别的利弊\" class=\"headerlink\" title=\"消息队列推拉分别的利弊\"></a>消息队列推拉分别的利弊</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Push方式：</span><br><span class=\"line\">优点：有消息就推给消费者。延迟小,几乎可以做到实时。等等。。。。</span><br><span class=\"line\"></span><br><span class=\"line\">缺点：Server端接收到消息后，主动把消息推送给Client端，实时性高。对于一个提供队列服务的Server来说，用Push方式主动推送有很多弊端；首先是加大Server端的工作量，进而影响Server的性能，其次Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题。</span><br><span class=\"line\"></span><br><span class=\"line\">菠萝科技注：意思是1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点。</span><br><span class=\"line\"></span><br><span class=\"line\">Pull方式：</span><br><span class=\"line\">优点：对比push优点就是消费者可以根据自己能力拉取消息处理。。。</span><br><span class=\"line\"></span><br><span class=\"line\">缺点：Client端循环地从Server端拉取消息，主动权在Client手里，自己拉取到一定量消息后，处理妥当了再接着取。Pull方式的问题是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。</span><br><span class=\"line\"></span><br><span class=\"line\">菠萝科技注：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull。</span><br><span class=\"line\"></span><br><span class=\"line\">长轮询：</span><br><span class=\"line\">CMQ (腾讯)提供了长轮询的优化方法，用以平衡 Pull&#x2F;Push 模型各自的缺点。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><h3 id=\"Golang-在-runtime、系统调用等多方面对-goroutine-调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前-goroutine-的CPU-P-转让出去，让其他-goroutine-能被调度并执行，也就是-Golang-从语言层面支持了协程。\"><a href=\"#Golang-在-runtime、系统调用等多方面对-goroutine-调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前-goroutine-的CPU-P-转让出去，让其他-goroutine-能被调度并执行，也就是-Golang-从语言层面支持了协程。\" class=\"headerlink\" title=\"Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。\"></a>Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。</h3><h3 id=\"redis-cluster\"><a href=\"#redis-cluster\" class=\"headerlink\" title=\"redis cluster\"></a>redis cluster</h3><p>Codis 需要通过 Proxy 来定位目标节点，RedisCluster 是直接定位。客户端为了可以直接定位某个具体的 key 所在的节点，它就需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。</p>\n<p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。</p>\n<h3 id=\"线程-进程和携程\"><a href=\"#线程-进程和携程\" class=\"headerlink\" title=\"线程 进程和携程\"></a>线程 进程和携程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</span><br><span class=\"line\">对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）</span><br><span class=\"line\">对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</span><br><span class=\"line\"></span><br><span class=\"line\">内存消耗方面</span><br><span class=\"line\">每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。</span><br><span class=\"line\">goroutine：2KB（官方）</span><br><span class=\"line\">线程：8MB（参考网络）</span><br><span class=\"line\"></span><br><span class=\"line\">线程和 goroutine 切换调度开销方面</span><br><span class=\"line\">线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小</span><br><span class=\"line\">线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。</span><br><span class=\"line\">goroutine：只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;where a&#x3D;1 and b&#x3D;2 and c&#x3D;3</span><br><span class=\"line\">   &#x2F;&#x2F;where a&#x3D;1 and b&lt;2 and c&#x3D;3</span><br><span class=\"line\">   &#x2F;&#x2F;where a&lt;2 and b&#x3D;2</span><br><span class=\"line\">   &#x2F;&#x2F;where b&#x3D;1 and c&#x3D;2</span><br><span class=\"line\">   &#x2F;&#x2F;where a&#x3D;1 and b&#x3D;2 order by c&lt;3</span><br><span class=\"line\"></span><br><span class=\"line\">   &#x2F;&#x2F;var funcList []func()</span><br><span class=\"line\">   &#x2F;&#x2F;for i :&#x3D; 0; i &lt; 3; i++ &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; funcList &#x3D; append(funcList, func() &#123;</span><br><span class=\"line\">   &#x2F;&#x2F;    println(i)</span><br><span class=\"line\">   &#x2F;&#x2F; &#125;)</span><br><span class=\"line\">   &#x2F;&#x2F;</span><br><span class=\"line\">   &#x2F;&#x2F;&#125;</span><br><span class=\"line\">   &#x2F;&#x2F;</span><br><span class=\"line\">   &#x2F;&#x2F;for j :&#x3D; 0; j &lt; 3; j++ &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; funcList[j]()</span><br><span class=\"line\">   &#x2F;&#x2F;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"消息队列推拉分别的利弊\"><a href=\"#消息队列推拉分别的利弊\" class=\"headerlink\" title=\"消息队列推拉分别的利弊\"></a>消息队列推拉分别的利弊</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Push方式：</span><br><span class=\"line\">优点：有消息就推给消费者。延迟小,几乎可以做到实时。等等。。。。</span><br><span class=\"line\"></span><br><span class=\"line\">缺点：Server端接收到消息后，主动把消息推送给Client端，实时性高。对于一个提供队列服务的Server来说，用Push方式主动推送有很多弊端；首先是加大Server端的工作量，进而影响Server的性能，其次Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题。</span><br><span class=\"line\"></span><br><span class=\"line\">菠萝科技注：意思是1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点。</span><br><span class=\"line\"></span><br><span class=\"line\">Pull方式：</span><br><span class=\"line\">优点：对比push优点就是消费者可以根据自己能力拉取消息处理。。。</span><br><span class=\"line\"></span><br><span class=\"line\">缺点：Client端循环地从Server端拉取消息，主动权在Client手里，自己拉取到一定量消息后，处理妥当了再接着取。Pull方式的问题是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。</span><br><span class=\"line\"></span><br><span class=\"line\">菠萝科技注：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull。</span><br><span class=\"line\"></span><br><span class=\"line\">长轮询：</span><br><span class=\"line\">CMQ (腾讯)提供了长轮询的优化方法，用以平衡 Pull&#x2F;Push 模型各自的缺点。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><h3 id=\"Golang-在-runtime、系统调用等多方面对-goroutine-调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前-goroutine-的CPU-P-转让出去，让其他-goroutine-能被调度并执行，也就是-Golang-从语言层面支持了协程。\"><a href=\"#Golang-在-runtime、系统调用等多方面对-goroutine-调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前-goroutine-的CPU-P-转让出去，让其他-goroutine-能被调度并执行，也就是-Golang-从语言层面支持了协程。\" class=\"headerlink\" title=\"Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。\"></a>Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。</h3><h3 id=\"redis-cluster\"><a href=\"#redis-cluster\" class=\"headerlink\" title=\"redis cluster\"></a>redis cluster</h3><p>Codis 需要通过 Proxy 来定位目标节点，RedisCluster 是直接定位。客户端为了可以直接定位某个具体的 key 所在的节点，它就需要缓存槽位相关信息，这样才可以准确快速地定位到相应的节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。</p>\n<p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。</p>\n<h3 id=\"线程-进程和携程\"><a href=\"#线程-进程和携程\" class=\"headerlink\" title=\"线程 进程和携程\"></a>线程 进程和携程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</span><br><span class=\"line\">对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）</span><br><span class=\"line\">对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</span><br><span class=\"line\"></span><br><span class=\"line\">内存消耗方面</span><br><span class=\"line\">每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。</span><br><span class=\"line\">goroutine：2KB（官方）</span><br><span class=\"line\">线程：8MB（参考网络）</span><br><span class=\"line\"></span><br><span class=\"line\">线程和 goroutine 切换调度开销方面</span><br><span class=\"line\">线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小</span><br><span class=\"line\">线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。</span><br><span class=\"line\">goroutine：只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【第一课】etcd&zookeeper","date":"2020-03-23T08:14:00.000Z","_content":"\n\n\n### etcd 和zookeeper\n\n```\netcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 ZooKeeper 和 Doozer，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。Raft是一个来自Stanford的新的一致性算法，适用于分布式系统的日志复制，Raft通过选举的方式来实现一致性，在Raft中，任何一个节点都可能成为Leader。Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。\n\netcd 集群的工作原理基于 raft 共识算法 (The Raft Consensus Algorithm)。etcd 在 0.5.0 版本中重新实现了 raft 算法，而非像之前那样依赖于第三方库 (https://github.com/goraft/raft) 。raft 共识算法的优点在于可以在高效的解决分布式系统中各个节点日志内容一致性问题的同时，也使得集群具备一定的容错能力。即使集群中出现部分节点故障、网络故障等问题，仍可保证其余大多数节点正确的步进。甚至当更多的节点（一般来说超过集群节点总数的一半）出现故障而导致集群不可用时，依然可以保证节点中的数据不会出现错误的结果。\n```\n\n```\nZookeeper是一个用户维护配置信息、命名、分布式同步以及分组服务的集中式服务框架，它使用Java语言编写，通过(http://www.stanford.edu/class/cs347/reading/zab.pdf)协议来保证节点的一致性。因为Zookeeper是一个CP型系统，所以当网络分区问题发生时，系统就不能注册或查找服务。\n\netcd是一个用于共享配置和服务发现的高可用的键值存储系统，使用Go语言编写，通过Raft来保证一致性，有基于HTTP+JSON的API接口。etcd也是一个强一致性系统，但是etcd似乎支持从non-leaders中读取数据以提高可用性；另外，写操作仍然需要leader的支持，所以在网络分区时，写操作仍可能失败。\n\n在原生接口和提供服务方式方面，etcd更适合作为集群配置服务器，用来存储集群中的大量数据。方便的REST接口也可以让集群中的任意一个节点在使用Key/Value服务时获取方便。ZooKeeper则更加的适合于提供分布式协调服务，他在实现分布式锁模型方面较etcd要简单的多。所以在实际使用中应该根据自身使用情况来选择相应的服务。\n```\n\n```\n并且在面对网络分区的时候，为了保持一致性，读取的可用性是可以牺牲的。\n\n```\n\n\n\n### 能否用redis替代etcd\n\n```\n不能 \n1、redis 没有版本的概念，历史版本数据在大规模微服务中非常有必要，对于状态回滚和故障排查，甚至定锅都很重要\n2、redis 的注册和发现目前只能通过 pub 和 sub 来实现，这两个命令完全不能满足生产环境的要求，具体原因可以 gg 或看源码实现\n3、etcd 在 2.+版本时，watch 到数据官方文档均建议再 get 一次，因为会存在数据延迟，3.+版本不再需要，可想 redis 的 pub 和 sub 能否达到此种低延迟的要求\n4、楼主看到的微服务架构应该都是将 etcd 直接暴露给 client 和 server 的，etcd 的性能摆在那，能够承受多少的 c/s 直连呢，更好的做法应该是对 etcd 做一层保护，当然这种做法会损失一些功能\n5、redis 和 etcd 的集群实现方案是不一致的，etcd 采用的是 raft 协议，一主多从，只能写主，底层采用 boltdb 作为 k/v 存储，直接落盘\n6、redis 的持久化方案有 aof 和 rdb，这两种方案在宕机的时候都或多或少的会丢失数据\n\n总结，瑞迪斯从来没有想过抢 etcd 在服务注册和发现的饭碗，目前的架构来说也抢不动，在缓存方面目前在性能和功能也无出其右； etcd 只关注在服务注册与发现方面，非要当做 k/v 存储来用（丢弃 watch 特性而言）也可以用，性能也不错，但只能说你选错对象了\n```\n\n```\npubsub 不会保留历史信息, 收到就行, 收不到也不会重复通知, 换句话说, 你必须客户端永远在线, 才能收到 sub 的信息, 一旦客户端网络短时间出问题, 就收不到变更通知了, redis 可以做, 但是不是用 pubsub 做, 而是要自己做一个定时的轮询, 时刻保持客户端信息最新\n```\n\n\n\n```\nCAP： \nC：Consistency 即一致性\nA：Availability 即可用性\nP：Partiton tolerence 即分区容忍性\n\netcd是CP的 而redis是AP的\n```\n\n","source":"_posts/面试/要点整理/etcd&zookeeper.md","raw":"---\ntitle: 【第一课】etcd&zookeeper\ndate: 2020-03-23 16:14:00\ntags:\n- golang\ncategories:\n- 面试\n---\n\n\n\n### etcd 和zookeeper\n\n```\netcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 ZooKeeper 和 Doozer，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。Raft是一个来自Stanford的新的一致性算法，适用于分布式系统的日志复制，Raft通过选举的方式来实现一致性，在Raft中，任何一个节点都可能成为Leader。Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。\n\netcd 集群的工作原理基于 raft 共识算法 (The Raft Consensus Algorithm)。etcd 在 0.5.0 版本中重新实现了 raft 算法，而非像之前那样依赖于第三方库 (https://github.com/goraft/raft) 。raft 共识算法的优点在于可以在高效的解决分布式系统中各个节点日志内容一致性问题的同时，也使得集群具备一定的容错能力。即使集群中出现部分节点故障、网络故障等问题，仍可保证其余大多数节点正确的步进。甚至当更多的节点（一般来说超过集群节点总数的一半）出现故障而导致集群不可用时，依然可以保证节点中的数据不会出现错误的结果。\n```\n\n```\nZookeeper是一个用户维护配置信息、命名、分布式同步以及分组服务的集中式服务框架，它使用Java语言编写，通过(http://www.stanford.edu/class/cs347/reading/zab.pdf)协议来保证节点的一致性。因为Zookeeper是一个CP型系统，所以当网络分区问题发生时，系统就不能注册或查找服务。\n\netcd是一个用于共享配置和服务发现的高可用的键值存储系统，使用Go语言编写，通过Raft来保证一致性，有基于HTTP+JSON的API接口。etcd也是一个强一致性系统，但是etcd似乎支持从non-leaders中读取数据以提高可用性；另外，写操作仍然需要leader的支持，所以在网络分区时，写操作仍可能失败。\n\n在原生接口和提供服务方式方面，etcd更适合作为集群配置服务器，用来存储集群中的大量数据。方便的REST接口也可以让集群中的任意一个节点在使用Key/Value服务时获取方便。ZooKeeper则更加的适合于提供分布式协调服务，他在实现分布式锁模型方面较etcd要简单的多。所以在实际使用中应该根据自身使用情况来选择相应的服务。\n```\n\n```\n并且在面对网络分区的时候，为了保持一致性，读取的可用性是可以牺牲的。\n\n```\n\n\n\n### 能否用redis替代etcd\n\n```\n不能 \n1、redis 没有版本的概念，历史版本数据在大规模微服务中非常有必要，对于状态回滚和故障排查，甚至定锅都很重要\n2、redis 的注册和发现目前只能通过 pub 和 sub 来实现，这两个命令完全不能满足生产环境的要求，具体原因可以 gg 或看源码实现\n3、etcd 在 2.+版本时，watch 到数据官方文档均建议再 get 一次，因为会存在数据延迟，3.+版本不再需要，可想 redis 的 pub 和 sub 能否达到此种低延迟的要求\n4、楼主看到的微服务架构应该都是将 etcd 直接暴露给 client 和 server 的，etcd 的性能摆在那，能够承受多少的 c/s 直连呢，更好的做法应该是对 etcd 做一层保护，当然这种做法会损失一些功能\n5、redis 和 etcd 的集群实现方案是不一致的，etcd 采用的是 raft 协议，一主多从，只能写主，底层采用 boltdb 作为 k/v 存储，直接落盘\n6、redis 的持久化方案有 aof 和 rdb，这两种方案在宕机的时候都或多或少的会丢失数据\n\n总结，瑞迪斯从来没有想过抢 etcd 在服务注册和发现的饭碗，目前的架构来说也抢不动，在缓存方面目前在性能和功能也无出其右； etcd 只关注在服务注册与发现方面，非要当做 k/v 存储来用（丢弃 watch 特性而言）也可以用，性能也不错，但只能说你选错对象了\n```\n\n```\npubsub 不会保留历史信息, 收到就行, 收不到也不会重复通知, 换句话说, 你必须客户端永远在线, 才能收到 sub 的信息, 一旦客户端网络短时间出问题, 就收不到变更通知了, redis 可以做, 但是不是用 pubsub 做, 而是要自己做一个定时的轮询, 时刻保持客户端信息最新\n```\n\n\n\n```\nCAP： \nC：Consistency 即一致性\nA：Availability 即可用性\nP：Partiton tolerence 即分区容忍性\n\netcd是CP的 而redis是AP的\n```\n\n","slug":"面试/要点整理/etcd&zookeeper","published":1,"updated":"2020-03-23T06:44:14.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck845eix60005ny8n87fngdrc","content":"<h3 id=\"etcd-和zookeeper\"><a href=\"#etcd-和zookeeper\" class=\"headerlink\" title=\"etcd 和zookeeper\"></a>etcd 和zookeeper</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 ZooKeeper 和 Doozer，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。Raft是一个来自Stanford的新的一致性算法，适用于分布式系统的日志复制，Raft通过选举的方式来实现一致性，在Raft中，任何一个节点都可能成为Leader。Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。</span><br><span class=\"line\"></span><br><span class=\"line\">etcd 集群的工作原理基于 raft 共识算法 (The Raft Consensus Algorithm)。etcd 在 0.5.0 版本中重新实现了 raft 算法，而非像之前那样依赖于第三方库 (https:&#x2F;&#x2F;github.com&#x2F;goraft&#x2F;raft) 。raft 共识算法的优点在于可以在高效的解决分布式系统中各个节点日志内容一致性问题的同时，也使得集群具备一定的容错能力。即使集群中出现部分节点故障、网络故障等问题，仍可保证其余大多数节点正确的步进。甚至当更多的节点（一般来说超过集群节点总数的一半）出现故障而导致集群不可用时，依然可以保证节点中的数据不会出现错误的结果。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Zookeeper是一个用户维护配置信息、命名、分布式同步以及分组服务的集中式服务框架，它使用Java语言编写，通过(http:&#x2F;&#x2F;www.stanford.edu&#x2F;class&#x2F;cs347&#x2F;reading&#x2F;zab.pdf)协议来保证节点的一致性。因为Zookeeper是一个CP型系统，所以当网络分区问题发生时，系统就不能注册或查找服务。</span><br><span class=\"line\"></span><br><span class=\"line\">etcd是一个用于共享配置和服务发现的高可用的键值存储系统，使用Go语言编写，通过Raft来保证一致性，有基于HTTP+JSON的API接口。etcd也是一个强一致性系统，但是etcd似乎支持从non-leaders中读取数据以提高可用性；另外，写操作仍然需要leader的支持，所以在网络分区时，写操作仍可能失败。</span><br><span class=\"line\"></span><br><span class=\"line\">在原生接口和提供服务方式方面，etcd更适合作为集群配置服务器，用来存储集群中的大量数据。方便的REST接口也可以让集群中的任意一个节点在使用Key&#x2F;Value服务时获取方便。ZooKeeper则更加的适合于提供分布式协调服务，他在实现分布式锁模型方面较etcd要简单的多。所以在实际使用中应该根据自身使用情况来选择相应的服务。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">并且在面对网络分区的时候，为了保持一致性，读取的可用性是可以牺牲的。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"能否用redis替代etcd\"><a href=\"#能否用redis替代etcd\" class=\"headerlink\" title=\"能否用redis替代etcd\"></a>能否用redis替代etcd</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不能 </span><br><span class=\"line\">1、redis 没有版本的概念，历史版本数据在大规模微服务中非常有必要，对于状态回滚和故障排查，甚至定锅都很重要</span><br><span class=\"line\">2、redis 的注册和发现目前只能通过 pub 和 sub 来实现，这两个命令完全不能满足生产环境的要求，具体原因可以 gg 或看源码实现</span><br><span class=\"line\">3、etcd 在 2.+版本时，watch 到数据官方文档均建议再 get 一次，因为会存在数据延迟，3.+版本不再需要，可想 redis 的 pub 和 sub 能否达到此种低延迟的要求</span><br><span class=\"line\">4、楼主看到的微服务架构应该都是将 etcd 直接暴露给 client 和 server 的，etcd 的性能摆在那，能够承受多少的 c&#x2F;s 直连呢，更好的做法应该是对 etcd 做一层保护，当然这种做法会损失一些功能</span><br><span class=\"line\">5、redis 和 etcd 的集群实现方案是不一致的，etcd 采用的是 raft 协议，一主多从，只能写主，底层采用 boltdb 作为 k&#x2F;v 存储，直接落盘</span><br><span class=\"line\">6、redis 的持久化方案有 aof 和 rdb，这两种方案在宕机的时候都或多或少的会丢失数据</span><br><span class=\"line\"></span><br><span class=\"line\">总结，瑞迪斯从来没有想过抢 etcd 在服务注册和发现的饭碗，目前的架构来说也抢不动，在缓存方面目前在性能和功能也无出其右； etcd 只关注在服务注册与发现方面，非要当做 k&#x2F;v 存储来用（丢弃 watch 特性而言）也可以用，性能也不错，但只能说你选错对象了</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pubsub 不会保留历史信息, 收到就行, 收不到也不会重复通知, 换句话说, 你必须客户端永远在线, 才能收到 sub 的信息, 一旦客户端网络短时间出问题, 就收不到变更通知了, redis 可以做, 但是不是用 pubsub 做, 而是要自己做一个定时的轮询, 时刻保持客户端信息最新</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAP： </span><br><span class=\"line\">C：Consistency 即一致性</span><br><span class=\"line\">A：Availability 即可用性</span><br><span class=\"line\">P：Partiton tolerence 即分区容忍性</span><br><span class=\"line\"></span><br><span class=\"line\">etcd是CP的 而redis是AP的</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"etcd-和zookeeper\"><a href=\"#etcd-和zookeeper\" class=\"headerlink\" title=\"etcd 和zookeeper\"></a>etcd 和zookeeper</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现。etcd是由CoreOS开发并维护的，灵感来自于 ZooKeeper 和 Doozer，它使用Go语言编写，并通过Raft一致性算法处理日志复制以保证强一致性。Raft是一个来自Stanford的新的一致性算法，适用于分布式系统的日志复制，Raft通过选举的方式来实现一致性，在Raft中，任何一个节点都可能成为Leader。Google的容器集群管理系统Kubernetes、开源PaaS平台Cloud Foundry和CoreOS的Fleet都广泛使用了etcd。</span><br><span class=\"line\"></span><br><span class=\"line\">etcd 集群的工作原理基于 raft 共识算法 (The Raft Consensus Algorithm)。etcd 在 0.5.0 版本中重新实现了 raft 算法，而非像之前那样依赖于第三方库 (https:&#x2F;&#x2F;github.com&#x2F;goraft&#x2F;raft) 。raft 共识算法的优点在于可以在高效的解决分布式系统中各个节点日志内容一致性问题的同时，也使得集群具备一定的容错能力。即使集群中出现部分节点故障、网络故障等问题，仍可保证其余大多数节点正确的步进。甚至当更多的节点（一般来说超过集群节点总数的一半）出现故障而导致集群不可用时，依然可以保证节点中的数据不会出现错误的结果。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Zookeeper是一个用户维护配置信息、命名、分布式同步以及分组服务的集中式服务框架，它使用Java语言编写，通过(http:&#x2F;&#x2F;www.stanford.edu&#x2F;class&#x2F;cs347&#x2F;reading&#x2F;zab.pdf)协议来保证节点的一致性。因为Zookeeper是一个CP型系统，所以当网络分区问题发生时，系统就不能注册或查找服务。</span><br><span class=\"line\"></span><br><span class=\"line\">etcd是一个用于共享配置和服务发现的高可用的键值存储系统，使用Go语言编写，通过Raft来保证一致性，有基于HTTP+JSON的API接口。etcd也是一个强一致性系统，但是etcd似乎支持从non-leaders中读取数据以提高可用性；另外，写操作仍然需要leader的支持，所以在网络分区时，写操作仍可能失败。</span><br><span class=\"line\"></span><br><span class=\"line\">在原生接口和提供服务方式方面，etcd更适合作为集群配置服务器，用来存储集群中的大量数据。方便的REST接口也可以让集群中的任意一个节点在使用Key&#x2F;Value服务时获取方便。ZooKeeper则更加的适合于提供分布式协调服务，他在实现分布式锁模型方面较etcd要简单的多。所以在实际使用中应该根据自身使用情况来选择相应的服务。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">并且在面对网络分区的时候，为了保持一致性，读取的可用性是可以牺牲的。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"能否用redis替代etcd\"><a href=\"#能否用redis替代etcd\" class=\"headerlink\" title=\"能否用redis替代etcd\"></a>能否用redis替代etcd</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不能 </span><br><span class=\"line\">1、redis 没有版本的概念，历史版本数据在大规模微服务中非常有必要，对于状态回滚和故障排查，甚至定锅都很重要</span><br><span class=\"line\">2、redis 的注册和发现目前只能通过 pub 和 sub 来实现，这两个命令完全不能满足生产环境的要求，具体原因可以 gg 或看源码实现</span><br><span class=\"line\">3、etcd 在 2.+版本时，watch 到数据官方文档均建议再 get 一次，因为会存在数据延迟，3.+版本不再需要，可想 redis 的 pub 和 sub 能否达到此种低延迟的要求</span><br><span class=\"line\">4、楼主看到的微服务架构应该都是将 etcd 直接暴露给 client 和 server 的，etcd 的性能摆在那，能够承受多少的 c&#x2F;s 直连呢，更好的做法应该是对 etcd 做一层保护，当然这种做法会损失一些功能</span><br><span class=\"line\">5、redis 和 etcd 的集群实现方案是不一致的，etcd 采用的是 raft 协议，一主多从，只能写主，底层采用 boltdb 作为 k&#x2F;v 存储，直接落盘</span><br><span class=\"line\">6、redis 的持久化方案有 aof 和 rdb，这两种方案在宕机的时候都或多或少的会丢失数据</span><br><span class=\"line\"></span><br><span class=\"line\">总结，瑞迪斯从来没有想过抢 etcd 在服务注册和发现的饭碗，目前的架构来说也抢不动，在缓存方面目前在性能和功能也无出其右； etcd 只关注在服务注册与发现方面，非要当做 k&#x2F;v 存储来用（丢弃 watch 特性而言）也可以用，性能也不错，但只能说你选错对象了</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pubsub 不会保留历史信息, 收到就行, 收不到也不会重复通知, 换句话说, 你必须客户端永远在线, 才能收到 sub 的信息, 一旦客户端网络短时间出问题, 就收不到变更通知了, redis 可以做, 但是不是用 pubsub 做, 而是要自己做一个定时的轮询, 时刻保持客户端信息最新</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CAP： </span><br><span class=\"line\">C：Consistency 即一致性</span><br><span class=\"line\">A：Availability 即可用性</span><br><span class=\"line\">P：Partiton tolerence 即分区容忍性</span><br><span class=\"line\"></span><br><span class=\"line\">etcd是CP的 而redis是AP的</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【面试复盘】百度面试","date":"2020-02-29T16:00:00.000Z","_content":"\n\n\n### 聚簇索引和非聚簇索引的区别\n\n\n\n```\n聚集索引与非聚集索引的区别是：叶节点是否存放一整行记录\n\nInnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。\n```\n\n```\n聚簇索引的优点\n1.当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。\n2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。\n3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。\n\n```\n\n```\n1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。\n2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。\n3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。\n4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。\n\n```\n\n\n\n### 并发和并行\n\n```\n并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。\n并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。\n\n前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生．\n```\n\n","source":"_posts/面试/复盘/3.19搜狐面试.md","raw":"---\ntitle: 【面试复盘】百度面试\ndate: 2020-03-1\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n### 聚簇索引和非聚簇索引的区别\n\n\n\n```\n聚集索引与非聚集索引的区别是：叶节点是否存放一整行记录\n\nInnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。\n```\n\n```\n聚簇索引的优点\n1.当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。\n2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。\n3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。\n\n```\n\n```\n1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。\n2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。\n3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。\n4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。\n\n```\n\n\n\n### 并发和并行\n\n```\n并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。\n并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。\n\n前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生．\n```\n\n","slug":"面试/复盘/3.19搜狐面试","published":1,"updated":"2020-03-23T02:41:12.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck845eix70008ny8n3lgyh8rv","content":"<h3 id=\"聚簇索引和非聚簇索引的区别\"><a href=\"#聚簇索引和非聚簇索引的区别\" class=\"headerlink\" title=\"聚簇索引和非聚簇索引的区别\"></a>聚簇索引和非聚簇索引的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">聚集索引与非聚集索引的区别是：叶节点是否存放一整行记录</span><br><span class=\"line\"></span><br><span class=\"line\">InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">聚簇索引的优点</span><br><span class=\"line\">1.当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。</span><br><span class=\"line\">2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I&#x2F;O。</span><br><span class=\"line\">3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</span><br><span class=\"line\">2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</span><br><span class=\"line\">3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</span><br><span class=\"line\">4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I&#x2F;O代价。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。</span><br><span class=\"line\">并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。</span><br><span class=\"line\"></span><br><span class=\"line\">前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生．</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"聚簇索引和非聚簇索引的区别\"><a href=\"#聚簇索引和非聚簇索引的区别\" class=\"headerlink\" title=\"聚簇索引和非聚簇索引的区别\"></a>聚簇索引和非聚簇索引的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">聚集索引与非聚集索引的区别是：叶节点是否存放一整行记录</span><br><span class=\"line\"></span><br><span class=\"line\">InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">聚簇索引的优点</span><br><span class=\"line\">1.当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。</span><br><span class=\"line\">2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I&#x2F;O。</span><br><span class=\"line\">3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。</span><br><span class=\"line\">2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</span><br><span class=\"line\">3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。</span><br><span class=\"line\">4.采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I&#x2F;O代价。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"并发和并行\"><a href=\"#并发和并行\" class=\"headerlink\" title=\"并发和并行\"></a>并发和并行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。</span><br><span class=\"line\">并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。</span><br><span class=\"line\"></span><br><span class=\"line\">前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生．</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【面试复盘】腾讯面试","date":"2020-03-09T16:00:00.000Z","_content":"\n\n\n### 哪种索引的性能最好\n\n```\n索引的选择性是指，不重复的索引值（也称为基数）和数据表的记录总数（rows）的比值，范围从1/rows到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让Mysql在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。而假如我们是按某个表的性别字段作为索引列，这样选择性就很低，索引效果就不是很明显。\n```\n\n\n\n### 什么时候用不到索引\n\n```\n以%开头的 like 查询不能利用 B-Tree 索引，执行计划中 key 的值为 null 表示没有使用索引\n数据类型出现隐式转换的时候也不会使用索引，例如，where 'age' 10=30\n对索引列进行函数运算，原因同上\n正则表达式不会使用索引\n字符串和数据比较不会使用索引\n复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则 leftmost，是不会使用复合索引的\n如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引\n用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到\n使用负向查询（not ，not in， not like ，<> ,!= ,!> ,!< ） 不会使用索引\n```\n\n\n\n\n\n### redis 压缩列表 跳表 \n\n\n\n### aof日志量过大的时候重写，瘦身\n\n","source":"_posts/面试/复盘/3.10腾讯面试.md","raw":"---\ntitle: 【面试复盘】腾讯面试\ndate: 2020-03-10\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n### 哪种索引的性能最好\n\n```\n索引的选择性是指，不重复的索引值（也称为基数）和数据表的记录总数（rows）的比值，范围从1/rows到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让Mysql在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。而假如我们是按某个表的性别字段作为索引列，这样选择性就很低，索引效果就不是很明显。\n```\n\n\n\n### 什么时候用不到索引\n\n```\n以%开头的 like 查询不能利用 B-Tree 索引，执行计划中 key 的值为 null 表示没有使用索引\n数据类型出现隐式转换的时候也不会使用索引，例如，where 'age' 10=30\n对索引列进行函数运算，原因同上\n正则表达式不会使用索引\n字符串和数据比较不会使用索引\n复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则 leftmost，是不会使用复合索引的\n如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引\n用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到\n使用负向查询（not ，not in， not like ，<> ,!= ,!> ,!< ） 不会使用索引\n```\n\n\n\n\n\n### redis 压缩列表 跳表 \n\n\n\n### aof日志量过大的时候重写，瘦身\n\n","slug":"面试/复盘/3.10腾讯面试","published":1,"updated":"2020-03-24T10:58:03.116Z","_id":"ck845eixg000bny8n5v49ek2h","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"哪种索引的性能最好\"><a href=\"#哪种索引的性能最好\" class=\"headerlink\" title=\"哪种索引的性能最好\"></a>哪种索引的性能最好</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">索引的选择性是指，不重复的索引值（也称为基数）和数据表的记录总数（rows）的比值，范围从1&#x2F;rows到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让Mysql在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。而假如我们是按某个表的性别字段作为索引列，这样选择性就很低，索引效果就不是很明显。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"什么时候用不到索引\"><a href=\"#什么时候用不到索引\" class=\"headerlink\" title=\"什么时候用不到索引\"></a>什么时候用不到索引</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以%开头的 like 查询不能利用 B-Tree 索引，执行计划中 key 的值为 null 表示没有使用索引</span><br><span class=\"line\">数据类型出现隐式转换的时候也不会使用索引，例如，where &#39;age&#39; 10&#x3D;30</span><br><span class=\"line\">对索引列进行函数运算，原因同上</span><br><span class=\"line\">正则表达式不会使用索引</span><br><span class=\"line\">字符串和数据比较不会使用索引</span><br><span class=\"line\">复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则 leftmost，是不会使用复合索引的</span><br><span class=\"line\">如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引</span><br><span class=\"line\">用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到</span><br><span class=\"line\">使用负向查询（not ，not in， not like ，&lt;&gt; ,!&#x3D; ,!&gt; ,!&lt; ） 不会使用索引</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"redis-压缩列表-跳表\"><a href=\"#redis-压缩列表-跳表\" class=\"headerlink\" title=\"redis 压缩列表 跳表\"></a>redis 压缩列表 跳表</h3><h3 id=\"aof日志量过大的时候重写，瘦身\"><a href=\"#aof日志量过大的时候重写，瘦身\" class=\"headerlink\" title=\"aof日志量过大的时候重写，瘦身\"></a>aof日志量过大的时候重写，瘦身</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"哪种索引的性能最好\"><a href=\"#哪种索引的性能最好\" class=\"headerlink\" title=\"哪种索引的性能最好\"></a>哪种索引的性能最好</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">索引的选择性是指，不重复的索引值（也称为基数）和数据表的记录总数（rows）的比值，范围从1&#x2F;rows到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让Mysql在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。而假如我们是按某个表的性别字段作为索引列，这样选择性就很低，索引效果就不是很明显。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"什么时候用不到索引\"><a href=\"#什么时候用不到索引\" class=\"headerlink\" title=\"什么时候用不到索引\"></a>什么时候用不到索引</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以%开头的 like 查询不能利用 B-Tree 索引，执行计划中 key 的值为 null 表示没有使用索引</span><br><span class=\"line\">数据类型出现隐式转换的时候也不会使用索引，例如，where &#39;age&#39; 10&#x3D;30</span><br><span class=\"line\">对索引列进行函数运算，原因同上</span><br><span class=\"line\">正则表达式不会使用索引</span><br><span class=\"line\">字符串和数据比较不会使用索引</span><br><span class=\"line\">复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则 leftmost，是不会使用复合索引的</span><br><span class=\"line\">如果 MySQL 估计使用索引比全表扫描更慢，则不使用索引</span><br><span class=\"line\">用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到</span><br><span class=\"line\">使用负向查询（not ，not in， not like ，&lt;&gt; ,!&#x3D; ,!&gt; ,!&lt; ） 不会使用索引</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"redis-压缩列表-跳表\"><a href=\"#redis-压缩列表-跳表\" class=\"headerlink\" title=\"redis 压缩列表 跳表\"></a>redis 压缩列表 跳表</h3><h3 id=\"aof日志量过大的时候重写，瘦身\"><a href=\"#aof日志量过大的时候重写，瘦身\" class=\"headerlink\" title=\"aof日志量过大的时候重写，瘦身\"></a>aof日志量过大的时候重写，瘦身</h3>"},{"title":"【第一课】golang常考知识点","date":"2020-03-19T08:14:00.000Z","_content":"\n\n\n\n\n### 数组和切片的区别\n\n```\n数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。\n我们其实可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。\n```\n\n\n\n### golang中的引用类型\n\n```\n在golang中只有三种引用类型它们分别是切片slice、字典map、管道channel。其它的全部是值类型，引用类型可以简单的理解为指针类型，它们都是通过make完成初始化\n```\n\n\n\n### 进程 线程 和 协程\n\n```\n 进程、线程(内核级线程)、协程(用户级线程)\n\n协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）\n对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。\n\n内存消耗方面\n每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。\ngoroutine：2KB（官方）\n线程：8MB（参考网络）\n\n线程和 goroutine 切换调度开销方面\n线程/goroutine 切换开销方面，goroutine 远比线程小\n线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。\ngoroutine：只有三个寄存器的值修改 - PC / SP / DX.\n```\n\n\n\n### Go 语言对测试函数的名称和签名都有哪些规定？\n\n```\n对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。\n对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。\n对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。\n```\n\n\n\n### go的性能分析\n\n```\nruntime/pprof；net/http/pprof；runtime/trace；\n$ go tool pprof cpuprofile.out\nType: cpu\nTime: Nov 9, 2018 at 4:31pm (CST)\nDuration: 7.96s, Total samples = 6.88s (86.38%)\nEntering interactive mode (type \"help\" for commands, \"o\" for options)(pprof)\n```\n\n\n\n","source":"_posts/面试/要点整理/go.md","raw":"---\ntitle: 【第一课】golang常考知识点\ndate: 2020-03-19 16:14:00\ntags:\n- golang\ncategories:\n- 面试\n---\n\n\n\n\n\n### 数组和切片的区别\n\n```\n数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。\n我们其实可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。\n```\n\n\n\n### golang中的引用类型\n\n```\n在golang中只有三种引用类型它们分别是切片slice、字典map、管道channel。其它的全部是值类型，引用类型可以简单的理解为指针类型，它们都是通过make完成初始化\n```\n\n\n\n### 进程 线程 和 协程\n\n```\n 进程、线程(内核级线程)、协程(用户级线程)\n\n协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）\n对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。\n\n内存消耗方面\n每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。\ngoroutine：2KB（官方）\n线程：8MB（参考网络）\n\n线程和 goroutine 切换调度开销方面\n线程/goroutine 切换开销方面，goroutine 远比线程小\n线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。\ngoroutine：只有三个寄存器的值修改 - PC / SP / DX.\n```\n\n\n\n### Go 语言对测试函数的名称和签名都有哪些规定？\n\n```\n对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。\n对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。\n对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。\n```\n\n\n\n### go的性能分析\n\n```\nruntime/pprof；net/http/pprof；runtime/trace；\n$ go tool pprof cpuprofile.out\nType: cpu\nTime: Nov 9, 2018 at 4:31pm (CST)\nDuration: 7.96s, Total samples = 6.88s (86.38%)\nEntering interactive mode (type \"help\" for commands, \"o\" for options)(pprof)\n```\n\n\n\n","slug":"面试/要点整理/go","published":1,"updated":"2020-03-23T10:02:52.467Z","_id":"ck845eixh000eny8negvbei6t","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"数组和切片的区别\"><a href=\"#数组和切片的区别\" class=\"headerlink\" title=\"数组和切片的区别\"></a>数组和切片的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。</span><br><span class=\"line\">我们其实可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"golang中的引用类型\"><a href=\"#golang中的引用类型\" class=\"headerlink\" title=\"golang中的引用类型\"></a>golang中的引用类型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在golang中只有三种引用类型它们分别是切片slice、字典map、管道channel。其它的全部是值类型，引用类型可以简单的理解为指针类型，它们都是通过make完成初始化</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"进程-线程-和-协程\"><a href=\"#进程-线程-和-协程\" class=\"headerlink\" title=\"进程 线程 和 协程\"></a>进程 线程 和 协程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 进程、线程(内核级线程)、协程(用户级线程)</span><br><span class=\"line\"></span><br><span class=\"line\">协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</span><br><span class=\"line\">对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）</span><br><span class=\"line\">对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</span><br><span class=\"line\"></span><br><span class=\"line\">内存消耗方面</span><br><span class=\"line\">每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。</span><br><span class=\"line\">goroutine：2KB（官方）</span><br><span class=\"line\">线程：8MB（参考网络）</span><br><span class=\"line\"></span><br><span class=\"line\">线程和 goroutine 切换调度开销方面</span><br><span class=\"line\">线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小</span><br><span class=\"line\">线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。</span><br><span class=\"line\">goroutine：只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Go-语言对测试函数的名称和签名都有哪些规定？\"><a href=\"#Go-语言对测试函数的名称和签名都有哪些规定？\" class=\"headerlink\" title=\"Go 语言对测试函数的名称和签名都有哪些规定？\"></a>Go 语言对测试函数的名称和签名都有哪些规定？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。</span><br><span class=\"line\">对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。</span><br><span class=\"line\">对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"go的性能分析\"><a href=\"#go的性能分析\" class=\"headerlink\" title=\"go的性能分析\"></a>go的性能分析</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runtime&#x2F;pprof；net&#x2F;http&#x2F;pprof；runtime&#x2F;trace；</span><br><span class=\"line\">$ go tool pprof cpuprofile.out</span><br><span class=\"line\">Type: cpu</span><br><span class=\"line\">Time: Nov 9, 2018 at 4:31pm (CST)</span><br><span class=\"line\">Duration: 7.96s, Total samples &#x3D; 6.88s (86.38%)</span><br><span class=\"line\">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof)</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数组和切片的区别\"><a href=\"#数组和切片的区别\" class=\"headerlink\" title=\"数组和切片的区别\"></a>数组和切片的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。</span><br><span class=\"line\">我们其实可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"golang中的引用类型\"><a href=\"#golang中的引用类型\" class=\"headerlink\" title=\"golang中的引用类型\"></a>golang中的引用类型</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在golang中只有三种引用类型它们分别是切片slice、字典map、管道channel。其它的全部是值类型，引用类型可以简单的理解为指针类型，它们都是通过make完成初始化</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"进程-线程-和-协程\"><a href=\"#进程-线程-和-协程\" class=\"headerlink\" title=\"进程 线程 和 协程\"></a>进程 线程 和 协程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 进程、线程(内核级线程)、协程(用户级线程)</span><br><span class=\"line\"></span><br><span class=\"line\">协程是一种用户态的轻量级线程，协程的调度完全由用户控制（进程和线程都是由cpu 内核进行调度）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</span><br><span class=\"line\">对于 进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）</span><br><span class=\"line\">对于 协程(用户级线程)，这是对内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程&#x2F;线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</span><br><span class=\"line\"></span><br><span class=\"line\">内存消耗方面</span><br><span class=\"line\">每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少。</span><br><span class=\"line\">goroutine：2KB（官方）</span><br><span class=\"line\">线程：8MB（参考网络）</span><br><span class=\"line\"></span><br><span class=\"line\">线程和 goroutine 切换调度开销方面</span><br><span class=\"line\">线程&#x2F;goroutine 切换开销方面，goroutine 远比线程小</span><br><span class=\"line\">线程：涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等。</span><br><span class=\"line\">goroutine：只有三个寄存器的值修改 - PC &#x2F; SP &#x2F; DX.</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Go-语言对测试函数的名称和签名都有哪些规定？\"><a href=\"#Go-语言对测试函数的名称和签名都有哪些规定？\" class=\"headerlink\" title=\"Go 语言对测试函数的名称和签名都有哪些规定？\"></a>Go 语言对测试函数的名称和签名都有哪些规定？</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。</span><br><span class=\"line\">对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。</span><br><span class=\"line\">对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"go的性能分析\"><a href=\"#go的性能分析\" class=\"headerlink\" title=\"go的性能分析\"></a>go的性能分析</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runtime&#x2F;pprof；net&#x2F;http&#x2F;pprof；runtime&#x2F;trace；</span><br><span class=\"line\">$ go tool pprof cpuprofile.out</span><br><span class=\"line\">Type: cpu</span><br><span class=\"line\">Time: Nov 9, 2018 at 4:31pm (CST)</span><br><span class=\"line\">Duration: 7.96s, Total samples &#x3D; 6.88s (86.38%)</span><br><span class=\"line\">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)(pprof)</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"【面试复盘】头条面试","date":"2020-03-11T16:00:00.000Z","_content":"\n\n\n### redis 主从同步\n\n\n\n### 判断是否是一个完全二叉树\n\n\n\n### 消息队列 推和拉的优劣\n\n","source":"_posts/面试/复盘/3.12头条面试.md","raw":"---\ntitle: 【面试复盘】头条面试\ndate: 2020-03-12\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n### redis 主从同步\n\n\n\n### 判断是否是一个完全二叉树\n\n\n\n### 消息队列 推和拉的优劣\n\n","slug":"面试/复盘/3.12头条面试","published":1,"updated":"2020-03-17T06:41:01.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck845eixi000hny8ng4gv4z8f","content":"<h3 id=\"redis-主从同步\"><a href=\"#redis-主从同步\" class=\"headerlink\" title=\"redis 主从同步\"></a>redis 主从同步</h3><h3 id=\"判断是否是一个完全二叉树\"><a href=\"#判断是否是一个完全二叉树\" class=\"headerlink\" title=\"判断是否是一个完全二叉树\"></a>判断是否是一个完全二叉树</h3><h3 id=\"消息队列-推和拉的优劣\"><a href=\"#消息队列-推和拉的优劣\" class=\"headerlink\" title=\"消息队列 推和拉的优劣\"></a>消息队列 推和拉的优劣</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"redis-主从同步\"><a href=\"#redis-主从同步\" class=\"headerlink\" title=\"redis 主从同步\"></a>redis 主从同步</h3><h3 id=\"判断是否是一个完全二叉树\"><a href=\"#判断是否是一个完全二叉树\" class=\"headerlink\" title=\"判断是否是一个完全二叉树\"></a>判断是否是一个完全二叉树</h3><h3 id=\"消息队列-推和拉的优劣\"><a href=\"#消息队列-推和拉的优劣\" class=\"headerlink\" title=\"消息队列 推和拉的优劣\"></a>消息队列 推和拉的优劣</h3>"},{"title":"【第一课】系统设计题","date":"2019-11-12T16:00:00.000Z","_content":"\n\n\n### 设计一个红包雨游戏\n\n\n\n### 设计一个唯一id生成器\n\n\n\n### 设计一个支付系统\n\n\n\n### 设计一个微博系统\n\n``` \n设计一个微博系统，用户之间可以互相关注，\n如果 A关注了B，B关注了C\n那么 A间接关注了C且 A与C之间的度为1\n然后系统有一个功能 输入俩用户 输出他俩之间的 度\n\n```\n\n\n\n### 设计一个12306抢购系统\n\n```\n买票\n退票\n同时抢不同区间的票\n压测\n\n\n验证码 \n```\n\n","source":"_posts/面试/要点整理/系统设计题.md","raw":"---\ntitle: 【第一课】系统设计题\ndate: 2019-11-13\ntags:\n- linux\ncategories:\n- 面试\n---\n\n\n\n### 设计一个红包雨游戏\n\n\n\n### 设计一个唯一id生成器\n\n\n\n### 设计一个支付系统\n\n\n\n### 设计一个微博系统\n\n``` \n设计一个微博系统，用户之间可以互相关注，\n如果 A关注了B，B关注了C\n那么 A间接关注了C且 A与C之间的度为1\n然后系统有一个功能 输入俩用户 输出他俩之间的 度\n\n```\n\n\n\n### 设计一个12306抢购系统\n\n```\n买票\n退票\n同时抢不同区间的票\n压测\n\n\n验证码 \n```\n\n","slug":"面试/要点整理/系统设计题","published":1,"updated":"2020-03-18T06:45:36.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck845eixj000kny8nawyp8ch6","content":"<h3 id=\"设计一个红包雨游戏\"><a href=\"#设计一个红包雨游戏\" class=\"headerlink\" title=\"设计一个红包雨游戏\"></a>设计一个红包雨游戏</h3><h3 id=\"设计一个唯一id生成器\"><a href=\"#设计一个唯一id生成器\" class=\"headerlink\" title=\"设计一个唯一id生成器\"></a>设计一个唯一id生成器</h3><h3 id=\"设计一个支付系统\"><a href=\"#设计一个支付系统\" class=\"headerlink\" title=\"设计一个支付系统\"></a>设计一个支付系统</h3><h3 id=\"设计一个微博系统\"><a href=\"#设计一个微博系统\" class=\"headerlink\" title=\"设计一个微博系统\"></a>设计一个微博系统</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设计一个微博系统，用户之间可以互相关注，</span><br><span class=\"line\">如果 A关注了B，B关注了C</span><br><span class=\"line\">那么 A间接关注了C且 A与C之间的度为1</span><br><span class=\"line\">然后系统有一个功能 输入俩用户 输出他俩之间的 度</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"设计一个12306抢购系统\"><a href=\"#设计一个12306抢购系统\" class=\"headerlink\" title=\"设计一个12306抢购系统\"></a>设计一个12306抢购系统</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">买票</span><br><span class=\"line\">退票</span><br><span class=\"line\">同时抢不同区间的票</span><br><span class=\"line\">压测</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">验证码</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"设计一个红包雨游戏\"><a href=\"#设计一个红包雨游戏\" class=\"headerlink\" title=\"设计一个红包雨游戏\"></a>设计一个红包雨游戏</h3><h3 id=\"设计一个唯一id生成器\"><a href=\"#设计一个唯一id生成器\" class=\"headerlink\" title=\"设计一个唯一id生成器\"></a>设计一个唯一id生成器</h3><h3 id=\"设计一个支付系统\"><a href=\"#设计一个支付系统\" class=\"headerlink\" title=\"设计一个支付系统\"></a>设计一个支付系统</h3><h3 id=\"设计一个微博系统\"><a href=\"#设计一个微博系统\" class=\"headerlink\" title=\"设计一个微博系统\"></a>设计一个微博系统</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">设计一个微博系统，用户之间可以互相关注，</span><br><span class=\"line\">如果 A关注了B，B关注了C</span><br><span class=\"line\">那么 A间接关注了C且 A与C之间的度为1</span><br><span class=\"line\">然后系统有一个功能 输入俩用户 输出他俩之间的 度</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"设计一个12306抢购系统\"><a href=\"#设计一个12306抢购系统\" class=\"headerlink\" title=\"设计一个12306抢购系统\"></a>设计一个12306抢购系统</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">买票</span><br><span class=\"line\">退票</span><br><span class=\"line\">同时抢不同区间的票</span><br><span class=\"line\">压测</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">验证码</span><br></pre></td></tr></table></figure>\n\n"},{"title":"【面试复盘】跟谁学面试","date":"2020-03-01T16:00:00.000Z","_content":"\n\n\n## 一面\n\n### grpc和thrift\n\n\n\n### 消息队列\n\n\n\n### golang append 的原理\n\n\n\n### chan的底层\n\n\n\n### 方法interface和变量interface的区别\n\n```\n具有一组方法的类型\ninterface 变量存储的是实现者的值\ninterface 的重要用途就体现在函数 f 的参数中，如果有多种类型实现了某个 interface，这些类型的值都可以直接使用 interface 的变量存储。\ninterface{} 是一个空的 interface 类型，根据前文的定义：一个类型如果实现了一个 interface 的所有方法就说该类型实现了这个 interface，空的 interface 没有方法，所以可以认为所有的类型都实现了 interface{}。如果定义一个函数参数是 interface{} 类型，这个函数应该可以接受任何类型作为它的参数。\n\ngo 可以使用 comma, ok 的形式做区分 value, ok := em.(T)：em 是 interface 类型的变量，T代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T。\n\n```\n\n\n\n### 【算法题】\n\n``` \n// 合并链表\nfunc merge(a, b *ListNode) *ListNode {\n\tvar c *ListNode\n\n\tif a != nil && b != nil {\n\t\tif a.Val > b.Val {\n\t\t\tc, b.Next, b = b, nil, b.Next\n\t\t\tb = b.Next\n\t\t} else {\n\t\t\tc, a.Next, a = a, nil, a.Next\n\t\t\ta = a.Next\n\t\t}\n\t}\n\n\tif a != nil {\n\t\tif c == nil {\n\t\t\treturn a\n\t\t} else {\n\t\t\tc.Next = a\n\t\t}\n\n\t} else if b != nil {\n\t\tif c == nil {\n\t\t\treturn b\n\t\t} else {\n\t\t\tc.Next = b\n\t\t}\n\t}\n\treturn c\n}\n\n```\n\n\n\n## 二面\n\n### 消息队列幂等性\n\n\n\n### http和tcp 和http2.0\n\n\n\n### golang实现支持并发的单例模式\n\n\n\n``` go\nvar exa *example\nvar mu sync.Mutex\nfunc GetInstance() *example {\n  if exa != nil {\n    return exa\n  }\n  mu.Lock()\n  defer mu.Unlock()\n  exa = &example{}\n  return exa\n}\n```\n\n``` go\ntype example struct {\n  name string\n}\nvar instance *example\nvar once Sync.Once\nfunc GetInstance() *example {\n  Once.Do(func(){\n    instance = &example{}\n    instance.name = \"test\"\n  })\n  return instance\n}\n```\n\n\n\n","source":"_posts/面试/复盘/3.2跟谁学面试.md","raw":"---\ntitle: 【面试复盘】跟谁学面试\ndate: 2020-03-2\ntags:\n- 复盘\ncategories:\n- 面试\n---\n\n\n\n## 一面\n\n### grpc和thrift\n\n\n\n### 消息队列\n\n\n\n### golang append 的原理\n\n\n\n### chan的底层\n\n\n\n### 方法interface和变量interface的区别\n\n```\n具有一组方法的类型\ninterface 变量存储的是实现者的值\ninterface 的重要用途就体现在函数 f 的参数中，如果有多种类型实现了某个 interface，这些类型的值都可以直接使用 interface 的变量存储。\ninterface{} 是一个空的 interface 类型，根据前文的定义：一个类型如果实现了一个 interface 的所有方法就说该类型实现了这个 interface，空的 interface 没有方法，所以可以认为所有的类型都实现了 interface{}。如果定义一个函数参数是 interface{} 类型，这个函数应该可以接受任何类型作为它的参数。\n\ngo 可以使用 comma, ok 的形式做区分 value, ok := em.(T)：em 是 interface 类型的变量，T代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T。\n\n```\n\n\n\n### 【算法题】\n\n``` \n// 合并链表\nfunc merge(a, b *ListNode) *ListNode {\n\tvar c *ListNode\n\n\tif a != nil && b != nil {\n\t\tif a.Val > b.Val {\n\t\t\tc, b.Next, b = b, nil, b.Next\n\t\t\tb = b.Next\n\t\t} else {\n\t\t\tc, a.Next, a = a, nil, a.Next\n\t\t\ta = a.Next\n\t\t}\n\t}\n\n\tif a != nil {\n\t\tif c == nil {\n\t\t\treturn a\n\t\t} else {\n\t\t\tc.Next = a\n\t\t}\n\n\t} else if b != nil {\n\t\tif c == nil {\n\t\t\treturn b\n\t\t} else {\n\t\t\tc.Next = b\n\t\t}\n\t}\n\treturn c\n}\n\n```\n\n\n\n## 二面\n\n### 消息队列幂等性\n\n\n\n### http和tcp 和http2.0\n\n\n\n### golang实现支持并发的单例模式\n\n\n\n``` go\nvar exa *example\nvar mu sync.Mutex\nfunc GetInstance() *example {\n  if exa != nil {\n    return exa\n  }\n  mu.Lock()\n  defer mu.Unlock()\n  exa = &example{}\n  return exa\n}\n```\n\n``` go\ntype example struct {\n  name string\n}\nvar instance *example\nvar once Sync.Once\nfunc GetInstance() *example {\n  Once.Do(func(){\n    instance = &example{}\n    instance.name = \"test\"\n  })\n  return instance\n}\n```\n\n\n\n","slug":"面试/复盘/3.2跟谁学面试","published":1,"updated":"2020-03-04T08:57:13.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck845eixk000nny8nh6nu6gwb","content":"<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"grpc和thrift\"><a href=\"#grpc和thrift\" class=\"headerlink\" title=\"grpc和thrift\"></a>grpc和thrift</h3><h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><h3 id=\"golang-append-的原理\"><a href=\"#golang-append-的原理\" class=\"headerlink\" title=\"golang append 的原理\"></a>golang append 的原理</h3><h3 id=\"chan的底层\"><a href=\"#chan的底层\" class=\"headerlink\" title=\"chan的底层\"></a>chan的底层</h3><h3 id=\"方法interface和变量interface的区别\"><a href=\"#方法interface和变量interface的区别\" class=\"headerlink\" title=\"方法interface和变量interface的区别\"></a>方法interface和变量interface的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">具有一组方法的类型</span><br><span class=\"line\">interface 变量存储的是实现者的值</span><br><span class=\"line\">interface 的重要用途就体现在函数 f 的参数中，如果有多种类型实现了某个 interface，这些类型的值都可以直接使用 interface 的变量存储。</span><br><span class=\"line\">interface&#123;&#125; 是一个空的 interface 类型，根据前文的定义：一个类型如果实现了一个 interface 的所有方法就说该类型实现了这个 interface，空的 interface 没有方法，所以可以认为所有的类型都实现了 interface&#123;&#125;。如果定义一个函数参数是 interface&#123;&#125; 类型，这个函数应该可以接受任何类型作为它的参数。</span><br><span class=\"line\"></span><br><span class=\"line\">go 可以使用 comma, ok 的形式做区分 value, ok :&#x3D; em.(T)：em 是 interface 类型的变量，T代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"【算法题】\"><a href=\"#【算法题】\" class=\"headerlink\" title=\"【算法题】\"></a>【算法题】</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 合并链表</span><br><span class=\"line\">func merge(a, b *ListNode) *ListNode &#123;</span><br><span class=\"line\">\tvar c *ListNode</span><br><span class=\"line\"></span><br><span class=\"line\">\tif a !&#x3D; nil &amp;&amp; b !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tif a.Val &gt; b.Val &#123;</span><br><span class=\"line\">\t\t\tc, b.Next, b &#x3D; b, nil, b.Next</span><br><span class=\"line\">\t\t\tb &#x3D; b.Next</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tc, a.Next, a &#x3D; a, nil, a.Next</span><br><span class=\"line\">\t\t\ta &#x3D; a.Next</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif a !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tif c &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn a</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tc.Next &#x3D; a</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; else if b !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tif c &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn b</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tc.Next &#x3D; b</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><h3 id=\"消息队列幂等性\"><a href=\"#消息队列幂等性\" class=\"headerlink\" title=\"消息队列幂等性\"></a>消息队列幂等性</h3><h3 id=\"http和tcp-和http2-0\"><a href=\"#http和tcp-和http2-0\" class=\"headerlink\" title=\"http和tcp 和http2.0\"></a>http和tcp 和http2.0</h3><h3 id=\"golang实现支持并发的单例模式\"><a href=\"#golang实现支持并发的单例模式\" class=\"headerlink\" title=\"golang实现支持并发的单例模式\"></a>golang实现支持并发的单例模式</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> exa *example</span><br><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetInstance</span><span class=\"params\">()</span> *<span class=\"title\">example</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> exa != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exa</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mu.Lock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> mu.Unlock()</span><br><span class=\"line\">  exa = &amp;example&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> exa</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> example <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  name <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance *example</span><br><span class=\"line\"><span class=\"keyword\">var</span> once Sync.Once</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetInstance</span><span class=\"params\">()</span> *<span class=\"title\">example</span></span> &#123;</span><br><span class=\"line\">  Once.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    instance = &amp;example&#123;&#125;</span><br><span class=\"line\">    instance.name = <span class=\"string\">\"test\"</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"grpc和thrift\"><a href=\"#grpc和thrift\" class=\"headerlink\" title=\"grpc和thrift\"></a>grpc和thrift</h3><h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><h3 id=\"golang-append-的原理\"><a href=\"#golang-append-的原理\" class=\"headerlink\" title=\"golang append 的原理\"></a>golang append 的原理</h3><h3 id=\"chan的底层\"><a href=\"#chan的底层\" class=\"headerlink\" title=\"chan的底层\"></a>chan的底层</h3><h3 id=\"方法interface和变量interface的区别\"><a href=\"#方法interface和变量interface的区别\" class=\"headerlink\" title=\"方法interface和变量interface的区别\"></a>方法interface和变量interface的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">具有一组方法的类型</span><br><span class=\"line\">interface 变量存储的是实现者的值</span><br><span class=\"line\">interface 的重要用途就体现在函数 f 的参数中，如果有多种类型实现了某个 interface，这些类型的值都可以直接使用 interface 的变量存储。</span><br><span class=\"line\">interface&#123;&#125; 是一个空的 interface 类型，根据前文的定义：一个类型如果实现了一个 interface 的所有方法就说该类型实现了这个 interface，空的 interface 没有方法，所以可以认为所有的类型都实现了 interface&#123;&#125;。如果定义一个函数参数是 interface&#123;&#125; 类型，这个函数应该可以接受任何类型作为它的参数。</span><br><span class=\"line\"></span><br><span class=\"line\">go 可以使用 comma, ok 的形式做区分 value, ok :&#x3D; em.(T)：em 是 interface 类型的变量，T代表要断言的类型，value 是 interface 变量存储的值，ok 是 bool 类型表示是否为该断言的类型 T。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"【算法题】\"><a href=\"#【算法题】\" class=\"headerlink\" title=\"【算法题】\"></a>【算法题】</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 合并链表</span><br><span class=\"line\">func merge(a, b *ListNode) *ListNode &#123;</span><br><span class=\"line\">\tvar c *ListNode</span><br><span class=\"line\"></span><br><span class=\"line\">\tif a !&#x3D; nil &amp;&amp; b !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tif a.Val &gt; b.Val &#123;</span><br><span class=\"line\">\t\t\tc, b.Next, b &#x3D; b, nil, b.Next</span><br><span class=\"line\">\t\t\tb &#x3D; b.Next</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tc, a.Next, a &#x3D; a, nil, a.Next</span><br><span class=\"line\">\t\t\ta &#x3D; a.Next</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif a !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tif c &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn a</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tc.Next &#x3D; a</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125; else if b !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tif c &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\t\treturn b</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\tc.Next &#x3D; b</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二面\"><a href=\"#二面\" class=\"headerlink\" title=\"二面\"></a>二面</h2><h3 id=\"消息队列幂等性\"><a href=\"#消息队列幂等性\" class=\"headerlink\" title=\"消息队列幂等性\"></a>消息队列幂等性</h3><h3 id=\"http和tcp-和http2-0\"><a href=\"#http和tcp-和http2-0\" class=\"headerlink\" title=\"http和tcp 和http2.0\"></a>http和tcp 和http2.0</h3><h3 id=\"golang实现支持并发的单例模式\"><a href=\"#golang实现支持并发的单例模式\" class=\"headerlink\" title=\"golang实现支持并发的单例模式\"></a>golang实现支持并发的单例模式</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> exa *example</span><br><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetInstance</span><span class=\"params\">()</span> *<span class=\"title\">example</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> exa != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exa</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mu.Lock()</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> mu.Unlock()</span><br><span class=\"line\">  exa = &amp;example&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> exa</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> example <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  name <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> instance *example</span><br><span class=\"line\"><span class=\"keyword\">var</span> once Sync.Once</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetInstance</span><span class=\"params\">()</span> *<span class=\"title\">example</span></span> &#123;</span><br><span class=\"line\">  Once.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    instance = &amp;example&#123;&#125;</span><br><span class=\"line\">    instance.name = <span class=\"string\">\"test\"</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"【第一课】消息队列","date":"2020-03-17T08:14:00.000Z","_content":"\n\n\n### 消息队列的使用场景 \n\n``` \n1. 解耦\n2. 异步\n3. 削峰\n```\n\n\n\n### 怎么保证消息不会丢失\n\n```\n保证消息的幂等性\n```\n\n\n\n### 推和拉模式分别有什么优势和劣势\n\n``` \nPush方式：\n优点：有消息就推给消费者。延迟小,几乎可以做到实时。等等。。。。\n\n缺点：Server端接收到消息后，主动把消息推送给Client端，实时性高。对于一个提供队列服务的Server来说，用Push方式主动推送有很多弊端；首先是加大Server端的工作量，进而影响Server的性能，其次Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题。\n\n菠萝科技注：意思是1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点。\n\nPull方式：\n优点：对比push优点就是消费者可以根据自己能力拉取消息处理。。。\n\n缺点：Client端循环地从Server端拉取消息，主动权在Client手里，自己拉取到一定量消息后，处理妥当了再接着取。Pull方式的问题是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。\n\n菠萝科技注：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull。\n```\n\n\n\n### 设计一个消息队列\n\n``` \n1.Producer(消息生产者)：发送消息到Broker。\n2.Broker(服务端)：Broker这个概念主要来自于Apache的ActiveMQ，特指消息队列的服务端。主要功能就是：把消息从发送端传送到接收端，这里会涉及到消息的存储、消息通讯机制等。\n3.Consumer(消息消费者)：从消息队列接收消息，consumer回复消费确认。\n```\n\n```\n为了实现上述消息队列的基础功能：\n1）消息的传输\n2）存储\n3）消费\n\n就需要涉及到如下三个方面的设计：\n1）通信协议 统一格式\n2）存储选择 速度来看，文件系统>分布式KV（持久化）>分布式文件系统>数据库，而可靠性却截然相反。\n3）消费关系维护 单播，就是点到点；而广播，是一点对多点。\n\n消息的顺序\n投递可靠性保证\n消息持久化\n支持不同消息模型\n多实例集群功能\n事务特性等\n```\n\n### rabbit MQ \n\n```\n由Erlang语言开发，继承其天生的并发性，稳定性和安全性有保障\n协议： AMQP（Advanced Message Queuing Protocol）高级消息队列协议，是一个异步消息传递所使用应用层协议规范，\n\nServer : 又称Broker, 接受客户端连接, 实现AMQP实体服务\nConnection : 连接, 应用程序与Broker的网络连接\nChannel : 网络信道, 几乎所有的操作都在Channel中进行, Channel是进行消息读写的通道。客户端可以建立多个Channel, 每个Channel代表一个会话任务。\nMessage : 消息, 服务器和应用程序之间传送的数据, 有Properties和Body组成。Properties可以对消息进行修饰, 比如消息的优先级, 延迟等高级特性; Body就是消息体内容。\nVirtual Host : 虚拟地址, 用于进行逻辑隔离, 最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue, 同一个Virtual Host里面不能有相同名称的Exchange或Queue\nExchange : 交换机, 用于接收消息, 根据路由键转发消息到绑定的队列\nBinding : Exchange和Queue之间的虚拟连接, binding中可以包含routing key\nRouting Key : 一个路由规则, 虚拟机可用它来确定如何路由一个特定消息\nQueue : 也成Message Queue, 消息队列, 用于保存消息并将它们转发给消费者\n\n消息的可靠性传递或回退\n重试机制和幂等性保障\n自动确认与手动确认\nRabbitMQ提供了一种qos(服务质量保证)功能, 即在非自动确认消息的前提下, 如果一定数目的消息(通过consumer或者channel设置qos的值)未被确认前, 不进行消费新的消息\n\n\n消息落库, 对消息状态进行标记\n消息的延迟投递, 做二次确认, 回调检查\n\nstep1:消息入库\nstep2:消息发送\nstep3:消费端消息确认\nstep4:更新库中消息状态为已确认\nstep5:定时任务读取数据库中未确认的消息\nstep6:未收到确认结果的消息重新发送\nstep7:如果重试几次之后仍然失败, 则将消息状态更改为投递失败的终态, 后面需要人工介入\n\n```\n\n","source":"_posts/面试/要点整理/消息队列.md","raw":"---\ntitle: 【第一课】消息队列\ndate: 2020-03-17 16:14:00\ntags:\n- 数据库\n- MYSQL\ncategories:\n- 面试\n---\n\n\n\n### 消息队列的使用场景 \n\n``` \n1. 解耦\n2. 异步\n3. 削峰\n```\n\n\n\n### 怎么保证消息不会丢失\n\n```\n保证消息的幂等性\n```\n\n\n\n### 推和拉模式分别有什么优势和劣势\n\n``` \nPush方式：\n优点：有消息就推给消费者。延迟小,几乎可以做到实时。等等。。。。\n\n缺点：Server端接收到消息后，主动把消息推送给Client端，实时性高。对于一个提供队列服务的Server来说，用Push方式主动推送有很多弊端；首先是加大Server端的工作量，进而影响Server的性能，其次Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题。\n\n菠萝科技注：意思是1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点。\n\nPull方式：\n优点：对比push优点就是消费者可以根据自己能力拉取消息处理。。。\n\n缺点：Client端循环地从Server端拉取消息，主动权在Client手里，自己拉取到一定量消息后，处理妥当了再接着取。Pull方式的问题是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。\n\n菠萝科技注：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull。\n```\n\n\n\n### 设计一个消息队列\n\n``` \n1.Producer(消息生产者)：发送消息到Broker。\n2.Broker(服务端)：Broker这个概念主要来自于Apache的ActiveMQ，特指消息队列的服务端。主要功能就是：把消息从发送端传送到接收端，这里会涉及到消息的存储、消息通讯机制等。\n3.Consumer(消息消费者)：从消息队列接收消息，consumer回复消费确认。\n```\n\n```\n为了实现上述消息队列的基础功能：\n1）消息的传输\n2）存储\n3）消费\n\n就需要涉及到如下三个方面的设计：\n1）通信协议 统一格式\n2）存储选择 速度来看，文件系统>分布式KV（持久化）>分布式文件系统>数据库，而可靠性却截然相反。\n3）消费关系维护 单播，就是点到点；而广播，是一点对多点。\n\n消息的顺序\n投递可靠性保证\n消息持久化\n支持不同消息模型\n多实例集群功能\n事务特性等\n```\n\n### rabbit MQ \n\n```\n由Erlang语言开发，继承其天生的并发性，稳定性和安全性有保障\n协议： AMQP（Advanced Message Queuing Protocol）高级消息队列协议，是一个异步消息传递所使用应用层协议规范，\n\nServer : 又称Broker, 接受客户端连接, 实现AMQP实体服务\nConnection : 连接, 应用程序与Broker的网络连接\nChannel : 网络信道, 几乎所有的操作都在Channel中进行, Channel是进行消息读写的通道。客户端可以建立多个Channel, 每个Channel代表一个会话任务。\nMessage : 消息, 服务器和应用程序之间传送的数据, 有Properties和Body组成。Properties可以对消息进行修饰, 比如消息的优先级, 延迟等高级特性; Body就是消息体内容。\nVirtual Host : 虚拟地址, 用于进行逻辑隔离, 最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue, 同一个Virtual Host里面不能有相同名称的Exchange或Queue\nExchange : 交换机, 用于接收消息, 根据路由键转发消息到绑定的队列\nBinding : Exchange和Queue之间的虚拟连接, binding中可以包含routing key\nRouting Key : 一个路由规则, 虚拟机可用它来确定如何路由一个特定消息\nQueue : 也成Message Queue, 消息队列, 用于保存消息并将它们转发给消费者\n\n消息的可靠性传递或回退\n重试机制和幂等性保障\n自动确认与手动确认\nRabbitMQ提供了一种qos(服务质量保证)功能, 即在非自动确认消息的前提下, 如果一定数目的消息(通过consumer或者channel设置qos的值)未被确认前, 不进行消费新的消息\n\n\n消息落库, 对消息状态进行标记\n消息的延迟投递, 做二次确认, 回调检查\n\nstep1:消息入库\nstep2:消息发送\nstep3:消费端消息确认\nstep4:更新库中消息状态为已确认\nstep5:定时任务读取数据库中未确认的消息\nstep6:未收到确认结果的消息重新发送\nstep7:如果重试几次之后仍然失败, 则将消息状态更改为投递失败的终态, 后面需要人工介入\n\n```\n\n","slug":"面试/要点整理/消息队列","published":1,"updated":"2020-03-18T05:55:35.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck845eixl000qny8n0d6ld6j7","content":"<h3 id=\"消息队列的使用场景\"><a href=\"#消息队列的使用场景\" class=\"headerlink\" title=\"消息队列的使用场景\"></a>消息队列的使用场景</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 解耦</span><br><span class=\"line\">2. 异步</span><br><span class=\"line\">3. 削峰</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"怎么保证消息不会丢失\"><a href=\"#怎么保证消息不会丢失\" class=\"headerlink\" title=\"怎么保证消息不会丢失\"></a>怎么保证消息不会丢失</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">保证消息的幂等性</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"推和拉模式分别有什么优势和劣势\"><a href=\"#推和拉模式分别有什么优势和劣势\" class=\"headerlink\" title=\"推和拉模式分别有什么优势和劣势\"></a>推和拉模式分别有什么优势和劣势</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Push方式：</span><br><span class=\"line\">优点：有消息就推给消费者。延迟小,几乎可以做到实时。等等。。。。</span><br><span class=\"line\"></span><br><span class=\"line\">缺点：Server端接收到消息后，主动把消息推送给Client端，实时性高。对于一个提供队列服务的Server来说，用Push方式主动推送有很多弊端；首先是加大Server端的工作量，进而影响Server的性能，其次Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题。</span><br><span class=\"line\"></span><br><span class=\"line\">菠萝科技注：意思是1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点。</span><br><span class=\"line\"></span><br><span class=\"line\">Pull方式：</span><br><span class=\"line\">优点：对比push优点就是消费者可以根据自己能力拉取消息处理。。。</span><br><span class=\"line\"></span><br><span class=\"line\">缺点：Client端循环地从Server端拉取消息，主动权在Client手里，自己拉取到一定量消息后，处理妥当了再接着取。Pull方式的问题是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。</span><br><span class=\"line\"></span><br><span class=\"line\">菠萝科技注：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"设计一个消息队列\"><a href=\"#设计一个消息队列\" class=\"headerlink\" title=\"设计一个消息队列\"></a>设计一个消息队列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.Producer(消息生产者)：发送消息到Broker。</span><br><span class=\"line\">2.Broker(服务端)：Broker这个概念主要来自于Apache的ActiveMQ，特指消息队列的服务端。主要功能就是：把消息从发送端传送到接收端，这里会涉及到消息的存储、消息通讯机制等。</span><br><span class=\"line\">3.Consumer(消息消费者)：从消息队列接收消息，consumer回复消费确认。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了实现上述消息队列的基础功能：</span><br><span class=\"line\">1）消息的传输</span><br><span class=\"line\">2）存储</span><br><span class=\"line\">3）消费</span><br><span class=\"line\"></span><br><span class=\"line\">就需要涉及到如下三个方面的设计：</span><br><span class=\"line\">1）通信协议 统一格式</span><br><span class=\"line\">2）存储选择 速度来看，文件系统&gt;分布式KV（持久化）&gt;分布式文件系统&gt;数据库，而可靠性却截然相反。</span><br><span class=\"line\">3）消费关系维护 单播，就是点到点；而广播，是一点对多点。</span><br><span class=\"line\"></span><br><span class=\"line\">消息的顺序</span><br><span class=\"line\">投递可靠性保证</span><br><span class=\"line\">消息持久化</span><br><span class=\"line\">支持不同消息模型</span><br><span class=\"line\">多实例集群功能</span><br><span class=\"line\">事务特性等</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rabbit-MQ\"><a href=\"#rabbit-MQ\" class=\"headerlink\" title=\"rabbit MQ\"></a>rabbit MQ</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由Erlang语言开发，继承其天生的并发性，稳定性和安全性有保障</span><br><span class=\"line\">协议： AMQP（Advanced Message Queuing Protocol）高级消息队列协议，是一个异步消息传递所使用应用层协议规范，</span><br><span class=\"line\"></span><br><span class=\"line\">Server : 又称Broker, 接受客户端连接, 实现AMQP实体服务</span><br><span class=\"line\">Connection : 连接, 应用程序与Broker的网络连接</span><br><span class=\"line\">Channel : 网络信道, 几乎所有的操作都在Channel中进行, Channel是进行消息读写的通道。客户端可以建立多个Channel, 每个Channel代表一个会话任务。</span><br><span class=\"line\">Message : 消息, 服务器和应用程序之间传送的数据, 有Properties和Body组成。Properties可以对消息进行修饰, 比如消息的优先级, 延迟等高级特性; Body就是消息体内容。</span><br><span class=\"line\">Virtual Host : 虚拟地址, 用于进行逻辑隔离, 最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue, 同一个Virtual Host里面不能有相同名称的Exchange或Queue</span><br><span class=\"line\">Exchange : 交换机, 用于接收消息, 根据路由键转发消息到绑定的队列</span><br><span class=\"line\">Binding : Exchange和Queue之间的虚拟连接, binding中可以包含routing key</span><br><span class=\"line\">Routing Key : 一个路由规则, 虚拟机可用它来确定如何路由一个特定消息</span><br><span class=\"line\">Queue : 也成Message Queue, 消息队列, 用于保存消息并将它们转发给消费者</span><br><span class=\"line\"></span><br><span class=\"line\">消息的可靠性传递或回退</span><br><span class=\"line\">重试机制和幂等性保障</span><br><span class=\"line\">自动确认与手动确认</span><br><span class=\"line\">RabbitMQ提供了一种qos(服务质量保证)功能, 即在非自动确认消息的前提下, 如果一定数目的消息(通过consumer或者channel设置qos的值)未被确认前, 不进行消费新的消息</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">消息落库, 对消息状态进行标记</span><br><span class=\"line\">消息的延迟投递, 做二次确认, 回调检查</span><br><span class=\"line\"></span><br><span class=\"line\">step1:消息入库</span><br><span class=\"line\">step2:消息发送</span><br><span class=\"line\">step3:消费端消息确认</span><br><span class=\"line\">step4:更新库中消息状态为已确认</span><br><span class=\"line\">step5:定时任务读取数据库中未确认的消息</span><br><span class=\"line\">step6:未收到确认结果的消息重新发送</span><br><span class=\"line\">step7:如果重试几次之后仍然失败, 则将消息状态更改为投递失败的终态, 后面需要人工介入</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"消息队列的使用场景\"><a href=\"#消息队列的使用场景\" class=\"headerlink\" title=\"消息队列的使用场景\"></a>消息队列的使用场景</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 解耦</span><br><span class=\"line\">2. 异步</span><br><span class=\"line\">3. 削峰</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"怎么保证消息不会丢失\"><a href=\"#怎么保证消息不会丢失\" class=\"headerlink\" title=\"怎么保证消息不会丢失\"></a>怎么保证消息不会丢失</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">保证消息的幂等性</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"推和拉模式分别有什么优势和劣势\"><a href=\"#推和拉模式分别有什么优势和劣势\" class=\"headerlink\" title=\"推和拉模式分别有什么优势和劣势\"></a>推和拉模式分别有什么优势和劣势</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Push方式：</span><br><span class=\"line\">优点：有消息就推给消费者。延迟小,几乎可以做到实时。等等。。。。</span><br><span class=\"line\"></span><br><span class=\"line\">缺点：Server端接收到消息后，主动把消息推送给Client端，实时性高。对于一个提供队列服务的Server来说，用Push方式主动推送有很多弊端；首先是加大Server端的工作量，进而影响Server的性能，其次Client的处理能力各不相同，Client的状态不受Server控制，如果Client不能及时处理Server推送过来的消息，会造成各种潜在问题。</span><br><span class=\"line\"></span><br><span class=\"line\">菠萝科技注：意思是1 加大server(broker)工作量,影响性能。2 有的消费者机器配置好处理能力强,有的配置低处理能力低,但是server推相同数量级消息给消费者，就会导致消费者强的等待,弱的处理效率跟不上,从而导致崩溃。3server资源相比消费者的资源肯定是更宝贵  4总结下就是客户端慢消费(设计到io等耗时操作)时会放大缺点。</span><br><span class=\"line\"></span><br><span class=\"line\">Pull方式：</span><br><span class=\"line\">优点：对比push优点就是消费者可以根据自己能力拉取消息处理。。。</span><br><span class=\"line\"></span><br><span class=\"line\">缺点：Client端循环地从Server端拉取消息，主动权在Client手里，自己拉取到一定量消息后，处理妥当了再接着取。Pull方式的问题是循环拉取消息的间隔不好设定，间隔太短就处在一个“忙等”的状态，浪费资源；每个Pull的时间间隔太长，Server端有消息到来有可能没有被及时处理。</span><br><span class=\"line\"></span><br><span class=\"line\">菠萝科技注：假如处理完消息后，现在空闲，设定多久去server再拉消息？主要问题就是消息处理延迟忙等。server没消息时,但是消费者因为是定时去pull，导致空pull。</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"设计一个消息队列\"><a href=\"#设计一个消息队列\" class=\"headerlink\" title=\"设计一个消息队列\"></a>设计一个消息队列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.Producer(消息生产者)：发送消息到Broker。</span><br><span class=\"line\">2.Broker(服务端)：Broker这个概念主要来自于Apache的ActiveMQ，特指消息队列的服务端。主要功能就是：把消息从发送端传送到接收端，这里会涉及到消息的存储、消息通讯机制等。</span><br><span class=\"line\">3.Consumer(消息消费者)：从消息队列接收消息，consumer回复消费确认。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了实现上述消息队列的基础功能：</span><br><span class=\"line\">1）消息的传输</span><br><span class=\"line\">2）存储</span><br><span class=\"line\">3）消费</span><br><span class=\"line\"></span><br><span class=\"line\">就需要涉及到如下三个方面的设计：</span><br><span class=\"line\">1）通信协议 统一格式</span><br><span class=\"line\">2）存储选择 速度来看，文件系统&gt;分布式KV（持久化）&gt;分布式文件系统&gt;数据库，而可靠性却截然相反。</span><br><span class=\"line\">3）消费关系维护 单播，就是点到点；而广播，是一点对多点。</span><br><span class=\"line\"></span><br><span class=\"line\">消息的顺序</span><br><span class=\"line\">投递可靠性保证</span><br><span class=\"line\">消息持久化</span><br><span class=\"line\">支持不同消息模型</span><br><span class=\"line\">多实例集群功能</span><br><span class=\"line\">事务特性等</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rabbit-MQ\"><a href=\"#rabbit-MQ\" class=\"headerlink\" title=\"rabbit MQ\"></a>rabbit MQ</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由Erlang语言开发，继承其天生的并发性，稳定性和安全性有保障</span><br><span class=\"line\">协议： AMQP（Advanced Message Queuing Protocol）高级消息队列协议，是一个异步消息传递所使用应用层协议规范，</span><br><span class=\"line\"></span><br><span class=\"line\">Server : 又称Broker, 接受客户端连接, 实现AMQP实体服务</span><br><span class=\"line\">Connection : 连接, 应用程序与Broker的网络连接</span><br><span class=\"line\">Channel : 网络信道, 几乎所有的操作都在Channel中进行, Channel是进行消息读写的通道。客户端可以建立多个Channel, 每个Channel代表一个会话任务。</span><br><span class=\"line\">Message : 消息, 服务器和应用程序之间传送的数据, 有Properties和Body组成。Properties可以对消息进行修饰, 比如消息的优先级, 延迟等高级特性; Body就是消息体内容。</span><br><span class=\"line\">Virtual Host : 虚拟地址, 用于进行逻辑隔离, 最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue, 同一个Virtual Host里面不能有相同名称的Exchange或Queue</span><br><span class=\"line\">Exchange : 交换机, 用于接收消息, 根据路由键转发消息到绑定的队列</span><br><span class=\"line\">Binding : Exchange和Queue之间的虚拟连接, binding中可以包含routing key</span><br><span class=\"line\">Routing Key : 一个路由规则, 虚拟机可用它来确定如何路由一个特定消息</span><br><span class=\"line\">Queue : 也成Message Queue, 消息队列, 用于保存消息并将它们转发给消费者</span><br><span class=\"line\"></span><br><span class=\"line\">消息的可靠性传递或回退</span><br><span class=\"line\">重试机制和幂等性保障</span><br><span class=\"line\">自动确认与手动确认</span><br><span class=\"line\">RabbitMQ提供了一种qos(服务质量保证)功能, 即在非自动确认消息的前提下, 如果一定数目的消息(通过consumer或者channel设置qos的值)未被确认前, 不进行消费新的消息</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">消息落库, 对消息状态进行标记</span><br><span class=\"line\">消息的延迟投递, 做二次确认, 回调检查</span><br><span class=\"line\"></span><br><span class=\"line\">step1:消息入库</span><br><span class=\"line\">step2:消息发送</span><br><span class=\"line\">step3:消费端消息确认</span><br><span class=\"line\">step4:更新库中消息状态为已确认</span><br><span class=\"line\">step5:定时任务读取数据库中未确认的消息</span><br><span class=\"line\">step6:未收到确认结果的消息重新发送</span><br><span class=\"line\">step7:如果重试几次之后仍然失败, 则将消息状态更改为投递失败的终态, 后面需要人工介入</span><br></pre></td></tr></table></figure>\n\n"},{"title":"go语言规范","date":"2019-02-19T16:00:00.000Z","_content":"\n## [1. 系统知识](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#1-系统知识)\n\n系统知识主要用于评判候选人是否为资深软件工程师\n\n<!-- more -->\n\n### [1.1 网络](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#11-网络)\n\n考察对象: 工作三年以上\n\n##### [1.1.1 网络七层模型](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#111-网络七层模型)\n\n又称OSI 模型，从下到上分别为：\n\n- 物理层：底层数据传输，如网线；网卡标准。\n- 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。\n- 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。\n- 传输层：端到端传输数据的基本功能；如 TCP、UDP。\n- 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。\n- 标识层：数据格式标识，基本压缩加密功能。\n- 应用层：各种应用软件，包括 Web 应用。\n\n##### [1.1.2 网络四层模型](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#112-网络四层模型)\n\n从下到上分别为：\n\n- 网络访问层：ARP、RARP等协议\n- 互联网层：ICMP、IP等协议\n- 传输层：TCP、UDP等协议\n- 应用层：DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS等协议\n\n##### [1.1.3 TCP、UDP、IP 协议](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#113-tcpudpip-协议)\n\n- TCP与UDP的区别\n  1. TCP属于有状态的可靠连接，通过ack、拆包组包机制保障数据按照顺序传递，一旦建立好连接，路由路线是固定的；UDP本身是无状态的不可靠连接，没有固定的路由路线，优先选择速度快的路由路线，顺序靠应用程序自己保障。\n  2. TCP是基于数据流的，对应用层来说没有固定包大小，在TCP内部会发生拆包组包；UDP是基于数据包的，对应用程序来说有固定大小，UDP内部不会发生拆包组包。但不管是TCP还是UDP，在IP层都有可能发生拆包组包。\n- TCP粘包问题\n  1. 发送端需要等缓冲区满才发送出去，造成粘包（nalge算法也可能造成粘包现象），可以通过设置socket为 nodelay解决。\n  2. 接收方不及时接收缓冲区的包，造成多个包接收。应用程序对每个数据包添加包头来区分数据界限解决。\n- TCP拆包问题\n  1. 发送的TCP报文大于TCP发送缓冲区剩余空间大小。\n  2. 缓冲区中待发送的数据大小大于MSS（最大报文长度） 拆包问题，可以通过压缩数据得到改善。\n- TCP快速重传、快速恢复、慢启动、滑动窗口\n  1. TCP使用滑动窗口机制进行拥塞控制，避免网络质量变差时ACK时间过长导致丢包以及网络质量变好时频繁的ACK导致网络速度无法提升。\n  2. 所谓的慢启动是指滑动窗口的调整是缓慢的调整，即使是网络质量很好的情况下，滑动窗口调整到合适大小也是需要一定时间。\n  3. 快速重传：接收方接收到无序的包时，会立即发送ACK给发送方请求重传缺失的包，如果发送方连续收到3个或者3个以上的重传ACK，那么就判定丢包了，立即重传丢失的包。\n  4. 快速恢复：丢包意味着网络环境变差，默认情况下TCP会恢复到慢启动来进行重传。快速恢复算法在收到3个重传ACK的时候判定网络环境质量并不差，决定不恢复到慢启动，直接重传丢失的包。\n- IP层拆包组包 当报文超过MTU（最大传输单元）大小时，将发生IP层的拆包组包。MTU由路由协商决定，取路由两端以太网帧大小中较小的值。\n\n##### [1.1.4 TCP端口快速回收与重用](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#114-tcp端口快速回收与重用)\n\n由于http协议是短连接，请求完毕后会关闭连接，导致服务器频繁的建立、断开连接，而TCP的回收是有等待时间的，在高并发的http服务器上，我们需要对TCP连接进行调优。否则，容易出现大量time_wait状态的连接占用大量资源。\n\n```\n# 开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭\nnet.ipv4.tcp_syncookies = 1\n# 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭\nnet.ipv4.tcp_tw_reuse = 1\n# 开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。\nnet.ipv4.tcp_tw_recycle = 1\n# 修改系統默认的TIMEOUT时间\nnet.ipv4.tcp_fin_timeout = 30\nnet.ipv4.tcp_timestamps = 1\n```\n\n服务端程序监听端口的socket也可能会遇到回收慢的问题。服务因意外挂掉没及时关闭socket，导致重启时无法监听端口。可以在代码里设置socket的reuse参数\n\n### [1.2 系统调用与函数调用](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#12-系统调用与函数调用)\n\n考察对象: 工作三年以上 附加考察点：应用程序地址空间的划分\n\n应用程序地址空间的最高1G的内存空间是内核态内存空间，其余的属于用户态内存空间。内核态内存空间主要用于系统调用时在内核态保存数据。\n\n##### [1.2.1 系统调用](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#121-系统调用)\n\n系统调用是指通过软中断调用系统内核函数的过程。\n\n- 应用程序调用C函数库中的函数（GO例外，GO自己封装了系统库函数）\n- C函数库中触发软中断 INT 0x80，把系统调用号放入 %eax 寄存器\n- 保存应用程序上下文到应用程序栈内存，主要是保存各种寄存器的值，其中最重要的是程序计数器（PC）和栈指针寄存器（SP）\n- 陷入内核态\n- 调用`copy_from_user`将参数从用户态内存复制到内核态内存\n- 调用内核函数\n- 调用`copy_to_user`将返回值从内核态内存复制到用户态内存\n- 返回用户态\n- 恢复应用程序上下文，并将PC所指内存地址的指令加载到指令寄存器（IP）\n- 继续执行应用程序\n\n##### [1.2.2 函数调用](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#122-函数调用)\n\n函数调用是指给定特定参数调用函数功能并获取返回结果的过程。\n\n- 保存函数参数到函数栈帧\n- 保存函数调用完成后执行的下一条指令的地址到栈帧\n- 跳转到函数地址\n- 执行函数体\n- 将返回值保存到栈帧\n- 从栈帧加载下一条指令地址\n- 执行下一条指令\n\n##### [1.2.3 系统调用与函数调用的区别](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#123-系统调用与函数调用的区别)\n\n- 函数调用不需要触发软中断\n- 函数调用不需要执行上下文切换\n- 系统调用是调用系统内核函数，函数调用是调用应用程序的函数\n\n### [1.3 并发与并行](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#13-并发与并行)\n\n并发：某一时间段内处理多个任务的能力。 并行：某一时间点处理多个任务的能力。\n\n##### [1.3.1 并发](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#131-并发)\n\n并发强调的是单个处理单元在单位时间内处理任务的能力。常见的并发场景有：\n\n- 单个CPU核单位时间内执行的任务（线程）数。如通过top查看到的load avrage在一定程度上反馈了CPU的并发数\n- 单个服务器单位时间内处理的请求数。如QPS这一指标一定程度上衡量了一台服务器的处理能力。\n\n#### [1.3.2 并行](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#132-并行)\n\n并行强调的是整个系统某一时间点同时处理任务的能力。常见的并行场景有：\n\n- CPU的指令流水线同时处理的指令数。如三级流水线表示整个流水线能同时处理三条指令：取指（加载指令）、预处理、执行。\n- CORE I7 处理器4核8线程，能同时让8个线程在上面工作。\n- 一个拥有10个节点的集群，能同时处理至少10个网络请求。\n\n#### [1.3.3 多线程同步](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#133-多线程同步)\n\n原因：CPU内核有缓存，现代多核CPU缓存中寄存器、L1缓存是独占的，L2、L3缓存是多核共享。多线程不同步的原因本质上是CPU核之间缓存不同步、CPU缓存与内存不同步。 解决方案：1、加锁，强制同步CPU核之间的缓存，适合复杂数据类型。2、volatile关键字，禁止寄存器优化，适合简单数据类型（如整数），但只能降低概率，并不能保证原子性。3、原子操作，CPU利用内存屏障，在CPU对内容进行“读-修改-写”这一连续操作时，锁定内存总线，屏蔽其他的读写操作。内存屏障分为读屏障（load barrier）、写屏障（store barrier）、全屏障（full barrier）。读屏障是加在指令前强制让CPU缓存失效，直接从内存读取；写屏障是加在指令后强制将CPU缓存中的数据写入到内存。\n\n## [2. 架构能力](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#2-架构能力)\n\n考察对象：工作五年以上 架构能力考察候选人软件架构方面的知识和能力。\n\n### [2.1 分布式与集群](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#21-分布式与集群)\n\n集群：多个处理相同任务的节点组成集群。 分布式：多个处理不同子任务的节点组成分布式系统。 分布式系统中往往涉及关键数据的同步，需要用到分布式锁。\n\n##### [2.1.1 分布式锁](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#211-分布式锁)\n\n分布式锁基本理论：CAP、悲观锁、乐观锁（CAS） CAP：任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。 CAS： compare and swap，比较并交换。在修改正式数据之前，先会把现有数据版本与修改前的数据版本比较：如果相等则执行修改操作；如果不相等则需要重新获取数据和版本并提交CAS请求。 悲观锁：假设所有操作都可能会修改数据，默认执行加锁操作，直到等待锁释放后才能加锁成功。相当于互斥锁。 乐观锁：假设所有操作中读操作远比写操作多，在修改数据之前检查条件，条件符合则执行修改操作，条件不符合则返回失败。\n\n常用的分布式锁主要有以下几种\n\n- 基于redis、memcached等缓存实现 redis的悲观锁： 加锁\n\n  ```\n  setnx test 1\n  ```\n\n  ，如果test已经存在，则返回0表示加锁失败。解锁\n\n  ```\n  del test\n  ```\n\n   redis的乐观锁：\n\n  ```\n  watch\n  multi\n  set test 1\n  get test\n  exec\n  unwatch\n  ```\n\n  判断get test的返回值是否为 set 的值来判断是否加锁成功\n\n- 基于zookeeper、etcd等集群管理软件实现 etcd 的悲观锁：\n\n  ```\n  1. 创建一个key\n  2. 如果key不存在返回成功并执行第 5 步\n  3. 如果key存在则返回失败，需要watch这个key等待key被删除\n  4. 如果key被删除则重试第 1 步\n  5. 执行需要的操作\n  ```\n\n  etcd 的乐观锁：\n\n  ```\n  1. 读取数据以及数据的版本号 ModifiedIndex\n  2. 修改数据时用ModifiedIndex作为数据的比较条件\n  3. 如果ModifiedIndex与现有数据的相同，则修改成功；否则修改失败，重试第 1 步\n  ```\n\n  etcd v3 已经提供了lock和unlock的接口\n\n- 基于mysql等数据库实现 悲观锁：\n\n  ```\n  SELECT * FROM methodLock WHERE method_name=xxx FOR UPDATE\n  UPDATE tb_stock SET number=number-1\n  ```\n\n  乐观锁：\n\n  ```\n  update tb_stock set number=number-1 where product_id=xxx\n  ```\n\n### [2.2 微服务](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#22-微服务)\n\n- SOA：服务注册与发现、配置管理 ETCD、zookeeper的用法\n- RPC：微服务调用 thrift、protobuf、grpc的原理和用法\n- MQ：异步调用、日志收集 rabbitmq、kafka的架构和用法\n- 容器：服务调度和治理 docker、kubernetes的原理和用法\n\n## [3. 编程语言](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#3-编程语言)\n\n### [3.1 PHP](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#31-php)\n\n### [3.2 Golang](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#32-golang)\n\n考察点：\n\n- go调度器模型\n- channel的各种用法\n- goroutine的各种用法\n- interface的各种用法\n- sync包的用法\n- time包定时器的用法\n- context包用法和实现原理\n\n##### [3.2.1 Golang的调度器模型](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#321-golang的调度器模型)\n\n用这个知识点来初步判断候选人是否真的对golang感兴趣并了解过golang\n\n##### [3.2.2 channel](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#322-channel)\n\n**种类**\n\n- nil 值为nil的channel，读写都会block。主要用于select的时候将close掉的channel置为nil，防止触发相应case。\n- 无缓冲 读写都会block，读操作在写操作之前完成。一般用于同步通知。\n\n```\nch := make(chan struct{})\ngo func(){\n\t//do something\n    close(ch)\n}()\n//wait goroutine finish\n<- ch\n//do something\n```\n\n- 单缓冲 无数据时，读操作block；有数据时，写操作block。用于保证数据有序传递并且限制接收端的最大速度。\n- 多缓冲 只要缓冲区有数据，读操作不会被block；即使有数据，只要缓冲区有空间，写操作不会被block。可以保证数据有序传递，但无法限制接收端的最大速度，只能限制接收端的平均速度。\n\n##### [3.2.3 goroutine](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#323-goroutine)\n\n## [4. 数据库](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#4-数据库)\n\n### [4.1 关联查询](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#41-关联查询)\n\n- 内联结：将两个表中存在联结关系的字段符合联结关系的那些记录形成记录集的联结。\n\n```\nSELECT A.Name B.Hobby FROM A, B WHERE A.id = B.id\n或者\nSELECT A.Name FROM A INNER JOIN B ON A.id = B.id\n```\n\n- 外联结：分为外左联结和外右联结。\n\n```\nSELECT A.Name FROM A LEFT JOIN B ON A.id = B.id\n或者\nSELECT A.Name FROM B RIGHT JOIN A ON A.id = B.id\n```\n\n- 全联结：将两个表中存在联结关系的字段的所有记录取出形成记录集的联结。 mysql本身没有实现全联结，可以使用`左连接 union 右连接`来实现\n\n```\nSELECT L.*,r.* FROM left_table L LEFT JOIN right_table r on L.age=r.age UNION\nSELECT L.*,r.* FROM left_table L RIGHT JOIN right_table r on L.age=r.age\n```\n\n- 无联结：没有使用联结功能，也有自联结的说法。\n\n假如要取两个用户共同评论过的商品详情，如何写SQL语句？\n\n### [4.2 事务](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#42-事务)\n\n##### [4.2.1 ACID特性](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#421-acid特性)\n\n- 原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。\n- 一致性（Consistency） 一致性是指事务必须使数据库从一个一致的状态变到另外一个一致的状态，也就是执行事务之前和之后的状态都必须处于一致的状态。\n- 隔离性(Isolation) 隔离性是指当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离\n- 持久性(Durability) 持久性是指一个事务一旦被提交了，那么对于数据库中的数据改变就是永久性的，即便是在数据库系统遭遇到故障的情况下也不会丢失提交事务的操作。\n\n##### [4.2.2 事务的使用](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#422-事务的使用)\n\n```\nset autocommit = 0;\nstart transaction;\nupdate accout set money=money+100 where name=\"Jason\";\ncommit;\n```\n\n##### [4.2.3 事务的回滚](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#423-事务的回滚)\n\n```\nset autocommit = 0;\nstart transaction;\nupdate account set money=money-100 where name=\"justin\";\nrollback;\n```\n\n##### [4.4.4 事务隔离级别](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#444-事务隔离级别)\n\n查询\n\n```\nselect @@tx_isolation;\n```\n\n设置当前session的下一个事务的隔离级别\n\n```\nset transaction isolation level Read uncommitted;\n```\n\n设置当前session以后所有事务的隔离级别\n\n```\nset session transaction isolation level Read uncommitted;\n```\n\n设置之后的所有session的隔离级别，不包括当前session\n\n```\nset global transaction isolation level Read uncommitted;\n```\n\n### [4.3 索引](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#43-索引)\n\n### [4.4 锁](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#44-锁)\n\n##### [4.4.1 锁方案](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#441-锁方案)\n\n- 一次封锁：可以避免大量并发情况下的死锁，前提条件是已知要在哪些数据加锁，不适合用在数据库事务中。\n- 两段锁：两段锁协议将事务分成两个阶段：加锁阶段和解锁阶段。在事务开始时加锁，事务结束后解锁。无法避免死锁，但能保证事务的串行化。\n\n##### [4.4.2 锁类型](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#442-锁类型)\n\n- 表锁：对一整张表加锁，并发能力低下（即使有分读锁、写锁），一般在DDL处理时使用。\n- 行锁：只锁住特定行的数据，并发能力强，MySQL一般都是用行锁来处理并发事务。\n- GAP锁（间隙锁）：是MySQL使用索引对行锁两边的区间进行加锁，避免其他事务在这两个区间insert的一种锁。\n- Next-Key锁：Next-Key锁是行锁和GAP锁的合并（MySQL使用它来避免幻读）\n- MVVC(多版本并发控制）：Innodb中的乐观锁实现。通过它提高MySQL的读取操作的性能。并能解决MySQL的重复读问题。\n\n## [5. 缓存](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#5-缓存)\n\n### [5.1 缓存金字塔](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#51-缓存金字塔)\n\n从上到下速度由快到慢，容量由小到大\n\n- 寄存器\n- L1缓存\n- L2缓存、L3缓存\n- 系统缓存：缓存系统元数据和文件数据。\n- 内存缓存：redis、memcached等使用内存来保存数据的缓存\n- 磁盘缓存：交换分区、缓存文件等\n- 网络缓存：CDN等通过网络来访问的缓存\n\n### [5.2 http请求的缓存过程](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#52-http请求的缓存过程)\n\n从上到下优先级从高到低\n\n- 浏览器内存缓存\n- 浏览器文件缓存\n- 浏览器DNS缓存\n- CDN缓存\n- nginx缓存\n- web服务缓存\n- redis缓存\n- 数据库缓存\n\n## [6. web开发](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#6-web开发)\n\n- http缓存\n- http状态码\n- web后端框架\n- websocket建立过程\n- http2基本原理\n\n## [7. 数据结构和算法](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#7-数据结构和算法)\n\n- 树操作：前序遍历、中序遍历、后序遍历；平衡二叉树调整子节点\n- 堆：TopN 问题\n- 数组：快排、归并\n\n## [8. shell脚本](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#8-shell脚本)\n\n- awk 输出第一列、第二列、最后一列，用一个空格隔开。\n- 逐行读取文件，在每行行首添加行号，用空格隔开","source":"_posts/面试/要点整理/精选面试题.md","raw":"---\ntitle: go语言规范\ndate: 2019-02-20\ntags:\n- go\ncategories:\n- 面试\n---\n\n## [1. 系统知识](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#1-系统知识)\n\n系统知识主要用于评判候选人是否为资深软件工程师\n\n<!-- more -->\n\n### [1.1 网络](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#11-网络)\n\n考察对象: 工作三年以上\n\n##### [1.1.1 网络七层模型](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#111-网络七层模型)\n\n又称OSI 模型，从下到上分别为：\n\n- 物理层：底层数据传输，如网线；网卡标准。\n- 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。\n- 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。\n- 传输层：端到端传输数据的基本功能；如 TCP、UDP。\n- 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。\n- 标识层：数据格式标识，基本压缩加密功能。\n- 应用层：各种应用软件，包括 Web 应用。\n\n##### [1.1.2 网络四层模型](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#112-网络四层模型)\n\n从下到上分别为：\n\n- 网络访问层：ARP、RARP等协议\n- 互联网层：ICMP、IP等协议\n- 传输层：TCP、UDP等协议\n- 应用层：DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS等协议\n\n##### [1.1.3 TCP、UDP、IP 协议](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#113-tcpudpip-协议)\n\n- TCP与UDP的区别\n  1. TCP属于有状态的可靠连接，通过ack、拆包组包机制保障数据按照顺序传递，一旦建立好连接，路由路线是固定的；UDP本身是无状态的不可靠连接，没有固定的路由路线，优先选择速度快的路由路线，顺序靠应用程序自己保障。\n  2. TCP是基于数据流的，对应用层来说没有固定包大小，在TCP内部会发生拆包组包；UDP是基于数据包的，对应用程序来说有固定大小，UDP内部不会发生拆包组包。但不管是TCP还是UDP，在IP层都有可能发生拆包组包。\n- TCP粘包问题\n  1. 发送端需要等缓冲区满才发送出去，造成粘包（nalge算法也可能造成粘包现象），可以通过设置socket为 nodelay解决。\n  2. 接收方不及时接收缓冲区的包，造成多个包接收。应用程序对每个数据包添加包头来区分数据界限解决。\n- TCP拆包问题\n  1. 发送的TCP报文大于TCP发送缓冲区剩余空间大小。\n  2. 缓冲区中待发送的数据大小大于MSS（最大报文长度） 拆包问题，可以通过压缩数据得到改善。\n- TCP快速重传、快速恢复、慢启动、滑动窗口\n  1. TCP使用滑动窗口机制进行拥塞控制，避免网络质量变差时ACK时间过长导致丢包以及网络质量变好时频繁的ACK导致网络速度无法提升。\n  2. 所谓的慢启动是指滑动窗口的调整是缓慢的调整，即使是网络质量很好的情况下，滑动窗口调整到合适大小也是需要一定时间。\n  3. 快速重传：接收方接收到无序的包时，会立即发送ACK给发送方请求重传缺失的包，如果发送方连续收到3个或者3个以上的重传ACK，那么就判定丢包了，立即重传丢失的包。\n  4. 快速恢复：丢包意味着网络环境变差，默认情况下TCP会恢复到慢启动来进行重传。快速恢复算法在收到3个重传ACK的时候判定网络环境质量并不差，决定不恢复到慢启动，直接重传丢失的包。\n- IP层拆包组包 当报文超过MTU（最大传输单元）大小时，将发生IP层的拆包组包。MTU由路由协商决定，取路由两端以太网帧大小中较小的值。\n\n##### [1.1.4 TCP端口快速回收与重用](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#114-tcp端口快速回收与重用)\n\n由于http协议是短连接，请求完毕后会关闭连接，导致服务器频繁的建立、断开连接，而TCP的回收是有等待时间的，在高并发的http服务器上，我们需要对TCP连接进行调优。否则，容易出现大量time_wait状态的连接占用大量资源。\n\n```\n# 开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭\nnet.ipv4.tcp_syncookies = 1\n# 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭\nnet.ipv4.tcp_tw_reuse = 1\n# 开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。\nnet.ipv4.tcp_tw_recycle = 1\n# 修改系統默认的TIMEOUT时间\nnet.ipv4.tcp_fin_timeout = 30\nnet.ipv4.tcp_timestamps = 1\n```\n\n服务端程序监听端口的socket也可能会遇到回收慢的问题。服务因意外挂掉没及时关闭socket，导致重启时无法监听端口。可以在代码里设置socket的reuse参数\n\n### [1.2 系统调用与函数调用](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#12-系统调用与函数调用)\n\n考察对象: 工作三年以上 附加考察点：应用程序地址空间的划分\n\n应用程序地址空间的最高1G的内存空间是内核态内存空间，其余的属于用户态内存空间。内核态内存空间主要用于系统调用时在内核态保存数据。\n\n##### [1.2.1 系统调用](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#121-系统调用)\n\n系统调用是指通过软中断调用系统内核函数的过程。\n\n- 应用程序调用C函数库中的函数（GO例外，GO自己封装了系统库函数）\n- C函数库中触发软中断 INT 0x80，把系统调用号放入 %eax 寄存器\n- 保存应用程序上下文到应用程序栈内存，主要是保存各种寄存器的值，其中最重要的是程序计数器（PC）和栈指针寄存器（SP）\n- 陷入内核态\n- 调用`copy_from_user`将参数从用户态内存复制到内核态内存\n- 调用内核函数\n- 调用`copy_to_user`将返回值从内核态内存复制到用户态内存\n- 返回用户态\n- 恢复应用程序上下文，并将PC所指内存地址的指令加载到指令寄存器（IP）\n- 继续执行应用程序\n\n##### [1.2.2 函数调用](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#122-函数调用)\n\n函数调用是指给定特定参数调用函数功能并获取返回结果的过程。\n\n- 保存函数参数到函数栈帧\n- 保存函数调用完成后执行的下一条指令的地址到栈帧\n- 跳转到函数地址\n- 执行函数体\n- 将返回值保存到栈帧\n- 从栈帧加载下一条指令地址\n- 执行下一条指令\n\n##### [1.2.3 系统调用与函数调用的区别](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#123-系统调用与函数调用的区别)\n\n- 函数调用不需要触发软中断\n- 函数调用不需要执行上下文切换\n- 系统调用是调用系统内核函数，函数调用是调用应用程序的函数\n\n### [1.3 并发与并行](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#13-并发与并行)\n\n并发：某一时间段内处理多个任务的能力。 并行：某一时间点处理多个任务的能力。\n\n##### [1.3.1 并发](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#131-并发)\n\n并发强调的是单个处理单元在单位时间内处理任务的能力。常见的并发场景有：\n\n- 单个CPU核单位时间内执行的任务（线程）数。如通过top查看到的load avrage在一定程度上反馈了CPU的并发数\n- 单个服务器单位时间内处理的请求数。如QPS这一指标一定程度上衡量了一台服务器的处理能力。\n\n#### [1.3.2 并行](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#132-并行)\n\n并行强调的是整个系统某一时间点同时处理任务的能力。常见的并行场景有：\n\n- CPU的指令流水线同时处理的指令数。如三级流水线表示整个流水线能同时处理三条指令：取指（加载指令）、预处理、执行。\n- CORE I7 处理器4核8线程，能同时让8个线程在上面工作。\n- 一个拥有10个节点的集群，能同时处理至少10个网络请求。\n\n#### [1.3.3 多线程同步](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#133-多线程同步)\n\n原因：CPU内核有缓存，现代多核CPU缓存中寄存器、L1缓存是独占的，L2、L3缓存是多核共享。多线程不同步的原因本质上是CPU核之间缓存不同步、CPU缓存与内存不同步。 解决方案：1、加锁，强制同步CPU核之间的缓存，适合复杂数据类型。2、volatile关键字，禁止寄存器优化，适合简单数据类型（如整数），但只能降低概率，并不能保证原子性。3、原子操作，CPU利用内存屏障，在CPU对内容进行“读-修改-写”这一连续操作时，锁定内存总线，屏蔽其他的读写操作。内存屏障分为读屏障（load barrier）、写屏障（store barrier）、全屏障（full barrier）。读屏障是加在指令前强制让CPU缓存失效，直接从内存读取；写屏障是加在指令后强制将CPU缓存中的数据写入到内存。\n\n## [2. 架构能力](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#2-架构能力)\n\n考察对象：工作五年以上 架构能力考察候选人软件架构方面的知识和能力。\n\n### [2.1 分布式与集群](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#21-分布式与集群)\n\n集群：多个处理相同任务的节点组成集群。 分布式：多个处理不同子任务的节点组成分布式系统。 分布式系统中往往涉及关键数据的同步，需要用到分布式锁。\n\n##### [2.1.1 分布式锁](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#211-分布式锁)\n\n分布式锁基本理论：CAP、悲观锁、乐观锁（CAS） CAP：任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。 CAS： compare and swap，比较并交换。在修改正式数据之前，先会把现有数据版本与修改前的数据版本比较：如果相等则执行修改操作；如果不相等则需要重新获取数据和版本并提交CAS请求。 悲观锁：假设所有操作都可能会修改数据，默认执行加锁操作，直到等待锁释放后才能加锁成功。相当于互斥锁。 乐观锁：假设所有操作中读操作远比写操作多，在修改数据之前检查条件，条件符合则执行修改操作，条件不符合则返回失败。\n\n常用的分布式锁主要有以下几种\n\n- 基于redis、memcached等缓存实现 redis的悲观锁： 加锁\n\n  ```\n  setnx test 1\n  ```\n\n  ，如果test已经存在，则返回0表示加锁失败。解锁\n\n  ```\n  del test\n  ```\n\n   redis的乐观锁：\n\n  ```\n  watch\n  multi\n  set test 1\n  get test\n  exec\n  unwatch\n  ```\n\n  判断get test的返回值是否为 set 的值来判断是否加锁成功\n\n- 基于zookeeper、etcd等集群管理软件实现 etcd 的悲观锁：\n\n  ```\n  1. 创建一个key\n  2. 如果key不存在返回成功并执行第 5 步\n  3. 如果key存在则返回失败，需要watch这个key等待key被删除\n  4. 如果key被删除则重试第 1 步\n  5. 执行需要的操作\n  ```\n\n  etcd 的乐观锁：\n\n  ```\n  1. 读取数据以及数据的版本号 ModifiedIndex\n  2. 修改数据时用ModifiedIndex作为数据的比较条件\n  3. 如果ModifiedIndex与现有数据的相同，则修改成功；否则修改失败，重试第 1 步\n  ```\n\n  etcd v3 已经提供了lock和unlock的接口\n\n- 基于mysql等数据库实现 悲观锁：\n\n  ```\n  SELECT * FROM methodLock WHERE method_name=xxx FOR UPDATE\n  UPDATE tb_stock SET number=number-1\n  ```\n\n  乐观锁：\n\n  ```\n  update tb_stock set number=number-1 where product_id=xxx\n  ```\n\n### [2.2 微服务](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#22-微服务)\n\n- SOA：服务注册与发现、配置管理 ETCD、zookeeper的用法\n- RPC：微服务调用 thrift、protobuf、grpc的原理和用法\n- MQ：异步调用、日志收集 rabbitmq、kafka的架构和用法\n- 容器：服务调度和治理 docker、kubernetes的原理和用法\n\n## [3. 编程语言](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#3-编程语言)\n\n### [3.1 PHP](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#31-php)\n\n### [3.2 Golang](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#32-golang)\n\n考察点：\n\n- go调度器模型\n- channel的各种用法\n- goroutine的各种用法\n- interface的各种用法\n- sync包的用法\n- time包定时器的用法\n- context包用法和实现原理\n\n##### [3.2.1 Golang的调度器模型](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#321-golang的调度器模型)\n\n用这个知识点来初步判断候选人是否真的对golang感兴趣并了解过golang\n\n##### [3.2.2 channel](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#322-channel)\n\n**种类**\n\n- nil 值为nil的channel，读写都会block。主要用于select的时候将close掉的channel置为nil，防止触发相应case。\n- 无缓冲 读写都会block，读操作在写操作之前完成。一般用于同步通知。\n\n```\nch := make(chan struct{})\ngo func(){\n\t//do something\n    close(ch)\n}()\n//wait goroutine finish\n<- ch\n//do something\n```\n\n- 单缓冲 无数据时，读操作block；有数据时，写操作block。用于保证数据有序传递并且限制接收端的最大速度。\n- 多缓冲 只要缓冲区有数据，读操作不会被block；即使有数据，只要缓冲区有空间，写操作不会被block。可以保证数据有序传递，但无法限制接收端的最大速度，只能限制接收端的平均速度。\n\n##### [3.2.3 goroutine](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#323-goroutine)\n\n## [4. 数据库](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#4-数据库)\n\n### [4.1 关联查询](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#41-关联查询)\n\n- 内联结：将两个表中存在联结关系的字段符合联结关系的那些记录形成记录集的联结。\n\n```\nSELECT A.Name B.Hobby FROM A, B WHERE A.id = B.id\n或者\nSELECT A.Name FROM A INNER JOIN B ON A.id = B.id\n```\n\n- 外联结：分为外左联结和外右联结。\n\n```\nSELECT A.Name FROM A LEFT JOIN B ON A.id = B.id\n或者\nSELECT A.Name FROM B RIGHT JOIN A ON A.id = B.id\n```\n\n- 全联结：将两个表中存在联结关系的字段的所有记录取出形成记录集的联结。 mysql本身没有实现全联结，可以使用`左连接 union 右连接`来实现\n\n```\nSELECT L.*,r.* FROM left_table L LEFT JOIN right_table r on L.age=r.age UNION\nSELECT L.*,r.* FROM left_table L RIGHT JOIN right_table r on L.age=r.age\n```\n\n- 无联结：没有使用联结功能，也有自联结的说法。\n\n假如要取两个用户共同评论过的商品详情，如何写SQL语句？\n\n### [4.2 事务](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#42-事务)\n\n##### [4.2.1 ACID特性](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#421-acid特性)\n\n- 原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。\n- 一致性（Consistency） 一致性是指事务必须使数据库从一个一致的状态变到另外一个一致的状态，也就是执行事务之前和之后的状态都必须处于一致的状态。\n- 隔离性(Isolation) 隔离性是指当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离\n- 持久性(Durability) 持久性是指一个事务一旦被提交了，那么对于数据库中的数据改变就是永久性的，即便是在数据库系统遭遇到故障的情况下也不会丢失提交事务的操作。\n\n##### [4.2.2 事务的使用](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#422-事务的使用)\n\n```\nset autocommit = 0;\nstart transaction;\nupdate accout set money=money+100 where name=\"Jason\";\ncommit;\n```\n\n##### [4.2.3 事务的回滚](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#423-事务的回滚)\n\n```\nset autocommit = 0;\nstart transaction;\nupdate account set money=money-100 where name=\"justin\";\nrollback;\n```\n\n##### [4.4.4 事务隔离级别](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#444-事务隔离级别)\n\n查询\n\n```\nselect @@tx_isolation;\n```\n\n设置当前session的下一个事务的隔离级别\n\n```\nset transaction isolation level Read uncommitted;\n```\n\n设置当前session以后所有事务的隔离级别\n\n```\nset session transaction isolation level Read uncommitted;\n```\n\n设置之后的所有session的隔离级别，不包括当前session\n\n```\nset global transaction isolation level Read uncommitted;\n```\n\n### [4.3 索引](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#43-索引)\n\n### [4.4 锁](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#44-锁)\n\n##### [4.4.1 锁方案](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#441-锁方案)\n\n- 一次封锁：可以避免大量并发情况下的死锁，前提条件是已知要在哪些数据加锁，不适合用在数据库事务中。\n- 两段锁：两段锁协议将事务分成两个阶段：加锁阶段和解锁阶段。在事务开始时加锁，事务结束后解锁。无法避免死锁，但能保证事务的串行化。\n\n##### [4.4.2 锁类型](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#442-锁类型)\n\n- 表锁：对一整张表加锁，并发能力低下（即使有分读锁、写锁），一般在DDL处理时使用。\n- 行锁：只锁住特定行的数据，并发能力强，MySQL一般都是用行锁来处理并发事务。\n- GAP锁（间隙锁）：是MySQL使用索引对行锁两边的区间进行加锁，避免其他事务在这两个区间insert的一种锁。\n- Next-Key锁：Next-Key锁是行锁和GAP锁的合并（MySQL使用它来避免幻读）\n- MVVC(多版本并发控制）：Innodb中的乐观锁实现。通过它提高MySQL的读取操作的性能。并能解决MySQL的重复读问题。\n\n## [5. 缓存](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#5-缓存)\n\n### [5.1 缓存金字塔](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#51-缓存金字塔)\n\n从上到下速度由快到慢，容量由小到大\n\n- 寄存器\n- L1缓存\n- L2缓存、L3缓存\n- 系统缓存：缓存系统元数据和文件数据。\n- 内存缓存：redis、memcached等使用内存来保存数据的缓存\n- 磁盘缓存：交换分区、缓存文件等\n- 网络缓存：CDN等通过网络来访问的缓存\n\n### [5.2 http请求的缓存过程](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#52-http请求的缓存过程)\n\n从上到下优先级从高到低\n\n- 浏览器内存缓存\n- 浏览器文件缓存\n- 浏览器DNS缓存\n- CDN缓存\n- nginx缓存\n- web服务缓存\n- redis缓存\n- 数据库缓存\n\n## [6. web开发](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#6-web开发)\n\n- http缓存\n- http状态码\n- web后端框架\n- websocket建立过程\n- http2基本原理\n\n## [7. 数据结构和算法](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#7-数据结构和算法)\n\n- 树操作：前序遍历、中序遍历、后序遍历；平衡二叉树调整子节点\n- 堆：TopN 问题\n- 数组：快排、归并\n\n## [8. shell脚本](https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#8-shell脚本)\n\n- awk 输出第一列、第二列、最后一列，用一个空格隔开。\n- 逐行读取文件，在每行行首添加行号，用空格隔开","slug":"面试/要点整理/精选面试题","published":1,"updated":"2020-01-23T08:41:52.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck845eixm000tny8n4iwde5k5","content":"<h2 id=\"1-系统知识\"><a href=\"#1-系统知识\" class=\"headerlink\" title=\"1. 系统知识\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#1-系统知识\" target=\"_blank\" rel=\"noopener\">1. 系统知识</a></h2><p>系统知识主要用于评判候选人是否为资深软件工程师</p>\n<a id=\"more\"></a>\n\n<h3 id=\"1-1-网络\"><a href=\"#1-1-网络\" class=\"headerlink\" title=\"1.1 网络\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#11-网络\" target=\"_blank\" rel=\"noopener\">1.1 网络</a></h3><p>考察对象: 工作三年以上</p>\n<h5 id=\"1-1-1-网络七层模型\"><a href=\"#1-1-1-网络七层模型\" class=\"headerlink\" title=\"1.1.1 网络七层模型\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#111-网络七层模型\" target=\"_blank\" rel=\"noopener\">1.1.1 网络七层模型</a></h5><p>又称OSI 模型，从下到上分别为：</p>\n<ul>\n<li>物理层：底层数据传输，如网线；网卡标准。</li>\n<li>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</li>\n<li>网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</li>\n<li>传输层：端到端传输数据的基本功能；如 TCP、UDP。</li>\n<li>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</li>\n<li>标识层：数据格式标识，基本压缩加密功能。</li>\n<li>应用层：各种应用软件，包括 Web 应用。</li>\n</ul>\n<h5 id=\"1-1-2-网络四层模型\"><a href=\"#1-1-2-网络四层模型\" class=\"headerlink\" title=\"1.1.2 网络四层模型\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#112-网络四层模型\" target=\"_blank\" rel=\"noopener\">1.1.2 网络四层模型</a></h5><p>从下到上分别为：</p>\n<ul>\n<li>网络访问层：ARP、RARP等协议</li>\n<li>互联网层：ICMP、IP等协议</li>\n<li>传输层：TCP、UDP等协议</li>\n<li>应用层：DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS等协议</li>\n</ul>\n<h5 id=\"1-1-3-TCP、UDP、IP-协议\"><a href=\"#1-1-3-TCP、UDP、IP-协议\" class=\"headerlink\" title=\"1.1.3 TCP、UDP、IP 协议\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#113-tcpudpip-协议\" target=\"_blank\" rel=\"noopener\">1.1.3 TCP、UDP、IP 协议</a></h5><ul>\n<li>TCP与UDP的区别<ol>\n<li>TCP属于有状态的可靠连接，通过ack、拆包组包机制保障数据按照顺序传递，一旦建立好连接，路由路线是固定的；UDP本身是无状态的不可靠连接，没有固定的路由路线，优先选择速度快的路由路线，顺序靠应用程序自己保障。</li>\n<li>TCP是基于数据流的，对应用层来说没有固定包大小，在TCP内部会发生拆包组包；UDP是基于数据包的，对应用程序来说有固定大小，UDP内部不会发生拆包组包。但不管是TCP还是UDP，在IP层都有可能发生拆包组包。</li>\n</ol>\n</li>\n<li>TCP粘包问题<ol>\n<li>发送端需要等缓冲区满才发送出去，造成粘包（nalge算法也可能造成粘包现象），可以通过设置socket为 nodelay解决。</li>\n<li>接收方不及时接收缓冲区的包，造成多个包接收。应用程序对每个数据包添加包头来区分数据界限解决。</li>\n</ol>\n</li>\n<li>TCP拆包问题<ol>\n<li>发送的TCP报文大于TCP发送缓冲区剩余空间大小。</li>\n<li>缓冲区中待发送的数据大小大于MSS（最大报文长度） 拆包问题，可以通过压缩数据得到改善。</li>\n</ol>\n</li>\n<li>TCP快速重传、快速恢复、慢启动、滑动窗口<ol>\n<li>TCP使用滑动窗口机制进行拥塞控制，避免网络质量变差时ACK时间过长导致丢包以及网络质量变好时频繁的ACK导致网络速度无法提升。</li>\n<li>所谓的慢启动是指滑动窗口的调整是缓慢的调整，即使是网络质量很好的情况下，滑动窗口调整到合适大小也是需要一定时间。</li>\n<li>快速重传：接收方接收到无序的包时，会立即发送ACK给发送方请求重传缺失的包，如果发送方连续收到3个或者3个以上的重传ACK，那么就判定丢包了，立即重传丢失的包。</li>\n<li>快速恢复：丢包意味着网络环境变差，默认情况下TCP会恢复到慢启动来进行重传。快速恢复算法在收到3个重传ACK的时候判定网络环境质量并不差，决定不恢复到慢启动，直接重传丢失的包。</li>\n</ol>\n</li>\n<li>IP层拆包组包 当报文超过MTU（最大传输单元）大小时，将发生IP层的拆包组包。MTU由路由协商决定，取路由两端以太网帧大小中较小的值。</li>\n</ul>\n<h5 id=\"1-1-4-TCP端口快速回收与重用\"><a href=\"#1-1-4-TCP端口快速回收与重用\" class=\"headerlink\" title=\"1.1.4 TCP端口快速回收与重用\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#114-tcp端口快速回收与重用\" target=\"_blank\" rel=\"noopener\">1.1.4 TCP端口快速回收与重用</a></h5><p>由于http协议是短连接，请求完毕后会关闭连接，导致服务器频繁的建立、断开连接，而TCP的回收是有等待时间的，在高并发的http服务器上，我们需要对TCP连接进行调优。否则，容易出现大量time_wait状态的连接占用大量资源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭</span><br><span class=\"line\">net.ipv4.tcp_syncookies &#x3D; 1</span><br><span class=\"line\"># 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</span><br><span class=\"line\">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class=\"line\"># 开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class=\"line\">net.ipv4.tcp_tw_recycle &#x3D; 1</span><br><span class=\"line\"># 修改系統默认的TIMEOUT时间</span><br><span class=\"line\">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br><span class=\"line\">net.ipv4.tcp_timestamps &#x3D; 1</span><br></pre></td></tr></table></figure>\n\n<p>服务端程序监听端口的socket也可能会遇到回收慢的问题。服务因意外挂掉没及时关闭socket，导致重启时无法监听端口。可以在代码里设置socket的reuse参数</p>\n<h3 id=\"1-2-系统调用与函数调用\"><a href=\"#1-2-系统调用与函数调用\" class=\"headerlink\" title=\"1.2 系统调用与函数调用\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#12-系统调用与函数调用\" target=\"_blank\" rel=\"noopener\">1.2 系统调用与函数调用</a></h3><p>考察对象: 工作三年以上 附加考察点：应用程序地址空间的划分</p>\n<p>应用程序地址空间的最高1G的内存空间是内核态内存空间，其余的属于用户态内存空间。内核态内存空间主要用于系统调用时在内核态保存数据。</p>\n<h5 id=\"1-2-1-系统调用\"><a href=\"#1-2-1-系统调用\" class=\"headerlink\" title=\"1.2.1 系统调用\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#121-系统调用\" target=\"_blank\" rel=\"noopener\">1.2.1 系统调用</a></h5><p>系统调用是指通过软中断调用系统内核函数的过程。</p>\n<ul>\n<li>应用程序调用C函数库中的函数（GO例外，GO自己封装了系统库函数）</li>\n<li>C函数库中触发软中断 INT 0x80，把系统调用号放入 %eax 寄存器</li>\n<li>保存应用程序上下文到应用程序栈内存，主要是保存各种寄存器的值，其中最重要的是程序计数器（PC）和栈指针寄存器（SP）</li>\n<li>陷入内核态</li>\n<li>调用<code>copy_from_user</code>将参数从用户态内存复制到内核态内存</li>\n<li>调用内核函数</li>\n<li>调用<code>copy_to_user</code>将返回值从内核态内存复制到用户态内存</li>\n<li>返回用户态</li>\n<li>恢复应用程序上下文，并将PC所指内存地址的指令加载到指令寄存器（IP）</li>\n<li>继续执行应用程序</li>\n</ul>\n<h5 id=\"1-2-2-函数调用\"><a href=\"#1-2-2-函数调用\" class=\"headerlink\" title=\"1.2.2 函数调用\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#122-函数调用\" target=\"_blank\" rel=\"noopener\">1.2.2 函数调用</a></h5><p>函数调用是指给定特定参数调用函数功能并获取返回结果的过程。</p>\n<ul>\n<li>保存函数参数到函数栈帧</li>\n<li>保存函数调用完成后执行的下一条指令的地址到栈帧</li>\n<li>跳转到函数地址</li>\n<li>执行函数体</li>\n<li>将返回值保存到栈帧</li>\n<li>从栈帧加载下一条指令地址</li>\n<li>执行下一条指令</li>\n</ul>\n<h5 id=\"1-2-3-系统调用与函数调用的区别\"><a href=\"#1-2-3-系统调用与函数调用的区别\" class=\"headerlink\" title=\"1.2.3 系统调用与函数调用的区别\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#123-系统调用与函数调用的区别\" target=\"_blank\" rel=\"noopener\">1.2.3 系统调用与函数调用的区别</a></h5><ul>\n<li>函数调用不需要触发软中断</li>\n<li>函数调用不需要执行上下文切换</li>\n<li>系统调用是调用系统内核函数，函数调用是调用应用程序的函数</li>\n</ul>\n<h3 id=\"1-3-并发与并行\"><a href=\"#1-3-并发与并行\" class=\"headerlink\" title=\"1.3 并发与并行\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#13-并发与并行\" target=\"_blank\" rel=\"noopener\">1.3 并发与并行</a></h3><p>并发：某一时间段内处理多个任务的能力。 并行：某一时间点处理多个任务的能力。</p>\n<h5 id=\"1-3-1-并发\"><a href=\"#1-3-1-并发\" class=\"headerlink\" title=\"1.3.1 并发\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#131-并发\" target=\"_blank\" rel=\"noopener\">1.3.1 并发</a></h5><p>并发强调的是单个处理单元在单位时间内处理任务的能力。常见的并发场景有：</p>\n<ul>\n<li>单个CPU核单位时间内执行的任务（线程）数。如通过top查看到的load avrage在一定程度上反馈了CPU的并发数</li>\n<li>单个服务器单位时间内处理的请求数。如QPS这一指标一定程度上衡量了一台服务器的处理能力。</li>\n</ul>\n<h4 id=\"1-3-2-并行\"><a href=\"#1-3-2-并行\" class=\"headerlink\" title=\"1.3.2 并行\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#132-并行\" target=\"_blank\" rel=\"noopener\">1.3.2 并行</a></h4><p>并行强调的是整个系统某一时间点同时处理任务的能力。常见的并行场景有：</p>\n<ul>\n<li>CPU的指令流水线同时处理的指令数。如三级流水线表示整个流水线能同时处理三条指令：取指（加载指令）、预处理、执行。</li>\n<li>CORE I7 处理器4核8线程，能同时让8个线程在上面工作。</li>\n<li>一个拥有10个节点的集群，能同时处理至少10个网络请求。</li>\n</ul>\n<h4 id=\"1-3-3-多线程同步\"><a href=\"#1-3-3-多线程同步\" class=\"headerlink\" title=\"1.3.3 多线程同步\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#133-多线程同步\" target=\"_blank\" rel=\"noopener\">1.3.3 多线程同步</a></h4><p>原因：CPU内核有缓存，现代多核CPU缓存中寄存器、L1缓存是独占的，L2、L3缓存是多核共享。多线程不同步的原因本质上是CPU核之间缓存不同步、CPU缓存与内存不同步。 解决方案：1、加锁，强制同步CPU核之间的缓存，适合复杂数据类型。2、volatile关键字，禁止寄存器优化，适合简单数据类型（如整数），但只能降低概率，并不能保证原子性。3、原子操作，CPU利用内存屏障，在CPU对内容进行“读-修改-写”这一连续操作时，锁定内存总线，屏蔽其他的读写操作。内存屏障分为读屏障（load barrier）、写屏障（store barrier）、全屏障（full barrier）。读屏障是加在指令前强制让CPU缓存失效，直接从内存读取；写屏障是加在指令后强制将CPU缓存中的数据写入到内存。</p>\n<h2 id=\"2-架构能力\"><a href=\"#2-架构能力\" class=\"headerlink\" title=\"2. 架构能力\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#2-架构能力\" target=\"_blank\" rel=\"noopener\">2. 架构能力</a></h2><p>考察对象：工作五年以上 架构能力考察候选人软件架构方面的知识和能力。</p>\n<h3 id=\"2-1-分布式与集群\"><a href=\"#2-1-分布式与集群\" class=\"headerlink\" title=\"2.1 分布式与集群\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#21-分布式与集群\" target=\"_blank\" rel=\"noopener\">2.1 分布式与集群</a></h3><p>集群：多个处理相同任务的节点组成集群。 分布式：多个处理不同子任务的节点组成分布式系统。 分布式系统中往往涉及关键数据的同步，需要用到分布式锁。</p>\n<h5 id=\"2-1-1-分布式锁\"><a href=\"#2-1-1-分布式锁\" class=\"headerlink\" title=\"2.1.1 分布式锁\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#211-分布式锁\" target=\"_blank\" rel=\"noopener\">2.1.1 分布式锁</a></h5><p>分布式锁基本理论：CAP、悲观锁、乐观锁（CAS） CAP：任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。 CAS： compare and swap，比较并交换。在修改正式数据之前，先会把现有数据版本与修改前的数据版本比较：如果相等则执行修改操作；如果不相等则需要重新获取数据和版本并提交CAS请求。 悲观锁：假设所有操作都可能会修改数据，默认执行加锁操作，直到等待锁释放后才能加锁成功。相当于互斥锁。 乐观锁：假设所有操作中读操作远比写操作多，在修改数据之前检查条件，条件符合则执行修改操作，条件不符合则返回失败。</p>\n<p>常用的分布式锁主要有以下几种</p>\n<ul>\n<li><p>基于redis、memcached等缓存实现 redis的悲观锁： 加锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setnx test 1</span><br></pre></td></tr></table></figure>\n\n<p>，如果test已经存在，则返回0表示加锁失败。解锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">del test</span><br></pre></td></tr></table></figure>\n\n<p> redis的乐观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch</span><br><span class=\"line\">multi</span><br><span class=\"line\">set test 1</span><br><span class=\"line\">get test</span><br><span class=\"line\">exec</span><br><span class=\"line\">unwatch</span><br></pre></td></tr></table></figure>\n\n<p>判断get test的返回值是否为 set 的值来判断是否加锁成功</p>\n</li>\n<li><p>基于zookeeper、etcd等集群管理软件实现 etcd 的悲观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 创建一个key</span><br><span class=\"line\">2. 如果key不存在返回成功并执行第 5 步</span><br><span class=\"line\">3. 如果key存在则返回失败，需要watch这个key等待key被删除</span><br><span class=\"line\">4. 如果key被删除则重试第 1 步</span><br><span class=\"line\">5. 执行需要的操作</span><br></pre></td></tr></table></figure>\n\n<p>etcd 的乐观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 读取数据以及数据的版本号 ModifiedIndex</span><br><span class=\"line\">2. 修改数据时用ModifiedIndex作为数据的比较条件</span><br><span class=\"line\">3. 如果ModifiedIndex与现有数据的相同，则修改成功；否则修改失败，重试第 1 步</span><br></pre></td></tr></table></figure>\n\n<p>etcd v3 已经提供了lock和unlock的接口</p>\n</li>\n<li><p>基于mysql等数据库实现 悲观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM methodLock WHERE method_name&#x3D;xxx FOR UPDATE</span><br><span class=\"line\">UPDATE tb_stock SET number&#x3D;number-1</span><br></pre></td></tr></table></figure>\n\n<p>乐观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update tb_stock set number&#x3D;number-1 where product_id&#x3D;xxx</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"2-2-微服务\"><a href=\"#2-2-微服务\" class=\"headerlink\" title=\"2.2 微服务\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#22-微服务\" target=\"_blank\" rel=\"noopener\">2.2 微服务</a></h3><ul>\n<li>SOA：服务注册与发现、配置管理 ETCD、zookeeper的用法</li>\n<li>RPC：微服务调用 thrift、protobuf、grpc的原理和用法</li>\n<li>MQ：异步调用、日志收集 rabbitmq、kafka的架构和用法</li>\n<li>容器：服务调度和治理 docker、kubernetes的原理和用法</li>\n</ul>\n<h2 id=\"3-编程语言\"><a href=\"#3-编程语言\" class=\"headerlink\" title=\"3. 编程语言\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#3-编程语言\" target=\"_blank\" rel=\"noopener\">3. 编程语言</a></h2><h3 id=\"3-1-PHP\"><a href=\"#3-1-PHP\" class=\"headerlink\" title=\"3.1 PHP\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#31-php\" target=\"_blank\" rel=\"noopener\">3.1 PHP</a></h3><h3 id=\"3-2-Golang\"><a href=\"#3-2-Golang\" class=\"headerlink\" title=\"3.2 Golang\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#32-golang\" target=\"_blank\" rel=\"noopener\">3.2 Golang</a></h3><p>考察点：</p>\n<ul>\n<li>go调度器模型</li>\n<li>channel的各种用法</li>\n<li>goroutine的各种用法</li>\n<li>interface的各种用法</li>\n<li>sync包的用法</li>\n<li>time包定时器的用法</li>\n<li>context包用法和实现原理</li>\n</ul>\n<h5 id=\"3-2-1-Golang的调度器模型\"><a href=\"#3-2-1-Golang的调度器模型\" class=\"headerlink\" title=\"3.2.1 Golang的调度器模型\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#321-golang的调度器模型\" target=\"_blank\" rel=\"noopener\">3.2.1 Golang的调度器模型</a></h5><p>用这个知识点来初步判断候选人是否真的对golang感兴趣并了解过golang</p>\n<h5 id=\"3-2-2-channel\"><a href=\"#3-2-2-channel\" class=\"headerlink\" title=\"3.2.2 channel\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#322-channel\" target=\"_blank\" rel=\"noopener\">3.2.2 channel</a></h5><p><strong>种类</strong></p>\n<ul>\n<li>nil 值为nil的channel，读写都会block。主要用于select的时候将close掉的channel置为nil，防止触发相应case。</li>\n<li>无缓冲 读写都会block，读操作在写操作之前完成。一般用于同步通知。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch :&#x3D; make(chan struct&#123;&#125;)</span><br><span class=\"line\">go func()&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;do something</span><br><span class=\"line\">    close(ch)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\">&#x2F;&#x2F;wait goroutine finish</span><br><span class=\"line\">&lt;- ch</span><br><span class=\"line\">&#x2F;&#x2F;do something</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>单缓冲 无数据时，读操作block；有数据时，写操作block。用于保证数据有序传递并且限制接收端的最大速度。</li>\n<li>多缓冲 只要缓冲区有数据，读操作不会被block；即使有数据，只要缓冲区有空间，写操作不会被block。可以保证数据有序传递，但无法限制接收端的最大速度，只能限制接收端的平均速度。</li>\n</ul>\n<h5 id=\"3-2-3-goroutine\"><a href=\"#3-2-3-goroutine\" class=\"headerlink\" title=\"3.2.3 goroutine\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#323-goroutine\" target=\"_blank\" rel=\"noopener\">3.2.3 goroutine</a></h5><h2 id=\"4-数据库\"><a href=\"#4-数据库\" class=\"headerlink\" title=\"4. 数据库\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#4-数据库\" target=\"_blank\" rel=\"noopener\">4. 数据库</a></h2><h3 id=\"4-1-关联查询\"><a href=\"#4-1-关联查询\" class=\"headerlink\" title=\"4.1 关联查询\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#41-关联查询\" target=\"_blank\" rel=\"noopener\">4.1 关联查询</a></h3><ul>\n<li>内联结：将两个表中存在联结关系的字段符合联结关系的那些记录形成记录集的联结。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT A.Name B.Hobby FROM A, B WHERE A.id &#x3D; B.id</span><br><span class=\"line\">或者</span><br><span class=\"line\">SELECT A.Name FROM A INNER JOIN B ON A.id &#x3D; B.id</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>外联结：分为外左联结和外右联结。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT A.Name FROM A LEFT JOIN B ON A.id &#x3D; B.id</span><br><span class=\"line\">或者</span><br><span class=\"line\">SELECT A.Name FROM B RIGHT JOIN A ON A.id &#x3D; B.id</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全联结：将两个表中存在联结关系的字段的所有记录取出形成记录集的联结。 mysql本身没有实现全联结，可以使用<code>左连接 union 右连接</code>来实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT L.*,r.* FROM left_table L LEFT JOIN right_table r on L.age&#x3D;r.age UNION</span><br><span class=\"line\">SELECT L.*,r.* FROM left_table L RIGHT JOIN right_table r on L.age&#x3D;r.age</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>无联结：没有使用联结功能，也有自联结的说法。</li>\n</ul>\n<p>假如要取两个用户共同评论过的商品详情，如何写SQL语句？</p>\n<h3 id=\"4-2-事务\"><a href=\"#4-2-事务\" class=\"headerlink\" title=\"4.2 事务\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#42-事务\" target=\"_blank\" rel=\"noopener\">4.2 事务</a></h3><h5 id=\"4-2-1-ACID特性\"><a href=\"#4-2-1-ACID特性\" class=\"headerlink\" title=\"4.2.1 ACID特性\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#421-acid特性\" target=\"_blank\" rel=\"noopener\">4.2.1 ACID特性</a></h5><ul>\n<li>原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li>\n<li>一致性（Consistency） 一致性是指事务必须使数据库从一个一致的状态变到另外一个一致的状态，也就是执行事务之前和之后的状态都必须处于一致的状态。</li>\n<li>隔离性(Isolation) 隔离性是指当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</li>\n<li>持久性(Durability) 持久性是指一个事务一旦被提交了，那么对于数据库中的数据改变就是永久性的，即便是在数据库系统遭遇到故障的情况下也不会丢失提交事务的操作。</li>\n</ul>\n<h5 id=\"4-2-2-事务的使用\"><a href=\"#4-2-2-事务的使用\" class=\"headerlink\" title=\"4.2.2 事务的使用\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#422-事务的使用\" target=\"_blank\" rel=\"noopener\">4.2.2 事务的使用</a></h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set autocommit &#x3D; 0;</span><br><span class=\"line\">start transaction;</span><br><span class=\"line\">update accout set money&#x3D;money+100 where name&#x3D;&quot;Jason&quot;;</span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-2-3-事务的回滚\"><a href=\"#4-2-3-事务的回滚\" class=\"headerlink\" title=\"4.2.3 事务的回滚\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#423-事务的回滚\" target=\"_blank\" rel=\"noopener\">4.2.3 事务的回滚</a></h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set autocommit &#x3D; 0;</span><br><span class=\"line\">start transaction;</span><br><span class=\"line\">update account set money&#x3D;money-100 where name&#x3D;&quot;justin&quot;;</span><br><span class=\"line\">rollback;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-4-4-事务隔离级别\"><a href=\"#4-4-4-事务隔离级别\" class=\"headerlink\" title=\"4.4.4 事务隔离级别\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#444-事务隔离级别\" target=\"_blank\" rel=\"noopener\">4.4.4 事务隔离级别</a></h5><p>查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select @@tx_isolation;</span><br></pre></td></tr></table></figure>\n\n<p>设置当前session的下一个事务的隔离级别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set transaction isolation level Read uncommitted;</span><br></pre></td></tr></table></figure>\n\n<p>设置当前session以后所有事务的隔离级别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set session transaction isolation level Read uncommitted;</span><br></pre></td></tr></table></figure>\n\n<p>设置之后的所有session的隔离级别，不包括当前session</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set global transaction isolation level Read uncommitted;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-索引\"><a href=\"#4-3-索引\" class=\"headerlink\" title=\"4.3 索引\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#43-索引\" target=\"_blank\" rel=\"noopener\">4.3 索引</a></h3><h3 id=\"4-4-锁\"><a href=\"#4-4-锁\" class=\"headerlink\" title=\"4.4 锁\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#44-锁\" target=\"_blank\" rel=\"noopener\">4.4 锁</a></h3><h5 id=\"4-4-1-锁方案\"><a href=\"#4-4-1-锁方案\" class=\"headerlink\" title=\"4.4.1 锁方案\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#441-锁方案\" target=\"_blank\" rel=\"noopener\">4.4.1 锁方案</a></h5><ul>\n<li>一次封锁：可以避免大量并发情况下的死锁，前提条件是已知要在哪些数据加锁，不适合用在数据库事务中。</li>\n<li>两段锁：两段锁协议将事务分成两个阶段：加锁阶段和解锁阶段。在事务开始时加锁，事务结束后解锁。无法避免死锁，但能保证事务的串行化。</li>\n</ul>\n<h5 id=\"4-4-2-锁类型\"><a href=\"#4-4-2-锁类型\" class=\"headerlink\" title=\"4.4.2 锁类型\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#442-锁类型\" target=\"_blank\" rel=\"noopener\">4.4.2 锁类型</a></h5><ul>\n<li>表锁：对一整张表加锁，并发能力低下（即使有分读锁、写锁），一般在DDL处理时使用。</li>\n<li>行锁：只锁住特定行的数据，并发能力强，MySQL一般都是用行锁来处理并发事务。</li>\n<li>GAP锁（间隙锁）：是MySQL使用索引对行锁两边的区间进行加锁，避免其他事务在这两个区间insert的一种锁。</li>\n<li>Next-Key锁：Next-Key锁是行锁和GAP锁的合并（MySQL使用它来避免幻读）</li>\n<li>MVVC(多版本并发控制）：Innodb中的乐观锁实现。通过它提高MySQL的读取操作的性能。并能解决MySQL的重复读问题。</li>\n</ul>\n<h2 id=\"5-缓存\"><a href=\"#5-缓存\" class=\"headerlink\" title=\"5. 缓存\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#5-缓存\" target=\"_blank\" rel=\"noopener\">5. 缓存</a></h2><h3 id=\"5-1-缓存金字塔\"><a href=\"#5-1-缓存金字塔\" class=\"headerlink\" title=\"5.1 缓存金字塔\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#51-缓存金字塔\" target=\"_blank\" rel=\"noopener\">5.1 缓存金字塔</a></h3><p>从上到下速度由快到慢，容量由小到大</p>\n<ul>\n<li>寄存器</li>\n<li>L1缓存</li>\n<li>L2缓存、L3缓存</li>\n<li>系统缓存：缓存系统元数据和文件数据。</li>\n<li>内存缓存：redis、memcached等使用内存来保存数据的缓存</li>\n<li>磁盘缓存：交换分区、缓存文件等</li>\n<li>网络缓存：CDN等通过网络来访问的缓存</li>\n</ul>\n<h3 id=\"5-2-http请求的缓存过程\"><a href=\"#5-2-http请求的缓存过程\" class=\"headerlink\" title=\"5.2 http请求的缓存过程\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#52-http请求的缓存过程\" target=\"_blank\" rel=\"noopener\">5.2 http请求的缓存过程</a></h3><p>从上到下优先级从高到低</p>\n<ul>\n<li>浏览器内存缓存</li>\n<li>浏览器文件缓存</li>\n<li>浏览器DNS缓存</li>\n<li>CDN缓存</li>\n<li>nginx缓存</li>\n<li>web服务缓存</li>\n<li>redis缓存</li>\n<li>数据库缓存</li>\n</ul>\n<h2 id=\"6-web开发\"><a href=\"#6-web开发\" class=\"headerlink\" title=\"6. web开发\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#6-web开发\" target=\"_blank\" rel=\"noopener\">6. web开发</a></h2><ul>\n<li>http缓存</li>\n<li>http状态码</li>\n<li>web后端框架</li>\n<li>websocket建立过程</li>\n<li>http2基本原理</li>\n</ul>\n<h2 id=\"7-数据结构和算法\"><a href=\"#7-数据结构和算法\" class=\"headerlink\" title=\"7. 数据结构和算法\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#7-数据结构和算法\" target=\"_blank\" rel=\"noopener\">7. 数据结构和算法</a></h2><ul>\n<li>树操作：前序遍历、中序遍历、后序遍历；平衡二叉树调整子节点</li>\n<li>堆：TopN 问题</li>\n<li>数组：快排、归并</li>\n</ul>\n<h2 id=\"8-shell脚本\"><a href=\"#8-shell脚本\" class=\"headerlink\" title=\"8. shell脚本\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#8-shell脚本\" target=\"_blank\" rel=\"noopener\">8. shell脚本</a></h2><ul>\n<li>awk 输出第一列、第二列、最后一列，用一个空格隔开。</li>\n<li>逐行读取文件，在每行行首添加行号，用空格隔开</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-系统知识\"><a href=\"#1-系统知识\" class=\"headerlink\" title=\"1. 系统知识\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#1-系统知识\" target=\"_blank\" rel=\"noopener\">1. 系统知识</a></h2><p>系统知识主要用于评判候选人是否为资深软件工程师</p>","more":"<h3 id=\"1-1-网络\"><a href=\"#1-1-网络\" class=\"headerlink\" title=\"1.1 网络\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#11-网络\" target=\"_blank\" rel=\"noopener\">1.1 网络</a></h3><p>考察对象: 工作三年以上</p>\n<h5 id=\"1-1-1-网络七层模型\"><a href=\"#1-1-1-网络七层模型\" class=\"headerlink\" title=\"1.1.1 网络七层模型\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#111-网络七层模型\" target=\"_blank\" rel=\"noopener\">1.1.1 网络七层模型</a></h5><p>又称OSI 模型，从下到上分别为：</p>\n<ul>\n<li>物理层：底层数据传输，如网线；网卡标准。</li>\n<li>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</li>\n<li>网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</li>\n<li>传输层：端到端传输数据的基本功能；如 TCP、UDP。</li>\n<li>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</li>\n<li>标识层：数据格式标识，基本压缩加密功能。</li>\n<li>应用层：各种应用软件，包括 Web 应用。</li>\n</ul>\n<h5 id=\"1-1-2-网络四层模型\"><a href=\"#1-1-2-网络四层模型\" class=\"headerlink\" title=\"1.1.2 网络四层模型\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#112-网络四层模型\" target=\"_blank\" rel=\"noopener\">1.1.2 网络四层模型</a></h5><p>从下到上分别为：</p>\n<ul>\n<li>网络访问层：ARP、RARP等协议</li>\n<li>互联网层：ICMP、IP等协议</li>\n<li>传输层：TCP、UDP等协议</li>\n<li>应用层：DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS等协议</li>\n</ul>\n<h5 id=\"1-1-3-TCP、UDP、IP-协议\"><a href=\"#1-1-3-TCP、UDP、IP-协议\" class=\"headerlink\" title=\"1.1.3 TCP、UDP、IP 协议\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#113-tcpudpip-协议\" target=\"_blank\" rel=\"noopener\">1.1.3 TCP、UDP、IP 协议</a></h5><ul>\n<li>TCP与UDP的区别<ol>\n<li>TCP属于有状态的可靠连接，通过ack、拆包组包机制保障数据按照顺序传递，一旦建立好连接，路由路线是固定的；UDP本身是无状态的不可靠连接，没有固定的路由路线，优先选择速度快的路由路线，顺序靠应用程序自己保障。</li>\n<li>TCP是基于数据流的，对应用层来说没有固定包大小，在TCP内部会发生拆包组包；UDP是基于数据包的，对应用程序来说有固定大小，UDP内部不会发生拆包组包。但不管是TCP还是UDP，在IP层都有可能发生拆包组包。</li>\n</ol>\n</li>\n<li>TCP粘包问题<ol>\n<li>发送端需要等缓冲区满才发送出去，造成粘包（nalge算法也可能造成粘包现象），可以通过设置socket为 nodelay解决。</li>\n<li>接收方不及时接收缓冲区的包，造成多个包接收。应用程序对每个数据包添加包头来区分数据界限解决。</li>\n</ol>\n</li>\n<li>TCP拆包问题<ol>\n<li>发送的TCP报文大于TCP发送缓冲区剩余空间大小。</li>\n<li>缓冲区中待发送的数据大小大于MSS（最大报文长度） 拆包问题，可以通过压缩数据得到改善。</li>\n</ol>\n</li>\n<li>TCP快速重传、快速恢复、慢启动、滑动窗口<ol>\n<li>TCP使用滑动窗口机制进行拥塞控制，避免网络质量变差时ACK时间过长导致丢包以及网络质量变好时频繁的ACK导致网络速度无法提升。</li>\n<li>所谓的慢启动是指滑动窗口的调整是缓慢的调整，即使是网络质量很好的情况下，滑动窗口调整到合适大小也是需要一定时间。</li>\n<li>快速重传：接收方接收到无序的包时，会立即发送ACK给发送方请求重传缺失的包，如果发送方连续收到3个或者3个以上的重传ACK，那么就判定丢包了，立即重传丢失的包。</li>\n<li>快速恢复：丢包意味着网络环境变差，默认情况下TCP会恢复到慢启动来进行重传。快速恢复算法在收到3个重传ACK的时候判定网络环境质量并不差，决定不恢复到慢启动，直接重传丢失的包。</li>\n</ol>\n</li>\n<li>IP层拆包组包 当报文超过MTU（最大传输单元）大小时，将发生IP层的拆包组包。MTU由路由协商决定，取路由两端以太网帧大小中较小的值。</li>\n</ul>\n<h5 id=\"1-1-4-TCP端口快速回收与重用\"><a href=\"#1-1-4-TCP端口快速回收与重用\" class=\"headerlink\" title=\"1.1.4 TCP端口快速回收与重用\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#114-tcp端口快速回收与重用\" target=\"_blank\" rel=\"noopener\">1.1.4 TCP端口快速回收与重用</a></h5><p>由于http协议是短连接，请求完毕后会关闭连接，导致服务器频繁的建立、断开连接，而TCP的回收是有等待时间的，在高并发的http服务器上，我们需要对TCP连接进行调优。否则，容易出现大量time_wait状态的连接占用大量资源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭</span><br><span class=\"line\">net.ipv4.tcp_syncookies &#x3D; 1</span><br><span class=\"line\"># 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</span><br><span class=\"line\">net.ipv4.tcp_tw_reuse &#x3D; 1</span><br><span class=\"line\"># 开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class=\"line\">net.ipv4.tcp_tw_recycle &#x3D; 1</span><br><span class=\"line\"># 修改系統默认的TIMEOUT时间</span><br><span class=\"line\">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br><span class=\"line\">net.ipv4.tcp_timestamps &#x3D; 1</span><br></pre></td></tr></table></figure>\n\n<p>服务端程序监听端口的socket也可能会遇到回收慢的问题。服务因意外挂掉没及时关闭socket，导致重启时无法监听端口。可以在代码里设置socket的reuse参数</p>\n<h3 id=\"1-2-系统调用与函数调用\"><a href=\"#1-2-系统调用与函数调用\" class=\"headerlink\" title=\"1.2 系统调用与函数调用\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#12-系统调用与函数调用\" target=\"_blank\" rel=\"noopener\">1.2 系统调用与函数调用</a></h3><p>考察对象: 工作三年以上 附加考察点：应用程序地址空间的划分</p>\n<p>应用程序地址空间的最高1G的内存空间是内核态内存空间，其余的属于用户态内存空间。内核态内存空间主要用于系统调用时在内核态保存数据。</p>\n<h5 id=\"1-2-1-系统调用\"><a href=\"#1-2-1-系统调用\" class=\"headerlink\" title=\"1.2.1 系统调用\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#121-系统调用\" target=\"_blank\" rel=\"noopener\">1.2.1 系统调用</a></h5><p>系统调用是指通过软中断调用系统内核函数的过程。</p>\n<ul>\n<li>应用程序调用C函数库中的函数（GO例外，GO自己封装了系统库函数）</li>\n<li>C函数库中触发软中断 INT 0x80，把系统调用号放入 %eax 寄存器</li>\n<li>保存应用程序上下文到应用程序栈内存，主要是保存各种寄存器的值，其中最重要的是程序计数器（PC）和栈指针寄存器（SP）</li>\n<li>陷入内核态</li>\n<li>调用<code>copy_from_user</code>将参数从用户态内存复制到内核态内存</li>\n<li>调用内核函数</li>\n<li>调用<code>copy_to_user</code>将返回值从内核态内存复制到用户态内存</li>\n<li>返回用户态</li>\n<li>恢复应用程序上下文，并将PC所指内存地址的指令加载到指令寄存器（IP）</li>\n<li>继续执行应用程序</li>\n</ul>\n<h5 id=\"1-2-2-函数调用\"><a href=\"#1-2-2-函数调用\" class=\"headerlink\" title=\"1.2.2 函数调用\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#122-函数调用\" target=\"_blank\" rel=\"noopener\">1.2.2 函数调用</a></h5><p>函数调用是指给定特定参数调用函数功能并获取返回结果的过程。</p>\n<ul>\n<li>保存函数参数到函数栈帧</li>\n<li>保存函数调用完成后执行的下一条指令的地址到栈帧</li>\n<li>跳转到函数地址</li>\n<li>执行函数体</li>\n<li>将返回值保存到栈帧</li>\n<li>从栈帧加载下一条指令地址</li>\n<li>执行下一条指令</li>\n</ul>\n<h5 id=\"1-2-3-系统调用与函数调用的区别\"><a href=\"#1-2-3-系统调用与函数调用的区别\" class=\"headerlink\" title=\"1.2.3 系统调用与函数调用的区别\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#123-系统调用与函数调用的区别\" target=\"_blank\" rel=\"noopener\">1.2.3 系统调用与函数调用的区别</a></h5><ul>\n<li>函数调用不需要触发软中断</li>\n<li>函数调用不需要执行上下文切换</li>\n<li>系统调用是调用系统内核函数，函数调用是调用应用程序的函数</li>\n</ul>\n<h3 id=\"1-3-并发与并行\"><a href=\"#1-3-并发与并行\" class=\"headerlink\" title=\"1.3 并发与并行\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#13-并发与并行\" target=\"_blank\" rel=\"noopener\">1.3 并发与并行</a></h3><p>并发：某一时间段内处理多个任务的能力。 并行：某一时间点处理多个任务的能力。</p>\n<h5 id=\"1-3-1-并发\"><a href=\"#1-3-1-并发\" class=\"headerlink\" title=\"1.3.1 并发\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#131-并发\" target=\"_blank\" rel=\"noopener\">1.3.1 并发</a></h5><p>并发强调的是单个处理单元在单位时间内处理任务的能力。常见的并发场景有：</p>\n<ul>\n<li>单个CPU核单位时间内执行的任务（线程）数。如通过top查看到的load avrage在一定程度上反馈了CPU的并发数</li>\n<li>单个服务器单位时间内处理的请求数。如QPS这一指标一定程度上衡量了一台服务器的处理能力。</li>\n</ul>\n<h4 id=\"1-3-2-并行\"><a href=\"#1-3-2-并行\" class=\"headerlink\" title=\"1.3.2 并行\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#132-并行\" target=\"_blank\" rel=\"noopener\">1.3.2 并行</a></h4><p>并行强调的是整个系统某一时间点同时处理任务的能力。常见的并行场景有：</p>\n<ul>\n<li>CPU的指令流水线同时处理的指令数。如三级流水线表示整个流水线能同时处理三条指令：取指（加载指令）、预处理、执行。</li>\n<li>CORE I7 处理器4核8线程，能同时让8个线程在上面工作。</li>\n<li>一个拥有10个节点的集群，能同时处理至少10个网络请求。</li>\n</ul>\n<h4 id=\"1-3-3-多线程同步\"><a href=\"#1-3-3-多线程同步\" class=\"headerlink\" title=\"1.3.3 多线程同步\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#133-多线程同步\" target=\"_blank\" rel=\"noopener\">1.3.3 多线程同步</a></h4><p>原因：CPU内核有缓存，现代多核CPU缓存中寄存器、L1缓存是独占的，L2、L3缓存是多核共享。多线程不同步的原因本质上是CPU核之间缓存不同步、CPU缓存与内存不同步。 解决方案：1、加锁，强制同步CPU核之间的缓存，适合复杂数据类型。2、volatile关键字，禁止寄存器优化，适合简单数据类型（如整数），但只能降低概率，并不能保证原子性。3、原子操作，CPU利用内存屏障，在CPU对内容进行“读-修改-写”这一连续操作时，锁定内存总线，屏蔽其他的读写操作。内存屏障分为读屏障（load barrier）、写屏障（store barrier）、全屏障（full barrier）。读屏障是加在指令前强制让CPU缓存失效，直接从内存读取；写屏障是加在指令后强制将CPU缓存中的数据写入到内存。</p>\n<h2 id=\"2-架构能力\"><a href=\"#2-架构能力\" class=\"headerlink\" title=\"2. 架构能力\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#2-架构能力\" target=\"_blank\" rel=\"noopener\">2. 架构能力</a></h2><p>考察对象：工作五年以上 架构能力考察候选人软件架构方面的知识和能力。</p>\n<h3 id=\"2-1-分布式与集群\"><a href=\"#2-1-分布式与集群\" class=\"headerlink\" title=\"2.1 分布式与集群\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#21-分布式与集群\" target=\"_blank\" rel=\"noopener\">2.1 分布式与集群</a></h3><p>集群：多个处理相同任务的节点组成集群。 分布式：多个处理不同子任务的节点组成分布式系统。 分布式系统中往往涉及关键数据的同步，需要用到分布式锁。</p>\n<h5 id=\"2-1-1-分布式锁\"><a href=\"#2-1-1-分布式锁\" class=\"headerlink\" title=\"2.1.1 分布式锁\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#211-分布式锁\" target=\"_blank\" rel=\"noopener\">2.1.1 分布式锁</a></h5><p>分布式锁基本理论：CAP、悲观锁、乐观锁（CAS） CAP：任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。 CAS： compare and swap，比较并交换。在修改正式数据之前，先会把现有数据版本与修改前的数据版本比较：如果相等则执行修改操作；如果不相等则需要重新获取数据和版本并提交CAS请求。 悲观锁：假设所有操作都可能会修改数据，默认执行加锁操作，直到等待锁释放后才能加锁成功。相当于互斥锁。 乐观锁：假设所有操作中读操作远比写操作多，在修改数据之前检查条件，条件符合则执行修改操作，条件不符合则返回失败。</p>\n<p>常用的分布式锁主要有以下几种</p>\n<ul>\n<li><p>基于redis、memcached等缓存实现 redis的悲观锁： 加锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setnx test 1</span><br></pre></td></tr></table></figure>\n\n<p>，如果test已经存在，则返回0表示加锁失败。解锁</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">del test</span><br></pre></td></tr></table></figure>\n\n<p> redis的乐观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch</span><br><span class=\"line\">multi</span><br><span class=\"line\">set test 1</span><br><span class=\"line\">get test</span><br><span class=\"line\">exec</span><br><span class=\"line\">unwatch</span><br></pre></td></tr></table></figure>\n\n<p>判断get test的返回值是否为 set 的值来判断是否加锁成功</p>\n</li>\n<li><p>基于zookeeper、etcd等集群管理软件实现 etcd 的悲观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 创建一个key</span><br><span class=\"line\">2. 如果key不存在返回成功并执行第 5 步</span><br><span class=\"line\">3. 如果key存在则返回失败，需要watch这个key等待key被删除</span><br><span class=\"line\">4. 如果key被删除则重试第 1 步</span><br><span class=\"line\">5. 执行需要的操作</span><br></pre></td></tr></table></figure>\n\n<p>etcd 的乐观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 读取数据以及数据的版本号 ModifiedIndex</span><br><span class=\"line\">2. 修改数据时用ModifiedIndex作为数据的比较条件</span><br><span class=\"line\">3. 如果ModifiedIndex与现有数据的相同，则修改成功；否则修改失败，重试第 1 步</span><br></pre></td></tr></table></figure>\n\n<p>etcd v3 已经提供了lock和unlock的接口</p>\n</li>\n<li><p>基于mysql等数据库实现 悲观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM methodLock WHERE method_name&#x3D;xxx FOR UPDATE</span><br><span class=\"line\">UPDATE tb_stock SET number&#x3D;number-1</span><br></pre></td></tr></table></figure>\n\n<p>乐观锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update tb_stock set number&#x3D;number-1 where product_id&#x3D;xxx</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"2-2-微服务\"><a href=\"#2-2-微服务\" class=\"headerlink\" title=\"2.2 微服务\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#22-微服务\" target=\"_blank\" rel=\"noopener\">2.2 微服务</a></h3><ul>\n<li>SOA：服务注册与发现、配置管理 ETCD、zookeeper的用法</li>\n<li>RPC：微服务调用 thrift、protobuf、grpc的原理和用法</li>\n<li>MQ：异步调用、日志收集 rabbitmq、kafka的架构和用法</li>\n<li>容器：服务调度和治理 docker、kubernetes的原理和用法</li>\n</ul>\n<h2 id=\"3-编程语言\"><a href=\"#3-编程语言\" class=\"headerlink\" title=\"3. 编程语言\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#3-编程语言\" target=\"_blank\" rel=\"noopener\">3. 编程语言</a></h2><h3 id=\"3-1-PHP\"><a href=\"#3-1-PHP\" class=\"headerlink\" title=\"3.1 PHP\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#31-php\" target=\"_blank\" rel=\"noopener\">3.1 PHP</a></h3><h3 id=\"3-2-Golang\"><a href=\"#3-2-Golang\" class=\"headerlink\" title=\"3.2 Golang\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#32-golang\" target=\"_blank\" rel=\"noopener\">3.2 Golang</a></h3><p>考察点：</p>\n<ul>\n<li>go调度器模型</li>\n<li>channel的各种用法</li>\n<li>goroutine的各种用法</li>\n<li>interface的各种用法</li>\n<li>sync包的用法</li>\n<li>time包定时器的用法</li>\n<li>context包用法和实现原理</li>\n</ul>\n<h5 id=\"3-2-1-Golang的调度器模型\"><a href=\"#3-2-1-Golang的调度器模型\" class=\"headerlink\" title=\"3.2.1 Golang的调度器模型\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#321-golang的调度器模型\" target=\"_blank\" rel=\"noopener\">3.2.1 Golang的调度器模型</a></h5><p>用这个知识点来初步判断候选人是否真的对golang感兴趣并了解过golang</p>\n<h5 id=\"3-2-2-channel\"><a href=\"#3-2-2-channel\" class=\"headerlink\" title=\"3.2.2 channel\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#322-channel\" target=\"_blank\" rel=\"noopener\">3.2.2 channel</a></h5><p><strong>种类</strong></p>\n<ul>\n<li>nil 值为nil的channel，读写都会block。主要用于select的时候将close掉的channel置为nil，防止触发相应case。</li>\n<li>无缓冲 读写都会block，读操作在写操作之前完成。一般用于同步通知。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch :&#x3D; make(chan struct&#123;&#125;)</span><br><span class=\"line\">go func()&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;do something</span><br><span class=\"line\">    close(ch)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\">&#x2F;&#x2F;wait goroutine finish</span><br><span class=\"line\">&lt;- ch</span><br><span class=\"line\">&#x2F;&#x2F;do something</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>单缓冲 无数据时，读操作block；有数据时，写操作block。用于保证数据有序传递并且限制接收端的最大速度。</li>\n<li>多缓冲 只要缓冲区有数据，读操作不会被block；即使有数据，只要缓冲区有空间，写操作不会被block。可以保证数据有序传递，但无法限制接收端的最大速度，只能限制接收端的平均速度。</li>\n</ul>\n<h5 id=\"3-2-3-goroutine\"><a href=\"#3-2-3-goroutine\" class=\"headerlink\" title=\"3.2.3 goroutine\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#323-goroutine\" target=\"_blank\" rel=\"noopener\">3.2.3 goroutine</a></h5><h2 id=\"4-数据库\"><a href=\"#4-数据库\" class=\"headerlink\" title=\"4. 数据库\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#4-数据库\" target=\"_blank\" rel=\"noopener\">4. 数据库</a></h2><h3 id=\"4-1-关联查询\"><a href=\"#4-1-关联查询\" class=\"headerlink\" title=\"4.1 关联查询\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#41-关联查询\" target=\"_blank\" rel=\"noopener\">4.1 关联查询</a></h3><ul>\n<li>内联结：将两个表中存在联结关系的字段符合联结关系的那些记录形成记录集的联结。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT A.Name B.Hobby FROM A, B WHERE A.id &#x3D; B.id</span><br><span class=\"line\">或者</span><br><span class=\"line\">SELECT A.Name FROM A INNER JOIN B ON A.id &#x3D; B.id</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>外联结：分为外左联结和外右联结。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT A.Name FROM A LEFT JOIN B ON A.id &#x3D; B.id</span><br><span class=\"line\">或者</span><br><span class=\"line\">SELECT A.Name FROM B RIGHT JOIN A ON A.id &#x3D; B.id</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全联结：将两个表中存在联结关系的字段的所有记录取出形成记录集的联结。 mysql本身没有实现全联结，可以使用<code>左连接 union 右连接</code>来实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT L.*,r.* FROM left_table L LEFT JOIN right_table r on L.age&#x3D;r.age UNION</span><br><span class=\"line\">SELECT L.*,r.* FROM left_table L RIGHT JOIN right_table r on L.age&#x3D;r.age</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>无联结：没有使用联结功能，也有自联结的说法。</li>\n</ul>\n<p>假如要取两个用户共同评论过的商品详情，如何写SQL语句？</p>\n<h3 id=\"4-2-事务\"><a href=\"#4-2-事务\" class=\"headerlink\" title=\"4.2 事务\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#42-事务\" target=\"_blank\" rel=\"noopener\">4.2 事务</a></h3><h5 id=\"4-2-1-ACID特性\"><a href=\"#4-2-1-ACID特性\" class=\"headerlink\" title=\"4.2.1 ACID特性\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#421-acid特性\" target=\"_blank\" rel=\"noopener\">4.2.1 ACID特性</a></h5><ul>\n<li>原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li>\n<li>一致性（Consistency） 一致性是指事务必须使数据库从一个一致的状态变到另外一个一致的状态，也就是执行事务之前和之后的状态都必须处于一致的状态。</li>\n<li>隔离性(Isolation) 隔离性是指当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离</li>\n<li>持久性(Durability) 持久性是指一个事务一旦被提交了，那么对于数据库中的数据改变就是永久性的，即便是在数据库系统遭遇到故障的情况下也不会丢失提交事务的操作。</li>\n</ul>\n<h5 id=\"4-2-2-事务的使用\"><a href=\"#4-2-2-事务的使用\" class=\"headerlink\" title=\"4.2.2 事务的使用\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#422-事务的使用\" target=\"_blank\" rel=\"noopener\">4.2.2 事务的使用</a></h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set autocommit &#x3D; 0;</span><br><span class=\"line\">start transaction;</span><br><span class=\"line\">update accout set money&#x3D;money+100 where name&#x3D;&quot;Jason&quot;;</span><br><span class=\"line\">commit;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-2-3-事务的回滚\"><a href=\"#4-2-3-事务的回滚\" class=\"headerlink\" title=\"4.2.3 事务的回滚\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#423-事务的回滚\" target=\"_blank\" rel=\"noopener\">4.2.3 事务的回滚</a></h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set autocommit &#x3D; 0;</span><br><span class=\"line\">start transaction;</span><br><span class=\"line\">update account set money&#x3D;money-100 where name&#x3D;&quot;justin&quot;;</span><br><span class=\"line\">rollback;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"4-4-4-事务隔离级别\"><a href=\"#4-4-4-事务隔离级别\" class=\"headerlink\" title=\"4.4.4 事务隔离级别\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#444-事务隔离级别\" target=\"_blank\" rel=\"noopener\">4.4.4 事务隔离级别</a></h5><p>查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select @@tx_isolation;</span><br></pre></td></tr></table></figure>\n\n<p>设置当前session的下一个事务的隔离级别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set transaction isolation level Read uncommitted;</span><br></pre></td></tr></table></figure>\n\n<p>设置当前session以后所有事务的隔离级别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set session transaction isolation level Read uncommitted;</span><br></pre></td></tr></table></figure>\n\n<p>设置之后的所有session的隔离级别，不包括当前session</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set global transaction isolation level Read uncommitted;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-索引\"><a href=\"#4-3-索引\" class=\"headerlink\" title=\"4.3 索引\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#43-索引\" target=\"_blank\" rel=\"noopener\">4.3 索引</a></h3><h3 id=\"4-4-锁\"><a href=\"#4-4-锁\" class=\"headerlink\" title=\"4.4 锁\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#44-锁\" target=\"_blank\" rel=\"noopener\">4.4 锁</a></h3><h5 id=\"4-4-1-锁方案\"><a href=\"#4-4-1-锁方案\" class=\"headerlink\" title=\"4.4.1 锁方案\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#441-锁方案\" target=\"_blank\" rel=\"noopener\">4.4.1 锁方案</a></h5><ul>\n<li>一次封锁：可以避免大量并发情况下的死锁，前提条件是已知要在哪些数据加锁，不适合用在数据库事务中。</li>\n<li>两段锁：两段锁协议将事务分成两个阶段：加锁阶段和解锁阶段。在事务开始时加锁，事务结束后解锁。无法避免死锁，但能保证事务的串行化。</li>\n</ul>\n<h5 id=\"4-4-2-锁类型\"><a href=\"#4-4-2-锁类型\" class=\"headerlink\" title=\"4.4.2 锁类型\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#442-锁类型\" target=\"_blank\" rel=\"noopener\">4.4.2 锁类型</a></h5><ul>\n<li>表锁：对一整张表加锁，并发能力低下（即使有分读锁、写锁），一般在DDL处理时使用。</li>\n<li>行锁：只锁住特定行的数据，并发能力强，MySQL一般都是用行锁来处理并发事务。</li>\n<li>GAP锁（间隙锁）：是MySQL使用索引对行锁两边的区间进行加锁，避免其他事务在这两个区间insert的一种锁。</li>\n<li>Next-Key锁：Next-Key锁是行锁和GAP锁的合并（MySQL使用它来避免幻读）</li>\n<li>MVVC(多版本并发控制）：Innodb中的乐观锁实现。通过它提高MySQL的读取操作的性能。并能解决MySQL的重复读问题。</li>\n</ul>\n<h2 id=\"5-缓存\"><a href=\"#5-缓存\" class=\"headerlink\" title=\"5. 缓存\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#5-缓存\" target=\"_blank\" rel=\"noopener\">5. 缓存</a></h2><h3 id=\"5-1-缓存金字塔\"><a href=\"#5-1-缓存金字塔\" class=\"headerlink\" title=\"5.1 缓存金字塔\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#51-缓存金字塔\" target=\"_blank\" rel=\"noopener\">5.1 缓存金字塔</a></h3><p>从上到下速度由快到慢，容量由小到大</p>\n<ul>\n<li>寄存器</li>\n<li>L1缓存</li>\n<li>L2缓存、L3缓存</li>\n<li>系统缓存：缓存系统元数据和文件数据。</li>\n<li>内存缓存：redis、memcached等使用内存来保存数据的缓存</li>\n<li>磁盘缓存：交换分区、缓存文件等</li>\n<li>网络缓存：CDN等通过网络来访问的缓存</li>\n</ul>\n<h3 id=\"5-2-http请求的缓存过程\"><a href=\"#5-2-http请求的缓存过程\" class=\"headerlink\" title=\"5.2 http请求的缓存过程\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#52-http请求的缓存过程\" target=\"_blank\" rel=\"noopener\">5.2 http请求的缓存过程</a></h3><p>从上到下优先级从高到低</p>\n<ul>\n<li>浏览器内存缓存</li>\n<li>浏览器文件缓存</li>\n<li>浏览器DNS缓存</li>\n<li>CDN缓存</li>\n<li>nginx缓存</li>\n<li>web服务缓存</li>\n<li>redis缓存</li>\n<li>数据库缓存</li>\n</ul>\n<h2 id=\"6-web开发\"><a href=\"#6-web开发\" class=\"headerlink\" title=\"6. web开发\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#6-web开发\" target=\"_blank\" rel=\"noopener\">6. web开发</a></h2><ul>\n<li>http缓存</li>\n<li>http状态码</li>\n<li>web后端框架</li>\n<li>websocket建立过程</li>\n<li>http2基本原理</li>\n</ul>\n<h2 id=\"7-数据结构和算法\"><a href=\"#7-数据结构和算法\" class=\"headerlink\" title=\"7. 数据结构和算法\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#7-数据结构和算法\" target=\"_blank\" rel=\"noopener\">7. 数据结构和算法</a></h2><ul>\n<li>树操作：前序遍历、中序遍历、后序遍历；平衡二叉树调整子节点</li>\n<li>堆：TopN 问题</li>\n<li>数组：快排、归并</li>\n</ul>\n<h2 id=\"8-shell脚本\"><a href=\"#8-shell脚本\" class=\"headerlink\" title=\"8. shell脚本\"></a><a href=\"https://wiki.n.miui.com/pages/viewpage.action?pageId=115214950#8-shell脚本\" target=\"_blank\" rel=\"noopener\">8. shell脚本</a></h2><ul>\n<li>awk 输出第一列、第二列、最后一列，用一个空格隔开。</li>\n<li>逐行读取文件，在每行行首添加行号，用空格隔开</li>\n</ul>"},{"_content":"## 基本的研究框架\n\n一般常见的研究框架包括以下这些：\n\n产品\n\n这个行业的主要产品是什么？\n\n产品的主要形态是什么？\n\n满足了用户哪一方面的需求？\n\n产品的替代品包括什么？\n\n产品的关键技术是哪一项？\n\n产品的成本结构如何？\n\n市场\n\n公司的市场定位？\n\n公司的主要用户？\n\n市场空间有多大？\n\n近几年的市场增长率有多高？\n\n预计未来几年的市场增速如何？\n\n市场的主要玩家是谁？\n\n行业概括\n\n基本的行业术语\n\n行业的发展历程和变迁\n\n行业的监管情况和主要政策是什么？\n\n行业发展的有利因素和不利因素\n\n行业发展的瓶颈\n\n行业目前所处的周期\n\n行业的供应链情况\n\n用PESTEL模型分析，这个行业如何？（PESTEL模型如下）\n\n*P*：政治因素，是否是公有设施行业？是否受到政策和监控的严控？如房地产\n\n*E*：经济因素，哪些经济因素影响了这个行业的发展？如奢侈品\n\n*S*：社会因素，社会风俗和思想开放程度对这个行业有多大的影响？如医美\n\n*T*：技术因素，技术是如何影响这个行业的？如手机\n\n*E*：环境因素，环保政策和环保理念如何影响行业发展？如新能源汽车\n\n*L*：法律因素，某些法律法规的出台对行业的影响，如广告法影响自媒体等。\n\n竞争\n\n行业的竞争情况如何，是完全竞争？寡头垄断？还是寡头竞争？\n\n业内几个主要玩家的盈利模式分别是怎样的？\n\n在竞争胜出的关键行业因素是什么？\n\n该行业是否受到海外竞争的压力","source":"_posts/商业/行业调研步骤.md","raw":"## 基本的研究框架\n\n一般常见的研究框架包括以下这些：\n\n产品\n\n这个行业的主要产品是什么？\n\n产品的主要形态是什么？\n\n满足了用户哪一方面的需求？\n\n产品的替代品包括什么？\n\n产品的关键技术是哪一项？\n\n产品的成本结构如何？\n\n市场\n\n公司的市场定位？\n\n公司的主要用户？\n\n市场空间有多大？\n\n近几年的市场增长率有多高？\n\n预计未来几年的市场增速如何？\n\n市场的主要玩家是谁？\n\n行业概括\n\n基本的行业术语\n\n行业的发展历程和变迁\n\n行业的监管情况和主要政策是什么？\n\n行业发展的有利因素和不利因素\n\n行业发展的瓶颈\n\n行业目前所处的周期\n\n行业的供应链情况\n\n用PESTEL模型分析，这个行业如何？（PESTEL模型如下）\n\n*P*：政治因素，是否是公有设施行业？是否受到政策和监控的严控？如房地产\n\n*E*：经济因素，哪些经济因素影响了这个行业的发展？如奢侈品\n\n*S*：社会因素，社会风俗和思想开放程度对这个行业有多大的影响？如医美\n\n*T*：技术因素，技术是如何影响这个行业的？如手机\n\n*E*：环境因素，环保政策和环保理念如何影响行业发展？如新能源汽车\n\n*L*：法律因素，某些法律法规的出台对行业的影响，如广告法影响自媒体等。\n\n竞争\n\n行业的竞争情况如何，是完全竞争？寡头垄断？还是寡头竞争？\n\n业内几个主要玩家的盈利模式分别是怎样的？\n\n在竞争胜出的关键行业因素是什么？\n\n该行业是否受到海外竞争的压力","slug":"商业/行业调研步骤","published":1,"date":"2020-11-21T19:01:39.676Z","updated":"2020-11-21T19:01:39.677Z","title":"商业/行业调研步骤","comments":1,"layout":"post","photos":[],"link":"","_id":"ckppj72n80000i1gicyjk9p00","content":"<h2 id=\"基本的研究框架\"><a href=\"#基本的研究框架\" class=\"headerlink\" title=\"基本的研究框架\"></a>基本的研究框架</h2><p>一般常见的研究框架包括以下这些：</p>\n<p>产品</p>\n<p>这个行业的主要产品是什么？</p>\n<p>产品的主要形态是什么？</p>\n<p>满足了用户哪一方面的需求？</p>\n<p>产品的替代品包括什么？</p>\n<p>产品的关键技术是哪一项？</p>\n<p>产品的成本结构如何？</p>\n<p>市场</p>\n<p>公司的市场定位？</p>\n<p>公司的主要用户？</p>\n<p>市场空间有多大？</p>\n<p>近几年的市场增长率有多高？</p>\n<p>预计未来几年的市场增速如何？</p>\n<p>市场的主要玩家是谁？</p>\n<p>行业概括</p>\n<p>基本的行业术语</p>\n<p>行业的发展历程和变迁</p>\n<p>行业的监管情况和主要政策是什么？</p>\n<p>行业发展的有利因素和不利因素</p>\n<p>行业发展的瓶颈</p>\n<p>行业目前所处的周期</p>\n<p>行业的供应链情况</p>\n<p>用PESTEL模型分析，这个行业如何？（PESTEL模型如下）</p>\n<p><em>P</em>：政治因素，是否是公有设施行业？是否受到政策和监控的严控？如房地产</p>\n<p><em>E</em>：经济因素，哪些经济因素影响了这个行业的发展？如奢侈品</p>\n<p><em>S</em>：社会因素，社会风俗和思想开放程度对这个行业有多大的影响？如医美</p>\n<p><em>T</em>：技术因素，技术是如何影响这个行业的？如手机</p>\n<p><em>E</em>：环境因素，环保政策和环保理念如何影响行业发展？如新能源汽车</p>\n<p><em>L</em>：法律因素，某些法律法规的出台对行业的影响，如广告法影响自媒体等。</p>\n<p>竞争</p>\n<p>行业的竞争情况如何，是完全竞争？寡头垄断？还是寡头竞争？</p>\n<p>业内几个主要玩家的盈利模式分别是怎样的？</p>\n<p>在竞争胜出的关键行业因素是什么？</p>\n<p>该行业是否受到海外竞争的压力</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本的研究框架\"><a href=\"#基本的研究框架\" class=\"headerlink\" title=\"基本的研究框架\"></a>基本的研究框架</h2><p>一般常见的研究框架包括以下这些：</p>\n<p>产品</p>\n<p>这个行业的主要产品是什么？</p>\n<p>产品的主要形态是什么？</p>\n<p>满足了用户哪一方面的需求？</p>\n<p>产品的替代品包括什么？</p>\n<p>产品的关键技术是哪一项？</p>\n<p>产品的成本结构如何？</p>\n<p>市场</p>\n<p>公司的市场定位？</p>\n<p>公司的主要用户？</p>\n<p>市场空间有多大？</p>\n<p>近几年的市场增长率有多高？</p>\n<p>预计未来几年的市场增速如何？</p>\n<p>市场的主要玩家是谁？</p>\n<p>行业概括</p>\n<p>基本的行业术语</p>\n<p>行业的发展历程和变迁</p>\n<p>行业的监管情况和主要政策是什么？</p>\n<p>行业发展的有利因素和不利因素</p>\n<p>行业发展的瓶颈</p>\n<p>行业目前所处的周期</p>\n<p>行业的供应链情况</p>\n<p>用PESTEL模型分析，这个行业如何？（PESTEL模型如下）</p>\n<p><em>P</em>：政治因素，是否是公有设施行业？是否受到政策和监控的严控？如房地产</p>\n<p><em>E</em>：经济因素，哪些经济因素影响了这个行业的发展？如奢侈品</p>\n<p><em>S</em>：社会因素，社会风俗和思想开放程度对这个行业有多大的影响？如医美</p>\n<p><em>T</em>：技术因素，技术是如何影响这个行业的？如手机</p>\n<p><em>E</em>：环境因素，环保政策和环保理念如何影响行业发展？如新能源汽车</p>\n<p><em>L</em>：法律因素，某些法律法规的出台对行业的影响，如广告法影响自媒体等。</p>\n<p>竞争</p>\n<p>行业的竞争情况如何，是完全竞争？寡头垄断？还是寡头竞争？</p>\n<p>业内几个主要玩家的盈利模式分别是怎样的？</p>\n<p>在竞争胜出的关键行业因素是什么？</p>\n<p>该行业是否受到海外竞争的压力</p>\n"},{"title":"搭建一个hexo博客","date":"2020-01-20T06:51:25.000Z","_content":"\n> 一直有一个搭建一个自己的博客的想法，刚好趁着有时间，一边整理，一边更新博客，因此就把博客搭起来了。 采用的是流行的hexo，部署在本地，当然部署也很简单，所以迁移的时候就节省了大量成本，其次就是文档，文档跟我的另外一些文档放在一起。\n\n<!-- more -->\n\n### 安装步骤\n\n```bash\n# 安装node\n$ brew install node\n$ node -v\n$ cd code\n# 安装 hexo\n$ sudo npm i hexo-cli -g\n$ hexo -v\n# 初始化文件夹\n$ hexo init blog\n$ cd blog\n# 安装相关的文件\n$ npm install\n$ npm install hexo-deployer-git --save\n# 配置github的相关信息\n$ vim _config.yml\n# 软链博客文件夹到本地\n$ ln -sv ~/博客 ~/code/blog/source/_posts\n# 修改定时脚本\n$ vim auto.sh\n```\n\n### 主题安装\n\n```bash\n# 使用indigo主题，文档如下\n# https://github.com/yscoder/hexo-theme-indigo/wiki/\n# 主题默认使用 less 作为 css 预处理工具\n$ npm install hexo-renderer-less --save\n# 生成rss\n$ npm install hexo-generator-feed --save\n# 生成搜索\n$ npm install hexo-generator-json-content --save\n# 生成微信分享二维码\n$ npm install hexo-helper-qrcode --save\n\n```\n\n\n\n### hexo常用的命令\n\n``` bash\n# 新建帖子\n$ hexo new \"My New Post\"\n# 启动本地服务器\n$ hexo server\n$ hexo s\n# 生成文件\n$ hexo generate\n$ hexo g\n# 部署到git上\n$ hexo deploy \n$ hexo d\n# 初始化项目框架\n$ hexo init <项目名>\n```\n\n\n\n### 新建post的规则\n\n```\ntitle: 搭建一个hexo博客\ndate: 2020-01-20 14:51:25\ncategories: \n- web前端\ntags:\n- node\n- hero\n```\n\n------","source":"_posts/黑科技/hexo.md","raw":"---\ntitle: 搭建一个hexo博客\ndate: 2020-01-20 14:51:25\ntags:\n- node\n- hexo\ncategories:\n- 应用安装&破解\n---\n\n> 一直有一个搭建一个自己的博客的想法，刚好趁着有时间，一边整理，一边更新博客，因此就把博客搭起来了。 采用的是流行的hexo，部署在本地，当然部署也很简单，所以迁移的时候就节省了大量成本，其次就是文档，文档跟我的另外一些文档放在一起。\n\n<!-- more -->\n\n### 安装步骤\n\n```bash\n# 安装node\n$ brew install node\n$ node -v\n$ cd code\n# 安装 hexo\n$ sudo npm i hexo-cli -g\n$ hexo -v\n# 初始化文件夹\n$ hexo init blog\n$ cd blog\n# 安装相关的文件\n$ npm install\n$ npm install hexo-deployer-git --save\n# 配置github的相关信息\n$ vim _config.yml\n# 软链博客文件夹到本地\n$ ln -sv ~/博客 ~/code/blog/source/_posts\n# 修改定时脚本\n$ vim auto.sh\n```\n\n### 主题安装\n\n```bash\n# 使用indigo主题，文档如下\n# https://github.com/yscoder/hexo-theme-indigo/wiki/\n# 主题默认使用 less 作为 css 预处理工具\n$ npm install hexo-renderer-less --save\n# 生成rss\n$ npm install hexo-generator-feed --save\n# 生成搜索\n$ npm install hexo-generator-json-content --save\n# 生成微信分享二维码\n$ npm install hexo-helper-qrcode --save\n\n```\n\n\n\n### hexo常用的命令\n\n``` bash\n# 新建帖子\n$ hexo new \"My New Post\"\n# 启动本地服务器\n$ hexo server\n$ hexo s\n# 生成文件\n$ hexo generate\n$ hexo g\n# 部署到git上\n$ hexo deploy \n$ hexo d\n# 初始化项目框架\n$ hexo init <项目名>\n```\n\n\n\n### 新建post的规则\n\n```\ntitle: 搭建一个hexo博客\ndate: 2020-01-20 14:51:25\ncategories: \n- web前端\ntags:\n- node\n- hero\n```\n\n------","slug":"黑科技/hexo","published":1,"updated":"2020-07-15T19:04:45.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckppj72nc0001i1gie66rhi8w","content":"<blockquote>\n<p>一直有一个搭建一个自己的博客的想法，刚好趁着有时间，一边整理，一边更新博客，因此就把博客搭起来了。 采用的是流行的hexo，部署在本地，当然部署也很简单，所以迁移的时候就节省了大量成本，其次就是文档，文档跟我的另外一些文档放在一起。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装node</span></span><br><span class=\"line\">$ brew install node</span><br><span class=\"line\">$ node -v</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> code</span><br><span class=\"line\"><span class=\"comment\"># 安装 hexo</span></span><br><span class=\"line\">$ sudo npm i hexo-cli -g</span><br><span class=\"line\">$ hexo -v</span><br><span class=\"line\"><span class=\"comment\"># 初始化文件夹</span></span><br><span class=\"line\">$ hexo init blog</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> blog</span><br><span class=\"line\"><span class=\"comment\"># 安装相关的文件</span></span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\"><span class=\"comment\"># 配置github的相关信息</span></span><br><span class=\"line\">$ vim _config.yml</span><br><span class=\"line\"><span class=\"comment\"># 软链博客文件夹到本地</span></span><br><span class=\"line\">$ ln -sv ~/博客 ~/code/blog/<span class=\"built_in\">source</span>/_posts</span><br><span class=\"line\"><span class=\"comment\"># 修改定时脚本</span></span><br><span class=\"line\">$ vim auto.sh</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"主题安装\"><a href=\"#主题安装\" class=\"headerlink\" title=\"主题安装\"></a>主题安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用indigo主题，文档如下</span></span><br><span class=\"line\"><span class=\"comment\"># https://github.com/yscoder/hexo-theme-indigo/wiki/</span></span><br><span class=\"line\"><span class=\"comment\"># 主题默认使用 less 作为 css 预处理工具</span></span><br><span class=\"line\">$ npm install hexo-renderer-less --save</span><br><span class=\"line\"><span class=\"comment\"># 生成rss</span></span><br><span class=\"line\">$ npm install hexo-generator-feed --save</span><br><span class=\"line\"><span class=\"comment\"># 生成搜索</span></span><br><span class=\"line\">$ npm install hexo-generator-json-content --save</span><br><span class=\"line\"><span class=\"comment\"># 生成微信分享二维码</span></span><br><span class=\"line\">$ npm install hexo-helper-qrcode --save</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"hexo常用的命令\"><a href=\"#hexo常用的命令\" class=\"headerlink\" title=\"hexo常用的命令\"></a>hexo常用的命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建帖子</span></span><br><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br><span class=\"line\"><span class=\"comment\"># 启动本地服务器</span></span><br><span class=\"line\">$ hexo server</span><br><span class=\"line\">$ hexo s</span><br><span class=\"line\"><span class=\"comment\"># 生成文件</span></span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\"><span class=\"comment\"># 部署到git上</span></span><br><span class=\"line\">$ hexo deploy </span><br><span class=\"line\">$ hexo d</span><br><span class=\"line\"><span class=\"comment\"># 初始化项目框架</span></span><br><span class=\"line\">$ hexo init &lt;项目名&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"新建post的规则\"><a href=\"#新建post的规则\" class=\"headerlink\" title=\"新建post的规则\"></a>新建post的规则</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 搭建一个hexo博客</span><br><span class=\"line\">date: 2020-01-20 14:51:25</span><br><span class=\"line\">categories: </span><br><span class=\"line\">- web前端</span><br><span class=\"line\">tags:</span><br><span class=\"line\">- node</span><br><span class=\"line\">- hero</span><br></pre></td></tr></table></figure>\n\n<hr>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>一直有一个搭建一个自己的博客的想法，刚好趁着有时间，一边整理，一边更新博客，因此就把博客搭起来了。 采用的是流行的hexo，部署在本地，当然部署也很简单，所以迁移的时候就节省了大量成本，其次就是文档，文档跟我的另外一些文档放在一起。</p>\n</blockquote>","more":"<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装node</span></span><br><span class=\"line\">$ brew install node</span><br><span class=\"line\">$ node -v</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> code</span><br><span class=\"line\"><span class=\"comment\"># 安装 hexo</span></span><br><span class=\"line\">$ sudo npm i hexo-cli -g</span><br><span class=\"line\">$ hexo -v</span><br><span class=\"line\"><span class=\"comment\"># 初始化文件夹</span></span><br><span class=\"line\">$ hexo init blog</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> blog</span><br><span class=\"line\"><span class=\"comment\"># 安装相关的文件</span></span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\"><span class=\"comment\"># 配置github的相关信息</span></span><br><span class=\"line\">$ vim _config.yml</span><br><span class=\"line\"><span class=\"comment\"># 软链博客文件夹到本地</span></span><br><span class=\"line\">$ ln -sv ~/博客 ~/code/blog/<span class=\"built_in\">source</span>/_posts</span><br><span class=\"line\"><span class=\"comment\"># 修改定时脚本</span></span><br><span class=\"line\">$ vim auto.sh</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"主题安装\"><a href=\"#主题安装\" class=\"headerlink\" title=\"主题安装\"></a>主题安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用indigo主题，文档如下</span></span><br><span class=\"line\"><span class=\"comment\"># https://github.com/yscoder/hexo-theme-indigo/wiki/</span></span><br><span class=\"line\"><span class=\"comment\"># 主题默认使用 less 作为 css 预处理工具</span></span><br><span class=\"line\">$ npm install hexo-renderer-less --save</span><br><span class=\"line\"><span class=\"comment\"># 生成rss</span></span><br><span class=\"line\">$ npm install hexo-generator-feed --save</span><br><span class=\"line\"><span class=\"comment\"># 生成搜索</span></span><br><span class=\"line\">$ npm install hexo-generator-json-content --save</span><br><span class=\"line\"><span class=\"comment\"># 生成微信分享二维码</span></span><br><span class=\"line\">$ npm install hexo-helper-qrcode --save</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"hexo常用的命令\"><a href=\"#hexo常用的命令\" class=\"headerlink\" title=\"hexo常用的命令\"></a>hexo常用的命令</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 新建帖子</span></span><br><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br><span class=\"line\"><span class=\"comment\"># 启动本地服务器</span></span><br><span class=\"line\">$ hexo server</span><br><span class=\"line\">$ hexo s</span><br><span class=\"line\"><span class=\"comment\"># 生成文件</span></span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo g</span><br><span class=\"line\"><span class=\"comment\"># 部署到git上</span></span><br><span class=\"line\">$ hexo deploy </span><br><span class=\"line\">$ hexo d</span><br><span class=\"line\"><span class=\"comment\"># 初始化项目框架</span></span><br><span class=\"line\">$ hexo init &lt;项目名&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"新建post的规则\"><a href=\"#新建post的规则\" class=\"headerlink\" title=\"新建post的规则\"></a>新建post的规则</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: 搭建一个hexo博客</span><br><span class=\"line\">date: 2020-01-20 14:51:25</span><br><span class=\"line\">categories: </span><br><span class=\"line\">- web前端</span><br><span class=\"line\">tags:</span><br><span class=\"line\">- node</span><br><span class=\"line\">- hero</span><br></pre></td></tr></table></figure>\n\n<hr>"},{"title":"python一行命令创建http服务器","date":"2020-01-20T06:51:25.000Z","_content":"\n\n\n>Python 创建服务器仅需一条命令\n\n<!-- more -->\n\n对于Python 2，简单搭建Web服务器，只需在需要搭建Web服务器的目录（如C:/ 或 /home/klchang/）下，输入如下命令：\n\n```shell\npython -m SimpleHTTPServer 8080\n```\n\n含义为使用 8080端口的创建Web服务器，可以使用浏览器 http://127.0.0.1:8080 或 将 127.0.0.1 替换为本机的外部IP地址，进行访问。\n\n \n\n对于Python 3，其创建Web服务器的等价命令，如下：\n\n```bash\npython3 -m http.server 8080\n```\n\n \n\n","source":"_posts/黑科技/python一行创建http服务器.md","raw":"---\ntitle: python一行命令创建http服务器\ndate: 2020-01-20 14:51:25\ntags:\n- python\ncategories:\n- 极客操作\n---\n\n\n\n>Python 创建服务器仅需一条命令\n\n<!-- more -->\n\n对于Python 2，简单搭建Web服务器，只需在需要搭建Web服务器的目录（如C:/ 或 /home/klchang/）下，输入如下命令：\n\n```shell\npython -m SimpleHTTPServer 8080\n```\n\n含义为使用 8080端口的创建Web服务器，可以使用浏览器 http://127.0.0.1:8080 或 将 127.0.0.1 替换为本机的外部IP地址，进行访问。\n\n \n\n对于Python 3，其创建Web服务器的等价命令，如下：\n\n```bash\npython3 -m http.server 8080\n```\n\n \n\n","slug":"黑科技/python一行创建http服务器","published":1,"updated":"2020-07-15T19:04:45.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckppj72nf0002i1gi5ba448v9","content":"<blockquote>\n<p>Python 创建服务器仅需一条命令</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p>对于Python 2，简单搭建Web服务器，只需在需要搭建Web服务器的目录（如C:/ 或 /home/klchang/）下，输入如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>\n\n<p>含义为使用 8080端口的创建Web服务器，可以使用浏览器 <a href=\"http://127.0.0.1:8080\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080</a> 或 将 127.0.0.1 替换为本机的外部IP地址，进行访问。</p>\n<p>对于Python 3，其创建Web服务器的等价命令，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 -m http.server 8080</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Python 创建服务器仅需一条命令</p>\n</blockquote>","more":"<p>对于Python 2，简单搭建Web服务器，只需在需要搭建Web服务器的目录（如C:/ 或 /home/klchang/）下，输入如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure>\n\n<p>含义为使用 8080端口的创建Web服务器，可以使用浏览器 <a href=\"http://127.0.0.1:8080\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080</a> 或 将 127.0.0.1 替换为本机的外部IP地址，进行访问。</p>\n<p>对于Python 3，其创建Web服务器的等价命令，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 -m http.server 8080</span><br></pre></td></tr></table></figure>"},{"_content":"# 股票初级\n## 股票入门\n### 股票投资五大流派\n- 技术投资派：通过分析股票的价格走势，来预测股票未来涨跌\n- 宏观投资派：逻辑是整个市场经济向好，股市就会向好，研究经济就可以指导股票投资\n- 有效市场派：认为市场大部分时候对股票的定价是正确的\n- 成长投资派（预测未来）：更关注公司未来是否有足够高的增长\n- 价值投资派（把握现在）：看重现在公司是否有足够低的价格，低价高卖就是价值投资的本质\n### 价值投资\n#### 价值投资方法\n##### 捡烟蒂投资法\n- 本杰明.格雷厄姆：100%价值投资法，独创安全边际理论\n- 烟蒂股：毫不起眼，甚至被抛弃的公司\n- 需要的成本远低于本身的价值，继续下跌概率小，上涨概率大于下跌概率\n##### 好公司投资法\n- 巴菲特：喜欢买好公司，偏爱食品行业\n- 投资核心：找到好公司，低价买入\n- 好公司的价值最终一定会显现在股价上\n- 天时：看准入场时机，在股票市场便宜的时候进场买买买\n- 一家公司的价值=现在公司的价值+未来公司能赚取的价值\n- 市盈率(PE)=市值/净利润=买下公司需要的钱/每年能赚到的钱\nPE越小，回本年限越短，越有投资价值\n- 市净率（PB)=市值/净资产=买下公司需要的钱/属于公司自己的资产\n- PB越小，价格越低，越有投资价值\n- A股3000=沪深300+中证500+其他各类股票\n- 找准入场时机：用沪深300和中证500估值处于低估，此时可入场\n当沪深300和中证500中任一个PE，PB同时满足：\n1.PE处于近十年数值的0-50%\n2.PB处于近十年数值的0-20%\n- 可入场投资的三种情况：\n沪深300PE，PB同时满足条件，中证500没有满足\n中证500PE，PB同时满足条件，沪深300没有满足\n沪深300和中证500的PE，PB都同时满足条件\n- 实操\n理杏仁官网-搜索框输入“沪深300”查询该指数的数据\n选“PE-TTM，加权平均值，十年”，可以看到PE图\nPE－TTM：就是PE，TTM是一种更为精确计算PE的方式\n加权平均值：把沪深３００的所有公司的市值相加除以净利润之和，相当于把这３００家公司“合并”成一家大公司计算PE\n１０年：通常７－１０年，中国股市会经过一个完整的涨跌大周期，选择十年，能较客观地判断当前估值相对于过去１０年是高还是低\nPE分位点：把过去１０年PE从小到大排序，当前PE所处位置\n１００％表示当前PE是最大值，５０％表示当前PE处于中间位置\n点击PB，可以查看PB图\n搜索中证５００，查看PE，PB\n判断某天是否适合入场，满足其中一个即可\n沪深３００当天PE分位点＜５０％且PB分位点＜２０％，十年加权平均值\n中证５００当天PE分位点＜５０％且PB分位点＜２０％，十年，加权平均值\n地利：合理布局资金，建立自己的投资组合，规避风险\n股市风险\n系统性风险:整个股票市场存在的下跌风险，我们需先估值再入市\n政策风险:政策改变导致企业生存条件变化\n购买力风险:通货膨胀的风险\n利率风险:市场利率会不断波动\n非系统性风险:单只股票本身的风险\n经营风险:公司经营的错误决策可能导致公司业绩大幅下滑\n信用风险:公司违背信用所产生的风险\n道德风险:违背道德事件，如三鹿的“毒奶粉事件”\n规避风险\n规避系统风险:先估值再入市\n规避非系统风险:构建组合投资，资金分散到多个行业的多个股票上，鸡蛋不要放在同一个篮子里\n回避风险时，并不是买的股票越多越科学，持有4-8只股票是比较经济，有效的做法\n分散行业：同行业资金占比不要超过30%\n人和：学会建设过硬的心理素质\n白马组合\n“好公司”投资法：赚业绩提升的钱\n初筛白马股\n买股票的条件\n资金：投资的必要条件\n心态：优秀投资者必备的素质\n选股：开始买股票最重要的事情，一个好的股票，上涨的时候更多的回报，下跌的时候更大的耐心\n头脑清晰，理性看待价格上涨\n可能跟随价值上涨\n可能只是围绕价值波动\n白马股票：信息相对可靠，长期业绩优秀，投资回报率高\n投资回报率：投资多少和能赚多少的比例\n股票投资回报率就是投资收益率=[（卖出价格/买入价格）-1]*100%\n年化复合收益率=【（卖出价格/买入价格）^（1/n）-1】*100%，n是投资年限\n净资产收益率（ROE）=净利润/净资产，代表了企业赚钱能力\nROE越高，股票的年化收益率就越高\n初筛条件\nROE连续7年>=15%\n上市时间>5年，因为上市时间太短的话，业绩不够稳定\n初筛方法\n1.打开同花顺旗下“i问财”网站（https://www.iwencai.com）\n2.文本框输入查询条件：2012年到2018年ROE大于等于15%，2019年06月30日ROE大于等于7.5%，上市时间大于5年，点击按钮“问一下财”，系统自动识别条件，并把输入的条件用“且”的关系关联起来，查出股票数据\n3.初步筛选出了43个白马股了，可以导出数据\n注意：财报披露是有延迟的（速记：1214）\n第一季度结束后一个月内公布\n第二个季度结束后两个月内公布\n第三季度结束后一个月内公布\n第四季度即年报是结束后4个月内公布\n剔除周期股\n经济周期：国民经济呈现扩张与紧缩交替波动变化\n必然发生\n循环往复：复苏，繁荣，衰退，萧条，类似四季循环\n周期性行业：业绩紧跟经济周期起起伏伏，比如：汽车行业\n非周期性行业：受经济周期影响较小，经营业绩更稳定，比如：医药行业，食品行业\n周期股：受经济周期影响大，所处行业属于周期性行业\n四类要避开的行业（周期性行业）\n作为工业基础原材料的大宗商品相关行业（主要用于经济发展）\n比如：采掘服务，钢铁，化工合成材料，化工新材料，石油矿业开采，化学制品等\n航运业（运输货物）\n比如：远洋运输，港口航运，机场航运，交通设备服务等\n非生活必需品行业，及与之相关的行业（非必需）\n如：国防军工，汽车零件，汽车，建筑材料，建筑装饰，房地产等\n非银行的金融行业\n如：证券，保险及其他\n方法\n1.“i问财”中初筛白马股，输入查询条件：2012年到2018年ROE大于等于15%，2019年06月30日ROE大于等于7.5%，上市时间大于5年，行业。点击按钮“问一下财”，查询数据并导出\n2.剔除周期股，打开表格，把所属行业是周期性行业的数据剔除\n剔除基本面转坏的股票\n评估业绩下滑，四个指标有一个为负数就剔除该股\n最近年度营收增长率 = （本年营业收入 - 去年营业收入） / 去年营业收入\n最近年度净利润增长率 = （本年净利润 - 去年净利润） / 去年净利润\n最近季度营收增长率 = （本季度营业收入 - 去年同季度营业收入） / 去年同季度营业收入\n最近季度净利润增长率 = （本季度净利润 - 去年同季度净利润） / 去年同季度净利润\n方法\n1.“i问财”输入查询条件：2012年到2018年ROE大于等于15%，2019年6月30日ROE大于等于7.5%，营收增长率和净利润增长率，上市时间大于5年，行业，2018年营收增长率和净利润增长率\n2.去掉不必要的列，导出数据\n3.导出的表格筛选行业，去掉周期性行业\n4.筛选出最近季度和最近年度的营收增长率和净利润增长率大于0，排除掉小于0的即业绩下滑的股\n财报三表分析\n财报：记录公司所有经营事务的报表，分为季度报表，半年报表，年度报表\n利润表（损益表）：体现公司在一段时间内是赚钱还是亏钱\n营业利润=营业收入 - 营业成本 - 三费\n营业收入：卖东西的收入，只要卖出东西，无论是否收到钱都计入\n营业成本：购买生产货物的原材料等所付出的钱\n三费：管理费用，销售费用，财务费用\n净利润 = 营业利润 - 所得税\n资产负债表\n记录某时公司有多少钱，财，物以及欠别人多少钱\n现金流量表\n公司现金流入流出情况，开支流水账，记录花出去多少钱，收到多少钱\n经营活动现金流量\n利润表\n投资现金流量\n资产\n筹资活动现金流量\n负债\n识别信息相对可靠\n如何识别收入美化，识别真货假卖\n小熊定理1：识别真货假卖，是否存在连续两年应收账款增长幅度大于营收增长幅度，存在则不通过检验\n实操方法\n理杏仁-输入查询的某股票\n利润表-我们需要了解最近3年增长情况，所以查询最近4年数据\n找到营业收入，把数据复制进表格中,计算每年营业收入增长金额\n资产负债表-应收账款-数据复制进表格，计算每年应收账款增长金额\n每年应收账款增长金额-营业收入增长金额算出结果，如果连续两年结果大于0，表示连续两年应收账款增长幅度大于营业收入增长幅度，则不通过小熊定理1，要当心\n如何识别资产美化\n资产负债表：记录公司某时有多少钱财物，欠多少钱\n资产\n货币资金（现金）：顾客找零，临时补货等\n应收账款：白条，别人欠你的钱\n存货：原材料和耗材等\n预付款项：预先支出房租等\n固定资产：设备，厂房，土地等\n负债\n应付款项：欠供应商的贷款\n短期借款：如借朋友的钱，一年内还\n长期借款：如借银行的钱，为期5年\n所有者权益（净资产）：属于公司自己的\n资本公积金\n未分配利润\n核心：资产=负债+所有者权益\n问题主要在存货上，存货不仅指生产出的货物，还包括生产用的原材料，生产过程中的半成品，财报的存货只能看到资金总额，这就给了别有用心的公司一个机会\n识别存货造假\n小熊定理2：连续两年存货增长大于营业收入增长，这家公司存货可能有问题\n实操方法\n1.理杏仁网站查询某股票信息，在利润表中找到连续4年的营业收入数据，并计算出营业收入增长金额\n2.在资产负债表中找到连续4年的存货数据，并计算存货增长金额\n3.验证小熊定理2，比较每年营业收入增长金额和存货增长的差异，用当年存货增长减去营业收入增长金额\n结果大于0，说明存货涨幅更大，小于0则说明营业收入丈夫更大\n当出现连续2年结果都大于0，说明公司连续两年存货增长金额大于营业收入增长金额，不通过小熊定理2，要当心了\n识别资产安全（鉴别公司是否有破产的风险）\n小熊定理3：如果一家公司的流动负债远大于流动资产的话，说明这家公司已经非常接近破产了\n流动资产：一年内可以变现的资产，如货币资金，存货，预付款项\n流动负债：一年内必须要还的钱，如应付账款，短期借款\n流动比率 = 流动资产 / 流动负债\n如果流动比率小于1，说明流动资产小于流动负债，危险的信号\n实操方法\n理杏仁-查询股票资产负债表中最近3年的流动比率，最近3年有2年都小于1就要当心了\ni问财也可以查询\n除银行股外，所选公司只要有一个定理不能通过检验，就要剔除\n小熊定理1能看出公司是否有美化收入嫌疑\n小熊定理2能看出公司是否有美化资产的嫌疑\n小熊定理3能轻松鉴别公司是否有破产风险\n自由现金流如此重要，加分项\n小熊定理4：当一家公司经营活动现金流量净额远大于净利润，说明这家公司可能有隐藏的盈利能力，有可能是座金矿\n理杏仁-查询公司-现金流量表-近三年经营活动产生的现金流量净额-和净利润对比\n小熊定理5：自由现金流是衡量公司现金流情况的指标，代表公司真正能自由运用的资金，比净利润更真实，更难作假\n自由现金流=经营活动产生的现金流量净额-资本开支\n资本开支是现金流量表中的购建固定资产，无形资产和其他长期资产支付的现金\n理杏仁-查询公司-财务指标-现金流量里面的自由现金流大于0就加分了\n实操：构建白马组合\n筛选步骤\n投资回报率高\nROE连续7年大于等于15%，上市时间大于5年\n长期业绩优秀\n剔除周期股，看行业\n剔除当下业绩显现下滑迹象的公司\n信息相对可靠\n小熊三大定理检验经过筛选的股票，财报信息是否可靠\n判断股票价格\n股票的贵与便宜相对价值而言的，估值体现价格和价值的关系\nPE分位点和PB分位点小于50%\n理杏仁-查询公司-价值分析-PE分位点和PB分位点（10年数据）历史看前复权，现在看股价\n怎么买\nPE分位点升序排列，优先买PE分位点低的，平均分配资金\nPE升序，整理筛选出来的公司\n找出它们当时的股价，计算购买一手的价格\n根据资金量分配选择股票数量，同行业不能超过30%，行业看二级行业\n同行业股票数量不超过30%，即公司数量不超过30%\n同行业资金占比也不超过30%\n卖出\n股票价格高于价值了，你贵了\n基本面转坏了，你变了，每年一次筛选对比\n发现更好更便宜的，别人比你更好了\n稳住心态，长期持有\n短期可能下跌，长期价格回归价值\n总结\nPE分位点升序排列，优先买PE分位点低的，平均分配资金\n每年筛选一次对比调仓，贵了，变了就剔除\n干货补充\n容易出白马股的行业，一般来说，有护城河的公司都会有较高的投资回报率，也有不错的业绩。\n护城河\n无形资产护城河：看不见摸不到的资产\n品牌护城河：大家耳熟能详的各种品牌，就是公司想要打造的品牌护城河\n品牌溢价护城河：可以卖得比同类产品贵的能力，就是品牌溢价能力，这种公司就有品牌 溢价护城河。\n有这种护城河的公司产品，即使价格卖得高卖得贵，消费者为了这个牌子也 会买，比如说贵州茅台，比如说苹果手机。\n品牌搜索护城河：有这种护城河的公司产品，在我们想买什么的时候，会出现在我们脑子里。\n比如说我们想买牛奶，第一反应可能是伊利，可能是蒙牛\n专利护城河：专利就是只有我有的权利\n有专利护城河的公司，就是那种可以持续性研发出产品，并且申请出专利的 公司，比如说大型药厂\n政府授权护城河:政府授权的是你能不能进入这个行业\n比较典型的有这个护城河的公司是赌场，在内地，赌场就禁止经营，而澳门现在也不会批准建新的赌场，所以，澳门那几家赌场的竞争对手并不会增加！\n转换成本护城河\n如果一个产品的用户，更换这个产品时需要付出很多代价或成本，我们就说 这个产品具有转换成本，这家公司具有转换成本护城河。\n如果一家医院要换信息系统，它会面临怎样的麻 烦？\n数据转移\n医生，护士学习新系统\n核对旧病例，导入是否完整\n网络效应护城河\n严格来说是转换成本的一种。 因为互联网的日益发达，受到了越来越多的重视，很典型的公司就是腾讯控股。\n像微信这种，随着使用人数的增多，产品价值越高的公司，就是有网络效应 护城河的公司。\n规模效应护城河\n规模带来的效应，生产数量越多固定资产成本越低\n固定成本（厂房设备等固定资产）的总额不会随着成品数量变化，但是 随着生产数量的增多，每个产品中固定成本的量会变小。\n易出护城河的行业（速记：白衣小软妹），可以优先选择好行业里的公司\n白酒行业、医药行业、软件行业、媒体行业、消费行业\n通过估值四象限快速判断一家公司的状态\nPE 是从企业盈利的角度考察现在的股价是不是合理，而 PB 是从企业的净资产角度考察现在的股价是不是合理。粗略来分，我们可以把大于 50%的分位点称为高，把小于 50%的分位点称 为低。\n估值四象限\n第一象限：高 PB，高 PE\n泡沫象限，远离\npe、pb 越高，说明整个 市场越贵，下跌的可能越大。\n被疯狂炒作的个股，比方说 2015 年妖股第一名暴风集团。\n第二象限：低 PB，高 PE，分析公司业绩未来是否有变好的可能\n企业自身运营不善，避开\n周期性行业低估期，买入持有至行业回暖，也有可观的收益\n第三象限：低 PB，低 PE，大概率是比较合适的投资机会，辨别PE是真低还是价低（盈利能力下降，财报是否体现）\n市场处于熊市的末期，此时由于熊市长期的下跌导致大家的投 资情绪都过于悲观，会使得很多股票的价格跌到实际价值以下，出现大量的低 PB、低 PE 股票，这时候意味着，投资的机会来了。\n企业遭遇经营困境、或行业政策、竞争态势等外部环境发生 不利变化。由于市场有时会提前并且迅速做出反应，导致公司股价下降，市 值变得很低，自然的 PB 就会很低。\nPE“真低”\n财报中的数据已经显示出公司盈利能力的下降，投资者们 看到公司盈利下降了，纷纷卖出，公司市值必然下降，市值与净利润同时下降导 致的低 PE，就是 PE“真低”。只要公司未来盈利能力可以恢复，就是好的入场 时机。\nPE“假低”\n公司业绩的披露有滞后性，而 PE 的计算又是基于最近披露的净利润， 所以当最近一期公司财报并没有显示出业绩下滑，也就是说净利润仍然是高的， pe=市值/净利润，公司的 PE 依然很低。\n一旦未来公司财报显示出公司的盈利能力快速下滑，那很可能会出现股价越 跌，PE 越高的情况。\n因为虽然股价在下跌，但盈利下跌速度更快，可能直接跌成负的了。 这就是我们必须尽力避免的低价值陷阱，也就是 PE“假低”。\n第四象限：高 PB，低 PE\n英雄象限，避开\nPB 高，意味着投资者们特别看好公司的发展，对公司的盈利能力有着很高的期待，毕竟市场给予了比净资产高很多倍的溢价嘛！\n一旦公司盈利不达预期，曾经追捧的那些投资者们就会纷纷弃他而去， 导致股价下跌。\nPB高，不用管PE低不低，直接避开\n分红过后需要除权除息，所以股价必然下降\n分红\n一种是上市公司直接给股东送股票，这种称为“股票股利”\n公司的股价=总市值/总股数，总股数增加了，每股的价格当然也会减少，这种行为就叫做除权。\n另外一种是现金分红，就是公司直接给股东发现金，这种称为“现金股利”\n发现金股利的时候，会从股价中将这一部分股利扣除，这就叫做除息\n填权\n公司的价值短期内变动幅度有限，只要大家看好公司的价值，股 价降低了公司价值没有变，当然会有人去买，因此，除权除息后，股价都会涨回 和原来差不多，这个过程称之为填权。\n红利税\n红利税并不是在分红派息那天扣除的，而是在卖出股票的时候 扣除，只要持股超过一年，就不需要缴纳，可见，咱们股市的监管方，也是希望 大家做长期的价值投资者，而非炒作的投机者。\n什么公司不能碰\n第一种，大品牌更可靠\n首先，知名企业有着很大的曝光率，更容易被发现财务造假。\n其次，他们财务造假的成本太高。\n第二种，不要 ST。股票名称前带有“ST”、“*ST”、“SST”、“S*ST”、“NST”标识的， 一定不要投！\n有上述标识的股票意味着，该公司至少连续两年亏损，将被证监会处理，面 临整改或者退市。\nST 代表的就是亏损股\n第三种，曾经出现过违反道德规范、财报作假等重大丑闻的，被证监会立案调查 还未有结果的公司不要买。\n只要在百度中用“公司名+证监会”， 这一组关键词搜索，就能看到相关的信息。\n便宜组合\n“捡烟蒂”投资法\n便宜组合：赚股价回升的钱，不太挑剔股票质量，主要看折扣\n筛选指标\n双低组合，低PE低PB\n0<PE<10\n0<PB<1.5\n大方分钱\n股息率>3%\n股息率=公司过去一年的累计现金分红/公司市值，A股公司平均股息率约为3%\n实操筛选\n理杏仁-选股-基本面选股\n选择范围-A股市场-沪深两市\n条件设置-基本指标-点击筛选便宜组合的三个指标\n市盈率选PE-TTM（扣非）\n扣非：扣除非经常性损益（利润表中一部分和公司正经运营业务无关）\n不含商誉的PB\n公司收购其他公司时超过净资产的部分，是资产的一部分，但本质不是真正的资产\n股息率\n两个选股条件\nPB（不含商誉）分位点（10年），股价\n时间选择最近时间\n按照筛选条件，选好最大值最小值，开始选股，最后导出文件\n排序筛选法\nPE，PB升序排列，股息率降序排列，三个指标排名加总，算出总排名\n实操\n分别在PE，PB，股息率右边增加列PE排名，PB排名，股息率排名。再加一列综合排名\n用RANK.EQ函数计算PE排名，PB排名，股息率排名\n数值-想要排序的那个数值\n引用-数值所在的数据集合\n排序方式\n1：升序\n0：降序\n计算综合排名：把PE排名，PB排名，股息率排名三个排名相加\n综合排名升序排列\n具体筛选\n8-10只构建便宜组合\n根据综合排名从低到高依次挑选，行业要分散：同一行业公司不要超过30%\n用PB分位点进一步挑选低估股票，PB分位点<20%加入组合\nPB（不含商誉）分位点（10年）：把过去10年的PB从小到大排列，现在PB所在的位置\nPB分位点<20%，现在是低估，适合买入\nPB分位点>50%，现在是高估，不适合买入\n资金分配\n根据资金量确定便宜组合的股票数量\n同一行业股票数量和资金不超过30%\n资金均分\n确定价格最高的买一手，其余股票金额往这个金额上靠就可以了\n筛选数量不够时\n放宽筛选条件\n寻找别的投资机会\n持币观望，等待入场时机\n被动投资\n每隔半年调仓一次，将组合整体估值降低\n每隔半年重新筛一次便宜组合\n将最新筛出的便宜组合和原来组合对比\n新旧组合重合部分保留\n卖掉旧组合里有，但新组合里没有的股票\n补入就组合里没有，但新组合里有的股票\n清楚投资原理，投资方法\n了解攀升强度，明白回撤幅度\n具备耐心和坚持才配得上优厚的回报\n轻松实践\n买股票常识\nA股交易时间：周一到周五每天4小时交易时间（法定休假日除外），上午9:30-11:30，下午13:00-15:00\nK线图（蜡炬图）\n蜡炬图\n阳线：红色的，代表股价上涨，当天收盘价大于开盘价即收盘价在上开盘价在下\n阴线：绿色的，代表股价下跌，当天收盘价小于开盘价即开盘价在上收盘价在下\n阳线和阴线都有上影线和下影线分部表示最高价和最低价\n计算周期\n日K线：最常用，以当天开盘价，收盘价，最高价，最低价来画的Ｋ线图\n周K线：以周一开盘价，周五收盘价，全周最高价和最低价来画的K线图\n月K线：以一个月第一个交易日的开盘价，最后一个交易日收盘价，全月最高价和最低价来画的K线图\n季K线\n年K线\n每根Ｋ线下面对应有一条红色或绿色的条形图，代表交易量（一段时间内成交的股票数量，受供求关系影响）\n交易单位\n以“手”为单位，１手＝100股, 1-99股称为零股\n买入最低单位为手\n分红送股可能有零股，卖出可以有零股，但是零股必须一次性卖出\nA股交易费用（沪市和深市）\n无论是基金开的还是咱们股初扫码开的华泰优惠开户，都是调整成股票万分之1.8，起点5元， 基金万分之1，起点0.1元\n印花税\n国家税务局\n卖出收，成交金额的千分之一\n过户费\n中登公司\n买入和卖出都收，成交金额的千分之0.02\n佣金\n证交所证券公司\n买入和卖出都收，最高千分之3，最低5元\n报价方式\n限价委托（常用）\n用户限定价格，价格可控，交易时间不可控\n好处：价格可控，当股价到达了设置的价格成交\n坏处：如果股价始终高于限定的价格，就需要耐心等待，也可能当天成交不了\n市价委托（不常用）\n只指定交易数量，价格不可控，交易时间可控\n好处：即时成交\n坏处：成交价格可能偏贵\n特色\n涨跌停板制度\n股票上涨幅度和下跌幅度只能是上一个交易日收盘价的10%\nST开头的股票，每日涨跌停幅度限制只有5%\n新股首日上市股价涨幅不受10%限制，但是最高幅度不能超过发行价的44%\n交易制度：T+1交易，忌频繁交易\n当天买入的证券不能当天卖出，第二天才可以卖出\n当天卖出股票收回的资金只能用来买新的股票，不能提取。第二天才可提取\n人和：股海沉浮，锦囊妙计\n1.贪多嚼不烂\n入门简单，严格执行投资计划，会获得合理收益的。精通难，想要超额收益，需要付出超额努力\n2.笑看涨跌，波澜不惊\n面对股价大幅度下跌，要相信组合的力量，不要每天看盘，一个月一次就够了\n3.保持耐心，长期持有\n时间是财富自由的基本条件#","source":"_posts/股票/股票初级.md","raw":"# 股票初级\n## 股票入门\n### 股票投资五大流派\n- 技术投资派：通过分析股票的价格走势，来预测股票未来涨跌\n- 宏观投资派：逻辑是整个市场经济向好，股市就会向好，研究经济就可以指导股票投资\n- 有效市场派：认为市场大部分时候对股票的定价是正确的\n- 成长投资派（预测未来）：更关注公司未来是否有足够高的增长\n- 价值投资派（把握现在）：看重现在公司是否有足够低的价格，低价高卖就是价值投资的本质\n### 价值投资\n#### 价值投资方法\n##### 捡烟蒂投资法\n- 本杰明.格雷厄姆：100%价值投资法，独创安全边际理论\n- 烟蒂股：毫不起眼，甚至被抛弃的公司\n- 需要的成本远低于本身的价值，继续下跌概率小，上涨概率大于下跌概率\n##### 好公司投资法\n- 巴菲特：喜欢买好公司，偏爱食品行业\n- 投资核心：找到好公司，低价买入\n- 好公司的价值最终一定会显现在股价上\n- 天时：看准入场时机，在股票市场便宜的时候进场买买买\n- 一家公司的价值=现在公司的价值+未来公司能赚取的价值\n- 市盈率(PE)=市值/净利润=买下公司需要的钱/每年能赚到的钱\nPE越小，回本年限越短，越有投资价值\n- 市净率（PB)=市值/净资产=买下公司需要的钱/属于公司自己的资产\n- PB越小，价格越低，越有投资价值\n- A股3000=沪深300+中证500+其他各类股票\n- 找准入场时机：用沪深300和中证500估值处于低估，此时可入场\n当沪深300和中证500中任一个PE，PB同时满足：\n1.PE处于近十年数值的0-50%\n2.PB处于近十年数值的0-20%\n- 可入场投资的三种情况：\n沪深300PE，PB同时满足条件，中证500没有满足\n中证500PE，PB同时满足条件，沪深300没有满足\n沪深300和中证500的PE，PB都同时满足条件\n- 实操\n理杏仁官网-搜索框输入“沪深300”查询该指数的数据\n选“PE-TTM，加权平均值，十年”，可以看到PE图\nPE－TTM：就是PE，TTM是一种更为精确计算PE的方式\n加权平均值：把沪深３００的所有公司的市值相加除以净利润之和，相当于把这３００家公司“合并”成一家大公司计算PE\n１０年：通常７－１０年，中国股市会经过一个完整的涨跌大周期，选择十年，能较客观地判断当前估值相对于过去１０年是高还是低\nPE分位点：把过去１０年PE从小到大排序，当前PE所处位置\n１００％表示当前PE是最大值，５０％表示当前PE处于中间位置\n点击PB，可以查看PB图\n搜索中证５００，查看PE，PB\n判断某天是否适合入场，满足其中一个即可\n沪深３００当天PE分位点＜５０％且PB分位点＜２０％，十年加权平均值\n中证５００当天PE分位点＜５０％且PB分位点＜２０％，十年，加权平均值\n地利：合理布局资金，建立自己的投资组合，规避风险\n股市风险\n系统性风险:整个股票市场存在的下跌风险，我们需先估值再入市\n政策风险:政策改变导致企业生存条件变化\n购买力风险:通货膨胀的风险\n利率风险:市场利率会不断波动\n非系统性风险:单只股票本身的风险\n经营风险:公司经营的错误决策可能导致公司业绩大幅下滑\n信用风险:公司违背信用所产生的风险\n道德风险:违背道德事件，如三鹿的“毒奶粉事件”\n规避风险\n规避系统风险:先估值再入市\n规避非系统风险:构建组合投资，资金分散到多个行业的多个股票上，鸡蛋不要放在同一个篮子里\n回避风险时，并不是买的股票越多越科学，持有4-8只股票是比较经济，有效的做法\n分散行业：同行业资金占比不要超过30%\n人和：学会建设过硬的心理素质\n白马组合\n“好公司”投资法：赚业绩提升的钱\n初筛白马股\n买股票的条件\n资金：投资的必要条件\n心态：优秀投资者必备的素质\n选股：开始买股票最重要的事情，一个好的股票，上涨的时候更多的回报，下跌的时候更大的耐心\n头脑清晰，理性看待价格上涨\n可能跟随价值上涨\n可能只是围绕价值波动\n白马股票：信息相对可靠，长期业绩优秀，投资回报率高\n投资回报率：投资多少和能赚多少的比例\n股票投资回报率就是投资收益率=[（卖出价格/买入价格）-1]*100%\n年化复合收益率=【（卖出价格/买入价格）^（1/n）-1】*100%，n是投资年限\n净资产收益率（ROE）=净利润/净资产，代表了企业赚钱能力\nROE越高，股票的年化收益率就越高\n初筛条件\nROE连续7年>=15%\n上市时间>5年，因为上市时间太短的话，业绩不够稳定\n初筛方法\n1.打开同花顺旗下“i问财”网站（https://www.iwencai.com）\n2.文本框输入查询条件：2012年到2018年ROE大于等于15%，2019年06月30日ROE大于等于7.5%，上市时间大于5年，点击按钮“问一下财”，系统自动识别条件，并把输入的条件用“且”的关系关联起来，查出股票数据\n3.初步筛选出了43个白马股了，可以导出数据\n注意：财报披露是有延迟的（速记：1214）\n第一季度结束后一个月内公布\n第二个季度结束后两个月内公布\n第三季度结束后一个月内公布\n第四季度即年报是结束后4个月内公布\n剔除周期股\n经济周期：国民经济呈现扩张与紧缩交替波动变化\n必然发生\n循环往复：复苏，繁荣，衰退，萧条，类似四季循环\n周期性行业：业绩紧跟经济周期起起伏伏，比如：汽车行业\n非周期性行业：受经济周期影响较小，经营业绩更稳定，比如：医药行业，食品行业\n周期股：受经济周期影响大，所处行业属于周期性行业\n四类要避开的行业（周期性行业）\n作为工业基础原材料的大宗商品相关行业（主要用于经济发展）\n比如：采掘服务，钢铁，化工合成材料，化工新材料，石油矿业开采，化学制品等\n航运业（运输货物）\n比如：远洋运输，港口航运，机场航运，交通设备服务等\n非生活必需品行业，及与之相关的行业（非必需）\n如：国防军工，汽车零件，汽车，建筑材料，建筑装饰，房地产等\n非银行的金融行业\n如：证券，保险及其他\n方法\n1.“i问财”中初筛白马股，输入查询条件：2012年到2018年ROE大于等于15%，2019年06月30日ROE大于等于7.5%，上市时间大于5年，行业。点击按钮“问一下财”，查询数据并导出\n2.剔除周期股，打开表格，把所属行业是周期性行业的数据剔除\n剔除基本面转坏的股票\n评估业绩下滑，四个指标有一个为负数就剔除该股\n最近年度营收增长率 = （本年营业收入 - 去年营业收入） / 去年营业收入\n最近年度净利润增长率 = （本年净利润 - 去年净利润） / 去年净利润\n最近季度营收增长率 = （本季度营业收入 - 去年同季度营业收入） / 去年同季度营业收入\n最近季度净利润增长率 = （本季度净利润 - 去年同季度净利润） / 去年同季度净利润\n方法\n1.“i问财”输入查询条件：2012年到2018年ROE大于等于15%，2019年6月30日ROE大于等于7.5%，营收增长率和净利润增长率，上市时间大于5年，行业，2018年营收增长率和净利润增长率\n2.去掉不必要的列，导出数据\n3.导出的表格筛选行业，去掉周期性行业\n4.筛选出最近季度和最近年度的营收增长率和净利润增长率大于0，排除掉小于0的即业绩下滑的股\n财报三表分析\n财报：记录公司所有经营事务的报表，分为季度报表，半年报表，年度报表\n利润表（损益表）：体现公司在一段时间内是赚钱还是亏钱\n营业利润=营业收入 - 营业成本 - 三费\n营业收入：卖东西的收入，只要卖出东西，无论是否收到钱都计入\n营业成本：购买生产货物的原材料等所付出的钱\n三费：管理费用，销售费用，财务费用\n净利润 = 营业利润 - 所得税\n资产负债表\n记录某时公司有多少钱，财，物以及欠别人多少钱\n现金流量表\n公司现金流入流出情况，开支流水账，记录花出去多少钱，收到多少钱\n经营活动现金流量\n利润表\n投资现金流量\n资产\n筹资活动现金流量\n负债\n识别信息相对可靠\n如何识别收入美化，识别真货假卖\n小熊定理1：识别真货假卖，是否存在连续两年应收账款增长幅度大于营收增长幅度，存在则不通过检验\n实操方法\n理杏仁-输入查询的某股票\n利润表-我们需要了解最近3年增长情况，所以查询最近4年数据\n找到营业收入，把数据复制进表格中,计算每年营业收入增长金额\n资产负债表-应收账款-数据复制进表格，计算每年应收账款增长金额\n每年应收账款增长金额-营业收入增长金额算出结果，如果连续两年结果大于0，表示连续两年应收账款增长幅度大于营业收入增长幅度，则不通过小熊定理1，要当心\n如何识别资产美化\n资产负债表：记录公司某时有多少钱财物，欠多少钱\n资产\n货币资金（现金）：顾客找零，临时补货等\n应收账款：白条，别人欠你的钱\n存货：原材料和耗材等\n预付款项：预先支出房租等\n固定资产：设备，厂房，土地等\n负债\n应付款项：欠供应商的贷款\n短期借款：如借朋友的钱，一年内还\n长期借款：如借银行的钱，为期5年\n所有者权益（净资产）：属于公司自己的\n资本公积金\n未分配利润\n核心：资产=负债+所有者权益\n问题主要在存货上，存货不仅指生产出的货物，还包括生产用的原材料，生产过程中的半成品，财报的存货只能看到资金总额，这就给了别有用心的公司一个机会\n识别存货造假\n小熊定理2：连续两年存货增长大于营业收入增长，这家公司存货可能有问题\n实操方法\n1.理杏仁网站查询某股票信息，在利润表中找到连续4年的营业收入数据，并计算出营业收入增长金额\n2.在资产负债表中找到连续4年的存货数据，并计算存货增长金额\n3.验证小熊定理2，比较每年营业收入增长金额和存货增长的差异，用当年存货增长减去营业收入增长金额\n结果大于0，说明存货涨幅更大，小于0则说明营业收入丈夫更大\n当出现连续2年结果都大于0，说明公司连续两年存货增长金额大于营业收入增长金额，不通过小熊定理2，要当心了\n识别资产安全（鉴别公司是否有破产的风险）\n小熊定理3：如果一家公司的流动负债远大于流动资产的话，说明这家公司已经非常接近破产了\n流动资产：一年内可以变现的资产，如货币资金，存货，预付款项\n流动负债：一年内必须要还的钱，如应付账款，短期借款\n流动比率 = 流动资产 / 流动负债\n如果流动比率小于1，说明流动资产小于流动负债，危险的信号\n实操方法\n理杏仁-查询股票资产负债表中最近3年的流动比率，最近3年有2年都小于1就要当心了\ni问财也可以查询\n除银行股外，所选公司只要有一个定理不能通过检验，就要剔除\n小熊定理1能看出公司是否有美化收入嫌疑\n小熊定理2能看出公司是否有美化资产的嫌疑\n小熊定理3能轻松鉴别公司是否有破产风险\n自由现金流如此重要，加分项\n小熊定理4：当一家公司经营活动现金流量净额远大于净利润，说明这家公司可能有隐藏的盈利能力，有可能是座金矿\n理杏仁-查询公司-现金流量表-近三年经营活动产生的现金流量净额-和净利润对比\n小熊定理5：自由现金流是衡量公司现金流情况的指标，代表公司真正能自由运用的资金，比净利润更真实，更难作假\n自由现金流=经营活动产生的现金流量净额-资本开支\n资本开支是现金流量表中的购建固定资产，无形资产和其他长期资产支付的现金\n理杏仁-查询公司-财务指标-现金流量里面的自由现金流大于0就加分了\n实操：构建白马组合\n筛选步骤\n投资回报率高\nROE连续7年大于等于15%，上市时间大于5年\n长期业绩优秀\n剔除周期股，看行业\n剔除当下业绩显现下滑迹象的公司\n信息相对可靠\n小熊三大定理检验经过筛选的股票，财报信息是否可靠\n判断股票价格\n股票的贵与便宜相对价值而言的，估值体现价格和价值的关系\nPE分位点和PB分位点小于50%\n理杏仁-查询公司-价值分析-PE分位点和PB分位点（10年数据）历史看前复权，现在看股价\n怎么买\nPE分位点升序排列，优先买PE分位点低的，平均分配资金\nPE升序，整理筛选出来的公司\n找出它们当时的股价，计算购买一手的价格\n根据资金量分配选择股票数量，同行业不能超过30%，行业看二级行业\n同行业股票数量不超过30%，即公司数量不超过30%\n同行业资金占比也不超过30%\n卖出\n股票价格高于价值了，你贵了\n基本面转坏了，你变了，每年一次筛选对比\n发现更好更便宜的，别人比你更好了\n稳住心态，长期持有\n短期可能下跌，长期价格回归价值\n总结\nPE分位点升序排列，优先买PE分位点低的，平均分配资金\n每年筛选一次对比调仓，贵了，变了就剔除\n干货补充\n容易出白马股的行业，一般来说，有护城河的公司都会有较高的投资回报率，也有不错的业绩。\n护城河\n无形资产护城河：看不见摸不到的资产\n品牌护城河：大家耳熟能详的各种品牌，就是公司想要打造的品牌护城河\n品牌溢价护城河：可以卖得比同类产品贵的能力，就是品牌溢价能力，这种公司就有品牌 溢价护城河。\n有这种护城河的公司产品，即使价格卖得高卖得贵，消费者为了这个牌子也 会买，比如说贵州茅台，比如说苹果手机。\n品牌搜索护城河：有这种护城河的公司产品，在我们想买什么的时候，会出现在我们脑子里。\n比如说我们想买牛奶，第一反应可能是伊利，可能是蒙牛\n专利护城河：专利就是只有我有的权利\n有专利护城河的公司，就是那种可以持续性研发出产品，并且申请出专利的 公司，比如说大型药厂\n政府授权护城河:政府授权的是你能不能进入这个行业\n比较典型的有这个护城河的公司是赌场，在内地，赌场就禁止经营，而澳门现在也不会批准建新的赌场，所以，澳门那几家赌场的竞争对手并不会增加！\n转换成本护城河\n如果一个产品的用户，更换这个产品时需要付出很多代价或成本，我们就说 这个产品具有转换成本，这家公司具有转换成本护城河。\n如果一家医院要换信息系统，它会面临怎样的麻 烦？\n数据转移\n医生，护士学习新系统\n核对旧病例，导入是否完整\n网络效应护城河\n严格来说是转换成本的一种。 因为互联网的日益发达，受到了越来越多的重视，很典型的公司就是腾讯控股。\n像微信这种，随着使用人数的增多，产品价值越高的公司，就是有网络效应 护城河的公司。\n规模效应护城河\n规模带来的效应，生产数量越多固定资产成本越低\n固定成本（厂房设备等固定资产）的总额不会随着成品数量变化，但是 随着生产数量的增多，每个产品中固定成本的量会变小。\n易出护城河的行业（速记：白衣小软妹），可以优先选择好行业里的公司\n白酒行业、医药行业、软件行业、媒体行业、消费行业\n通过估值四象限快速判断一家公司的状态\nPE 是从企业盈利的角度考察现在的股价是不是合理，而 PB 是从企业的净资产角度考察现在的股价是不是合理。粗略来分，我们可以把大于 50%的分位点称为高，把小于 50%的分位点称 为低。\n估值四象限\n第一象限：高 PB，高 PE\n泡沫象限，远离\npe、pb 越高，说明整个 市场越贵，下跌的可能越大。\n被疯狂炒作的个股，比方说 2015 年妖股第一名暴风集团。\n第二象限：低 PB，高 PE，分析公司业绩未来是否有变好的可能\n企业自身运营不善，避开\n周期性行业低估期，买入持有至行业回暖，也有可观的收益\n第三象限：低 PB，低 PE，大概率是比较合适的投资机会，辨别PE是真低还是价低（盈利能力下降，财报是否体现）\n市场处于熊市的末期，此时由于熊市长期的下跌导致大家的投 资情绪都过于悲观，会使得很多股票的价格跌到实际价值以下，出现大量的低 PB、低 PE 股票，这时候意味着，投资的机会来了。\n企业遭遇经营困境、或行业政策、竞争态势等外部环境发生 不利变化。由于市场有时会提前并且迅速做出反应，导致公司股价下降，市 值变得很低，自然的 PB 就会很低。\nPE“真低”\n财报中的数据已经显示出公司盈利能力的下降，投资者们 看到公司盈利下降了，纷纷卖出，公司市值必然下降，市值与净利润同时下降导 致的低 PE，就是 PE“真低”。只要公司未来盈利能力可以恢复，就是好的入场 时机。\nPE“假低”\n公司业绩的披露有滞后性，而 PE 的计算又是基于最近披露的净利润， 所以当最近一期公司财报并没有显示出业绩下滑，也就是说净利润仍然是高的， pe=市值/净利润，公司的 PE 依然很低。\n一旦未来公司财报显示出公司的盈利能力快速下滑，那很可能会出现股价越 跌，PE 越高的情况。\n因为虽然股价在下跌，但盈利下跌速度更快，可能直接跌成负的了。 这就是我们必须尽力避免的低价值陷阱，也就是 PE“假低”。\n第四象限：高 PB，低 PE\n英雄象限，避开\nPB 高，意味着投资者们特别看好公司的发展，对公司的盈利能力有着很高的期待，毕竟市场给予了比净资产高很多倍的溢价嘛！\n一旦公司盈利不达预期，曾经追捧的那些投资者们就会纷纷弃他而去， 导致股价下跌。\nPB高，不用管PE低不低，直接避开\n分红过后需要除权除息，所以股价必然下降\n分红\n一种是上市公司直接给股东送股票，这种称为“股票股利”\n公司的股价=总市值/总股数，总股数增加了，每股的价格当然也会减少，这种行为就叫做除权。\n另外一种是现金分红，就是公司直接给股东发现金，这种称为“现金股利”\n发现金股利的时候，会从股价中将这一部分股利扣除，这就叫做除息\n填权\n公司的价值短期内变动幅度有限，只要大家看好公司的价值，股 价降低了公司价值没有变，当然会有人去买，因此，除权除息后，股价都会涨回 和原来差不多，这个过程称之为填权。\n红利税\n红利税并不是在分红派息那天扣除的，而是在卖出股票的时候 扣除，只要持股超过一年，就不需要缴纳，可见，咱们股市的监管方，也是希望 大家做长期的价值投资者，而非炒作的投机者。\n什么公司不能碰\n第一种，大品牌更可靠\n首先，知名企业有着很大的曝光率，更容易被发现财务造假。\n其次，他们财务造假的成本太高。\n第二种，不要 ST。股票名称前带有“ST”、“*ST”、“SST”、“S*ST”、“NST”标识的， 一定不要投！\n有上述标识的股票意味着，该公司至少连续两年亏损，将被证监会处理，面 临整改或者退市。\nST 代表的就是亏损股\n第三种，曾经出现过违反道德规范、财报作假等重大丑闻的，被证监会立案调查 还未有结果的公司不要买。\n只要在百度中用“公司名+证监会”， 这一组关键词搜索，就能看到相关的信息。\n便宜组合\n“捡烟蒂”投资法\n便宜组合：赚股价回升的钱，不太挑剔股票质量，主要看折扣\n筛选指标\n双低组合，低PE低PB\n0<PE<10\n0<PB<1.5\n大方分钱\n股息率>3%\n股息率=公司过去一年的累计现金分红/公司市值，A股公司平均股息率约为3%\n实操筛选\n理杏仁-选股-基本面选股\n选择范围-A股市场-沪深两市\n条件设置-基本指标-点击筛选便宜组合的三个指标\n市盈率选PE-TTM（扣非）\n扣非：扣除非经常性损益（利润表中一部分和公司正经运营业务无关）\n不含商誉的PB\n公司收购其他公司时超过净资产的部分，是资产的一部分，但本质不是真正的资产\n股息率\n两个选股条件\nPB（不含商誉）分位点（10年），股价\n时间选择最近时间\n按照筛选条件，选好最大值最小值，开始选股，最后导出文件\n排序筛选法\nPE，PB升序排列，股息率降序排列，三个指标排名加总，算出总排名\n实操\n分别在PE，PB，股息率右边增加列PE排名，PB排名，股息率排名。再加一列综合排名\n用RANK.EQ函数计算PE排名，PB排名，股息率排名\n数值-想要排序的那个数值\n引用-数值所在的数据集合\n排序方式\n1：升序\n0：降序\n计算综合排名：把PE排名，PB排名，股息率排名三个排名相加\n综合排名升序排列\n具体筛选\n8-10只构建便宜组合\n根据综合排名从低到高依次挑选，行业要分散：同一行业公司不要超过30%\n用PB分位点进一步挑选低估股票，PB分位点<20%加入组合\nPB（不含商誉）分位点（10年）：把过去10年的PB从小到大排列，现在PB所在的位置\nPB分位点<20%，现在是低估，适合买入\nPB分位点>50%，现在是高估，不适合买入\n资金分配\n根据资金量确定便宜组合的股票数量\n同一行业股票数量和资金不超过30%\n资金均分\n确定价格最高的买一手，其余股票金额往这个金额上靠就可以了\n筛选数量不够时\n放宽筛选条件\n寻找别的投资机会\n持币观望，等待入场时机\n被动投资\n每隔半年调仓一次，将组合整体估值降低\n每隔半年重新筛一次便宜组合\n将最新筛出的便宜组合和原来组合对比\n新旧组合重合部分保留\n卖掉旧组合里有，但新组合里没有的股票\n补入就组合里没有，但新组合里有的股票\n清楚投资原理，投资方法\n了解攀升强度，明白回撤幅度\n具备耐心和坚持才配得上优厚的回报\n轻松实践\n买股票常识\nA股交易时间：周一到周五每天4小时交易时间（法定休假日除外），上午9:30-11:30，下午13:00-15:00\nK线图（蜡炬图）\n蜡炬图\n阳线：红色的，代表股价上涨，当天收盘价大于开盘价即收盘价在上开盘价在下\n阴线：绿色的，代表股价下跌，当天收盘价小于开盘价即开盘价在上收盘价在下\n阳线和阴线都有上影线和下影线分部表示最高价和最低价\n计算周期\n日K线：最常用，以当天开盘价，收盘价，最高价，最低价来画的Ｋ线图\n周K线：以周一开盘价，周五收盘价，全周最高价和最低价来画的K线图\n月K线：以一个月第一个交易日的开盘价，最后一个交易日收盘价，全月最高价和最低价来画的K线图\n季K线\n年K线\n每根Ｋ线下面对应有一条红色或绿色的条形图，代表交易量（一段时间内成交的股票数量，受供求关系影响）\n交易单位\n以“手”为单位，１手＝100股, 1-99股称为零股\n买入最低单位为手\n分红送股可能有零股，卖出可以有零股，但是零股必须一次性卖出\nA股交易费用（沪市和深市）\n无论是基金开的还是咱们股初扫码开的华泰优惠开户，都是调整成股票万分之1.8，起点5元， 基金万分之1，起点0.1元\n印花税\n国家税务局\n卖出收，成交金额的千分之一\n过户费\n中登公司\n买入和卖出都收，成交金额的千分之0.02\n佣金\n证交所证券公司\n买入和卖出都收，最高千分之3，最低5元\n报价方式\n限价委托（常用）\n用户限定价格，价格可控，交易时间不可控\n好处：价格可控，当股价到达了设置的价格成交\n坏处：如果股价始终高于限定的价格，就需要耐心等待，也可能当天成交不了\n市价委托（不常用）\n只指定交易数量，价格不可控，交易时间可控\n好处：即时成交\n坏处：成交价格可能偏贵\n特色\n涨跌停板制度\n股票上涨幅度和下跌幅度只能是上一个交易日收盘价的10%\nST开头的股票，每日涨跌停幅度限制只有5%\n新股首日上市股价涨幅不受10%限制，但是最高幅度不能超过发行价的44%\n交易制度：T+1交易，忌频繁交易\n当天买入的证券不能当天卖出，第二天才可以卖出\n当天卖出股票收回的资金只能用来买新的股票，不能提取。第二天才可提取\n人和：股海沉浮，锦囊妙计\n1.贪多嚼不烂\n入门简单，严格执行投资计划，会获得合理收益的。精通难，想要超额收益，需要付出超额努力\n2.笑看涨跌，波澜不惊\n面对股价大幅度下跌，要相信组合的力量，不要每天看盘，一个月一次就够了\n3.保持耐心，长期持有\n时间是财富自由的基本条件#","slug":"股票/股票初级","published":1,"date":"2020-07-15T19:04:45.339Z","updated":"2020-07-15T19:04:45.341Z","title":"股票/股票初级","comments":1,"layout":"post","photos":[],"link":"","_id":"ckppj72ng0004i1gi9uunhqja","content":"<h1 id=\"股票初级\"><a href=\"#股票初级\" class=\"headerlink\" title=\"股票初级\"></a>股票初级</h1><h2 id=\"股票入门\"><a href=\"#股票入门\" class=\"headerlink\" title=\"股票入门\"></a>股票入门</h2><h3 id=\"股票投资五大流派\"><a href=\"#股票投资五大流派\" class=\"headerlink\" title=\"股票投资五大流派\"></a>股票投资五大流派</h3><ul>\n<li>技术投资派：通过分析股票的价格走势，来预测股票未来涨跌</li>\n<li>宏观投资派：逻辑是整个市场经济向好，股市就会向好，研究经济就可以指导股票投资</li>\n<li>有效市场派：认为市场大部分时候对股票的定价是正确的</li>\n<li>成长投资派（预测未来）：更关注公司未来是否有足够高的增长</li>\n<li>价值投资派（把握现在）：看重现在公司是否有足够低的价格，低价高卖就是价值投资的本质<h3 id=\"价值投资\"><a href=\"#价值投资\" class=\"headerlink\" title=\"价值投资\"></a>价值投资</h3><h4 id=\"价值投资方法\"><a href=\"#价值投资方法\" class=\"headerlink\" title=\"价值投资方法\"></a>价值投资方法</h4><h5 id=\"捡烟蒂投资法\"><a href=\"#捡烟蒂投资法\" class=\"headerlink\" title=\"捡烟蒂投资法\"></a>捡烟蒂投资法</h5></li>\n<li>本杰明.格雷厄姆：100%价值投资法，独创安全边际理论</li>\n<li>烟蒂股：毫不起眼，甚至被抛弃的公司</li>\n<li>需要的成本远低于本身的价值，继续下跌概率小，上涨概率大于下跌概率<h5 id=\"好公司投资法\"><a href=\"#好公司投资法\" class=\"headerlink\" title=\"好公司投资法\"></a>好公司投资法</h5></li>\n<li>巴菲特：喜欢买好公司，偏爱食品行业</li>\n<li>投资核心：找到好公司，低价买入</li>\n<li>好公司的价值最终一定会显现在股价上</li>\n<li>天时：看准入场时机，在股票市场便宜的时候进场买买买</li>\n<li>一家公司的价值=现在公司的价值+未来公司能赚取的价值</li>\n<li>市盈率(PE)=市值/净利润=买下公司需要的钱/每年能赚到的钱<br>PE越小，回本年限越短，越有投资价值</li>\n<li>市净率（PB)=市值/净资产=买下公司需要的钱/属于公司自己的资产</li>\n<li>PB越小，价格越低，越有投资价值</li>\n<li>A股3000=沪深300+中证500+其他各类股票</li>\n<li>找准入场时机：用沪深300和中证500估值处于低估，此时可入场<br>当沪深300和中证500中任一个PE，PB同时满足：</li>\n</ul>\n<p>1.PE处于近十年数值的0-50%<br>2.PB处于近十年数值的0-20%</p>\n<ul>\n<li>可入场投资的三种情况：<br>沪深300PE，PB同时满足条件，中证500没有满足<br>中证500PE，PB同时满足条件，沪深300没有满足<br>沪深300和中证500的PE，PB都同时满足条件</li>\n<li>实操<br>理杏仁官网-搜索框输入“沪深300”查询该指数的数据<br>选“PE-TTM，加权平均值，十年”，可以看到PE图<br>PE－TTM：就是PE，TTM是一种更为精确计算PE的方式<br>加权平均值：把沪深３００的所有公司的市值相加除以净利润之和，相当于把这３００家公司“合并”成一家大公司计算PE<br>１０年：通常７－１０年，中国股市会经过一个完整的涨跌大周期，选择十年，能较客观地判断当前估值相对于过去１０年是高还是低<br>PE分位点：把过去１０年PE从小到大排序，当前PE所处位置<br>１００％表示当前PE是最大值，５０％表示当前PE处于中间位置<br>点击PB，可以查看PB图<br>搜索中证５００，查看PE，PB<br>判断某天是否适合入场，满足其中一个即可<br>沪深３００当天PE分位点＜５０％且PB分位点＜２０％，十年加权平均值<br>中证５００当天PE分位点＜５０％且PB分位点＜２０％，十年，加权平均值<br>地利：合理布局资金，建立自己的投资组合，规避风险<br>股市风险<br>系统性风险:整个股票市场存在的下跌风险，我们需先估值再入市<br>政策风险:政策改变导致企业生存条件变化<br>购买力风险:通货膨胀的风险<br>利率风险:市场利率会不断波动<br>非系统性风险:单只股票本身的风险<br>经营风险:公司经营的错误决策可能导致公司业绩大幅下滑<br>信用风险:公司违背信用所产生的风险<br>道德风险:违背道德事件，如三鹿的“毒奶粉事件”<br>规避风险<br>规避系统风险:先估值再入市<br>规避非系统风险:构建组合投资，资金分散到多个行业的多个股票上，鸡蛋不要放在同一个篮子里<br>回避风险时，并不是买的股票越多越科学，持有4-8只股票是比较经济，有效的做法<br>分散行业：同行业资金占比不要超过30%<br>人和：学会建设过硬的心理素质<br>白马组合<br>“好公司”投资法：赚业绩提升的钱<br>初筛白马股<br>买股票的条件<br>资金：投资的必要条件<br>心态：优秀投资者必备的素质<br>选股：开始买股票最重要的事情，一个好的股票，上涨的时候更多的回报，下跌的时候更大的耐心<br>头脑清晰，理性看待价格上涨<br>可能跟随价值上涨<br>可能只是围绕价值波动<br>白马股票：信息相对可靠，长期业绩优秀，投资回报率高<br>投资回报率：投资多少和能赚多少的比例<br>股票投资回报率就是投资收益率=[（卖出价格/买入价格）-1]<em>100%<br>年化复合收益率=【（卖出价格/买入价格）^（1/n）-1】</em>100%，n是投资年限<br>净资产收益率（ROE）=净利润/净资产，代表了企业赚钱能力<br>ROE越高，股票的年化收益率就越高<br>初筛条件<br>ROE连续7年&gt;=15%<br>上市时间&gt;5年，因为上市时间太短的话，业绩不够稳定<br>初筛方法</li>\n</ul>\n<p>1.打开同花顺旗下“i问财”网站（<a href=\"https://www.iwencai.com）\" target=\"_blank\" rel=\"noopener\">https://www.iwencai.com）</a><br>2.文本框输入查询条件：2012年到2018年ROE大于等于15%，2019年06月30日ROE大于等于7.5%，上市时间大于5年，点击按钮“问一下财”，系统自动识别条件，并把输入的条件用“且”的关系关联起来，查出股票数据<br>3.初步筛选出了43个白马股了，可以导出数据<br>注意：财报披露是有延迟的（速记：1214）<br>第一季度结束后一个月内公布<br>第二个季度结束后两个月内公布<br>第三季度结束后一个月内公布<br>第四季度即年报是结束后4个月内公布<br>剔除周期股<br>经济周期：国民经济呈现扩张与紧缩交替波动变化<br>必然发生<br>循环往复：复苏，繁荣，衰退，萧条，类似四季循环<br>周期性行业：业绩紧跟经济周期起起伏伏，比如：汽车行业<br>非周期性行业：受经济周期影响较小，经营业绩更稳定，比如：医药行业，食品行业<br>周期股：受经济周期影响大，所处行业属于周期性行业<br>四类要避开的行业（周期性行业）<br>作为工业基础原材料的大宗商品相关行业（主要用于经济发展）<br>比如：采掘服务，钢铁，化工合成材料，化工新材料，石油矿业开采，化学制品等<br>航运业（运输货物）<br>比如：远洋运输，港口航运，机场航运，交通设备服务等<br>非生活必需品行业，及与之相关的行业（非必需）<br>如：国防军工，汽车零件，汽车，建筑材料，建筑装饰，房地产等<br>非银行的金融行业<br>如：证券，保险及其他<br>方法<br>1.“i问财”中初筛白马股，输入查询条件：2012年到2018年ROE大于等于15%，2019年06月30日ROE大于等于7.5%，上市时间大于5年，行业。点击按钮“问一下财”，查询数据并导出<br>2.剔除周期股，打开表格，把所属行业是周期性行业的数据剔除<br>剔除基本面转坏的股票<br>评估业绩下滑，四个指标有一个为负数就剔除该股<br>最近年度营收增长率 = （本年营业收入 - 去年营业收入） / 去年营业收入<br>最近年度净利润增长率 = （本年净利润 - 去年净利润） / 去年净利润<br>最近季度营收增长率 = （本季度营业收入 - 去年同季度营业收入） / 去年同季度营业收入<br>最近季度净利润增长率 = （本季度净利润 - 去年同季度净利润） / 去年同季度净利润<br>方法<br>1.“i问财”输入查询条件：2012年到2018年ROE大于等于15%，2019年6月30日ROE大于等于7.5%，营收增长率和净利润增长率，上市时间大于5年，行业，2018年营收增长率和净利润增长率<br>2.去掉不必要的列，导出数据<br>3.导出的表格筛选行业，去掉周期性行业<br>4.筛选出最近季度和最近年度的营收增长率和净利润增长率大于0，排除掉小于0的即业绩下滑的股<br>财报三表分析<br>财报：记录公司所有经营事务的报表，分为季度报表，半年报表，年度报表<br>利润表（损益表）：体现公司在一段时间内是赚钱还是亏钱<br>营业利润=营业收入 - 营业成本 - 三费<br>营业收入：卖东西的收入，只要卖出东西，无论是否收到钱都计入<br>营业成本：购买生产货物的原材料等所付出的钱<br>三费：管理费用，销售费用，财务费用<br>净利润 = 营业利润 - 所得税<br>资产负债表<br>记录某时公司有多少钱，财，物以及欠别人多少钱<br>现金流量表<br>公司现金流入流出情况，开支流水账，记录花出去多少钱，收到多少钱<br>经营活动现金流量<br>利润表<br>投资现金流量<br>资产<br>筹资活动现金流量<br>负债<br>识别信息相对可靠<br>如何识别收入美化，识别真货假卖<br>小熊定理1：识别真货假卖，是否存在连续两年应收账款增长幅度大于营收增长幅度，存在则不通过检验<br>实操方法<br>理杏仁-输入查询的某股票<br>利润表-我们需要了解最近3年增长情况，所以查询最近4年数据<br>找到营业收入，把数据复制进表格中,计算每年营业收入增长金额<br>资产负债表-应收账款-数据复制进表格，计算每年应收账款增长金额<br>每年应收账款增长金额-营业收入增长金额算出结果，如果连续两年结果大于0，表示连续两年应收账款增长幅度大于营业收入增长幅度，则不通过小熊定理1，要当心<br>如何识别资产美化<br>资产负债表：记录公司某时有多少钱财物，欠多少钱<br>资产<br>货币资金（现金）：顾客找零，临时补货等<br>应收账款：白条，别人欠你的钱<br>存货：原材料和耗材等<br>预付款项：预先支出房租等<br>固定资产：设备，厂房，土地等<br>负债<br>应付款项：欠供应商的贷款<br>短期借款：如借朋友的钱，一年内还<br>长期借款：如借银行的钱，为期5年<br>所有者权益（净资产）：属于公司自己的<br>资本公积金<br>未分配利润<br>核心：资产=负债+所有者权益<br>问题主要在存货上，存货不仅指生产出的货物，还包括生产用的原材料，生产过程中的半成品，财报的存货只能看到资金总额，这就给了别有用心的公司一个机会<br>识别存货造假<br>小熊定理2：连续两年存货增长大于营业收入增长，这家公司存货可能有问题<br>实操方法<br>1.理杏仁网站查询某股票信息，在利润表中找到连续4年的营业收入数据，并计算出营业收入增长金额<br>2.在资产负债表中找到连续4年的存货数据，并计算存货增长金额<br>3.验证小熊定理2，比较每年营业收入增长金额和存货增长的差异，用当年存货增长减去营业收入增长金额<br>结果大于0，说明存货涨幅更大，小于0则说明营业收入丈夫更大<br>当出现连续2年结果都大于0，说明公司连续两年存货增长金额大于营业收入增长金额，不通过小熊定理2，要当心了<br>识别资产安全（鉴别公司是否有破产的风险）<br>小熊定理3：如果一家公司的流动负债远大于流动资产的话，说明这家公司已经非常接近破产了<br>流动资产：一年内可以变现的资产，如货币资金，存货，预付款项<br>流动负债：一年内必须要还的钱，如应付账款，短期借款<br>流动比率 = 流动资产 / 流动负债<br>如果流动比率小于1，说明流动资产小于流动负债，危险的信号<br>实操方法<br>理杏仁-查询股票资产负债表中最近3年的流动比率，最近3年有2年都小于1就要当心了<br>i问财也可以查询<br>除银行股外，所选公司只要有一个定理不能通过检验，就要剔除<br>小熊定理1能看出公司是否有美化收入嫌疑<br>小熊定理2能看出公司是否有美化资产的嫌疑<br>小熊定理3能轻松鉴别公司是否有破产风险<br>自由现金流如此重要，加分项<br>小熊定理4：当一家公司经营活动现金流量净额远大于净利润，说明这家公司可能有隐藏的盈利能力，有可能是座金矿<br>理杏仁-查询公司-现金流量表-近三年经营活动产生的现金流量净额-和净利润对比<br>小熊定理5：自由现金流是衡量公司现金流情况的指标，代表公司真正能自由运用的资金，比净利润更真实，更难作假<br>自由现金流=经营活动产生的现金流量净额-资本开支<br>资本开支是现金流量表中的购建固定资产，无形资产和其他长期资产支付的现金<br>理杏仁-查询公司-财务指标-现金流量里面的自由现金流大于0就加分了<br>实操：构建白马组合<br>筛选步骤<br>投资回报率高<br>ROE连续7年大于等于15%，上市时间大于5年<br>长期业绩优秀<br>剔除周期股，看行业<br>剔除当下业绩显现下滑迹象的公司<br>信息相对可靠<br>小熊三大定理检验经过筛选的股票，财报信息是否可靠<br>判断股票价格<br>股票的贵与便宜相对价值而言的，估值体现价格和价值的关系<br>PE分位点和PB分位点小于50%<br>理杏仁-查询公司-价值分析-PE分位点和PB分位点（10年数据）历史看前复权，现在看股价<br>怎么买<br>PE分位点升序排列，优先买PE分位点低的，平均分配资金<br>PE升序，整理筛选出来的公司<br>找出它们当时的股价，计算购买一手的价格<br>根据资金量分配选择股票数量，同行业不能超过30%，行业看二级行业<br>同行业股票数量不超过30%，即公司数量不超过30%<br>同行业资金占比也不超过30%<br>卖出<br>股票价格高于价值了，你贵了<br>基本面转坏了，你变了，每年一次筛选对比<br>发现更好更便宜的，别人比你更好了<br>稳住心态，长期持有<br>短期可能下跌，长期价格回归价值<br>总结<br>PE分位点升序排列，优先买PE分位点低的，平均分配资金<br>每年筛选一次对比调仓，贵了，变了就剔除<br>干货补充<br>容易出白马股的行业，一般来说，有护城河的公司都会有较高的投资回报率，也有不错的业绩。<br>护城河<br>无形资产护城河：看不见摸不到的资产<br>品牌护城河：大家耳熟能详的各种品牌，就是公司想要打造的品牌护城河<br>品牌溢价护城河：可以卖得比同类产品贵的能力，就是品牌溢价能力，这种公司就有品牌 溢价护城河。<br>有这种护城河的公司产品，即使价格卖得高卖得贵，消费者为了这个牌子也 会买，比如说贵州茅台，比如说苹果手机。<br>品牌搜索护城河：有这种护城河的公司产品，在我们想买什么的时候，会出现在我们脑子里。<br>比如说我们想买牛奶，第一反应可能是伊利，可能是蒙牛<br>专利护城河：专利就是只有我有的权利<br>有专利护城河的公司，就是那种可以持续性研发出产品，并且申请出专利的 公司，比如说大型药厂<br>政府授权护城河:政府授权的是你能不能进入这个行业<br>比较典型的有这个护城河的公司是赌场，在内地，赌场就禁止经营，而澳门现在也不会批准建新的赌场，所以，澳门那几家赌场的竞争对手并不会增加！<br>转换成本护城河<br>如果一个产品的用户，更换这个产品时需要付出很多代价或成本，我们就说 这个产品具有转换成本，这家公司具有转换成本护城河。<br>如果一家医院要换信息系统，它会面临怎样的麻 烦？<br>数据转移<br>医生，护士学习新系统<br>核对旧病例，导入是否完整<br>网络效应护城河<br>严格来说是转换成本的一种。 因为互联网的日益发达，受到了越来越多的重视，很典型的公司就是腾讯控股。<br>像微信这种，随着使用人数的增多，产品价值越高的公司，就是有网络效应 护城河的公司。<br>规模效应护城河<br>规模带来的效应，生产数量越多固定资产成本越低<br>固定成本（厂房设备等固定资产）的总额不会随着成品数量变化，但是 随着生产数量的增多，每个产品中固定成本的量会变小。<br>易出护城河的行业（速记：白衣小软妹），可以优先选择好行业里的公司<br>白酒行业、医药行业、软件行业、媒体行业、消费行业<br>通过估值四象限快速判断一家公司的状态<br>PE 是从企业盈利的角度考察现在的股价是不是合理，而 PB 是从企业的净资产角度考察现在的股价是不是合理。粗略来分，我们可以把大于 50%的分位点称为高，把小于 50%的分位点称 为低。<br>估值四象限<br>第一象限：高 PB，高 PE<br>泡沫象限，远离<br>pe、pb 越高，说明整个 市场越贵，下跌的可能越大。<br>被疯狂炒作的个股，比方说 2015 年妖股第一名暴风集团。<br>第二象限：低 PB，高 PE，分析公司业绩未来是否有变好的可能<br>企业自身运营不善，避开<br>周期性行业低估期，买入持有至行业回暖，也有可观的收益<br>第三象限：低 PB，低 PE，大概率是比较合适的投资机会，辨别PE是真低还是价低（盈利能力下降，财报是否体现）<br>市场处于熊市的末期，此时由于熊市长期的下跌导致大家的投 资情绪都过于悲观，会使得很多股票的价格跌到实际价值以下，出现大量的低 PB、低 PE 股票，这时候意味着，投资的机会来了。<br>企业遭遇经营困境、或行业政策、竞争态势等外部环境发生 不利变化。由于市场有时会提前并且迅速做出反应，导致公司股价下降，市 值变得很低，自然的 PB 就会很低。<br>PE“真低”<br>财报中的数据已经显示出公司盈利能力的下降，投资者们 看到公司盈利下降了，纷纷卖出，公司市值必然下降，市值与净利润同时下降导 致的低 PE，就是 PE“真低”。只要公司未来盈利能力可以恢复，就是好的入场 时机。<br>PE“假低”<br>公司业绩的披露有滞后性，而 PE 的计算又是基于最近披露的净利润， 所以当最近一期公司财报并没有显示出业绩下滑，也就是说净利润仍然是高的， pe=市值/净利润，公司的 PE 依然很低。<br>一旦未来公司财报显示出公司的盈利能力快速下滑，那很可能会出现股价越 跌，PE 越高的情况。<br>因为虽然股价在下跌，但盈利下跌速度更快，可能直接跌成负的了。 这就是我们必须尽力避免的低价值陷阱，也就是 PE“假低”。<br>第四象限：高 PB，低 PE<br>英雄象限，避开<br>PB 高，意味着投资者们特别看好公司的发展，对公司的盈利能力有着很高的期待，毕竟市场给予了比净资产高很多倍的溢价嘛！<br>一旦公司盈利不达预期，曾经追捧的那些投资者们就会纷纷弃他而去， 导致股价下跌。<br>PB高，不用管PE低不低，直接避开<br>分红过后需要除权除息，所以股价必然下降<br>分红<br>一种是上市公司直接给股东送股票，这种称为“股票股利”<br>公司的股价=总市值/总股数，总股数增加了，每股的价格当然也会减少，这种行为就叫做除权。<br>另外一种是现金分红，就是公司直接给股东发现金，这种称为“现金股利”<br>发现金股利的时候，会从股价中将这一部分股利扣除，这就叫做除息<br>填权<br>公司的价值短期内变动幅度有限，只要大家看好公司的价值，股 价降低了公司价值没有变，当然会有人去买，因此，除权除息后，股价都会涨回 和原来差不多，这个过程称之为填权。<br>红利税<br>红利税并不是在分红派息那天扣除的，而是在卖出股票的时候 扣除，只要持股超过一年，就不需要缴纳，可见，咱们股市的监管方，也是希望 大家做长期的价值投资者，而非炒作的投机者。<br>什么公司不能碰<br>第一种，大品牌更可靠<br>首先，知名企业有着很大的曝光率，更容易被发现财务造假。<br>其次，他们财务造假的成本太高。<br>第二种，不要 ST。股票名称前带有“ST”、“<em>ST”、“SST”、“S</em>ST”、“NST”标识的， 一定不要投！<br>有上述标识的股票意味着，该公司至少连续两年亏损，将被证监会处理，面 临整改或者退市。<br>ST 代表的就是亏损股<br>第三种，曾经出现过违反道德规范、财报作假等重大丑闻的，被证监会立案调查 还未有结果的公司不要买。<br>只要在百度中用“公司名+证监会”， 这一组关键词搜索，就能看到相关的信息。<br>便宜组合<br>“捡烟蒂”投资法<br>便宜组合：赚股价回升的钱，不太挑剔股票质量，主要看折扣<br>筛选指标<br>双低组合，低PE低PB<br>0&lt;PE&lt;10<br>0&lt;PB&lt;1.5<br>大方分钱<br>股息率&gt;3%<br>股息率=公司过去一年的累计现金分红/公司市值，A股公司平均股息率约为3%<br>实操筛选<br>理杏仁-选股-基本面选股<br>选择范围-A股市场-沪深两市<br>条件设置-基本指标-点击筛选便宜组合的三个指标<br>市盈率选PE-TTM（扣非）<br>扣非：扣除非经常性损益（利润表中一部分和公司正经运营业务无关）<br>不含商誉的PB<br>公司收购其他公司时超过净资产的部分，是资产的一部分，但本质不是真正的资产<br>股息率<br>两个选股条件<br>PB（不含商誉）分位点（10年），股价<br>时间选择最近时间<br>按照筛选条件，选好最大值最小值，开始选股，最后导出文件<br>排序筛选法<br>PE，PB升序排列，股息率降序排列，三个指标排名加总，算出总排名<br>实操<br>分别在PE，PB，股息率右边增加列PE排名，PB排名，股息率排名。再加一列综合排名<br>用RANK.EQ函数计算PE排名，PB排名，股息率排名<br>数值-想要排序的那个数值<br>引用-数值所在的数据集合<br>排序方式<br>1：升序<br>0：降序<br>计算综合排名：把PE排名，PB排名，股息率排名三个排名相加<br>综合排名升序排列<br>具体筛选<br>8-10只构建便宜组合<br>根据综合排名从低到高依次挑选，行业要分散：同一行业公司不要超过30%<br>用PB分位点进一步挑选低估股票，PB分位点&lt;20%加入组合<br>PB（不含商誉）分位点（10年）：把过去10年的PB从小到大排列，现在PB所在的位置<br>PB分位点&lt;20%，现在是低估，适合买入<br>PB分位点&gt;50%，现在是高估，不适合买入<br>资金分配<br>根据资金量确定便宜组合的股票数量<br>同一行业股票数量和资金不超过30%<br>资金均分<br>确定价格最高的买一手，其余股票金额往这个金额上靠就可以了<br>筛选数量不够时<br>放宽筛选条件<br>寻找别的投资机会<br>持币观望，等待入场时机<br>被动投资<br>每隔半年调仓一次，将组合整体估值降低<br>每隔半年重新筛一次便宜组合<br>将最新筛出的便宜组合和原来组合对比<br>新旧组合重合部分保留<br>卖掉旧组合里有，但新组合里没有的股票<br>补入就组合里没有，但新组合里有的股票<br>清楚投资原理，投资方法<br>了解攀升强度，明白回撤幅度<br>具备耐心和坚持才配得上优厚的回报<br>轻松实践<br>买股票常识<br>A股交易时间：周一到周五每天4小时交易时间（法定休假日除外），上午9:30-11:30，下午13:00-15:00<br>K线图（蜡炬图）<br>蜡炬图<br>阳线：红色的，代表股价上涨，当天收盘价大于开盘价即收盘价在上开盘价在下<br>阴线：绿色的，代表股价下跌，当天收盘价小于开盘价即开盘价在上收盘价在下<br>阳线和阴线都有上影线和下影线分部表示最高价和最低价<br>计算周期<br>日K线：最常用，以当天开盘价，收盘价，最高价，最低价来画的Ｋ线图<br>周K线：以周一开盘价，周五收盘价，全周最高价和最低价来画的K线图<br>月K线：以一个月第一个交易日的开盘价，最后一个交易日收盘价，全月最高价和最低价来画的K线图<br>季K线<br>年K线<br>每根Ｋ线下面对应有一条红色或绿色的条形图，代表交易量（一段时间内成交的股票数量，受供求关系影响）<br>交易单位<br>以“手”为单位，１手＝100股, 1-99股称为零股<br>买入最低单位为手<br>分红送股可能有零股，卖出可以有零股，但是零股必须一次性卖出<br>A股交易费用（沪市和深市）<br>无论是基金开的还是咱们股初扫码开的华泰优惠开户，都是调整成股票万分之1.8，起点5元， 基金万分之1，起点0.1元<br>印花税<br>国家税务局<br>卖出收，成交金额的千分之一<br>过户费<br>中登公司<br>买入和卖出都收，成交金额的千分之0.02<br>佣金<br>证交所证券公司<br>买入和卖出都收，最高千分之3，最低5元<br>报价方式<br>限价委托（常用）<br>用户限定价格，价格可控，交易时间不可控<br>好处：价格可控，当股价到达了设置的价格成交<br>坏处：如果股价始终高于限定的价格，就需要耐心等待，也可能当天成交不了<br>市价委托（不常用）<br>只指定交易数量，价格不可控，交易时间可控<br>好处：即时成交<br>坏处：成交价格可能偏贵<br>特色<br>涨跌停板制度<br>股票上涨幅度和下跌幅度只能是上一个交易日收盘价的10%<br>ST开头的股票，每日涨跌停幅度限制只有5%<br>新股首日上市股价涨幅不受10%限制，但是最高幅度不能超过发行价的44%<br>交易制度：T+1交易，忌频繁交易<br>当天买入的证券不能当天卖出，第二天才可以卖出<br>当天卖出股票收回的资金只能用来买新的股票，不能提取。第二天才可提取<br>人和：股海沉浮，锦囊妙计<br>1.贪多嚼不烂<br>入门简单，严格执行投资计划，会获得合理收益的。精通难，想要超额收益，需要付出超额努力<br>2.笑看涨跌，波澜不惊<br>面对股价大幅度下跌，要相信组合的力量，不要每天看盘，一个月一次就够了<br>3.保持耐心，长期持有<br>时间是财富自由的基本条件#</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"股票初级\"><a href=\"#股票初级\" class=\"headerlink\" title=\"股票初级\"></a>股票初级</h1><h2 id=\"股票入门\"><a href=\"#股票入门\" class=\"headerlink\" title=\"股票入门\"></a>股票入门</h2><h3 id=\"股票投资五大流派\"><a href=\"#股票投资五大流派\" class=\"headerlink\" title=\"股票投资五大流派\"></a>股票投资五大流派</h3><ul>\n<li>技术投资派：通过分析股票的价格走势，来预测股票未来涨跌</li>\n<li>宏观投资派：逻辑是整个市场经济向好，股市就会向好，研究经济就可以指导股票投资</li>\n<li>有效市场派：认为市场大部分时候对股票的定价是正确的</li>\n<li>成长投资派（预测未来）：更关注公司未来是否有足够高的增长</li>\n<li>价值投资派（把握现在）：看重现在公司是否有足够低的价格，低价高卖就是价值投资的本质<h3 id=\"价值投资\"><a href=\"#价值投资\" class=\"headerlink\" title=\"价值投资\"></a>价值投资</h3><h4 id=\"价值投资方法\"><a href=\"#价值投资方法\" class=\"headerlink\" title=\"价值投资方法\"></a>价值投资方法</h4><h5 id=\"捡烟蒂投资法\"><a href=\"#捡烟蒂投资法\" class=\"headerlink\" title=\"捡烟蒂投资法\"></a>捡烟蒂投资法</h5></li>\n<li>本杰明.格雷厄姆：100%价值投资法，独创安全边际理论</li>\n<li>烟蒂股：毫不起眼，甚至被抛弃的公司</li>\n<li>需要的成本远低于本身的价值，继续下跌概率小，上涨概率大于下跌概率<h5 id=\"好公司投资法\"><a href=\"#好公司投资法\" class=\"headerlink\" title=\"好公司投资法\"></a>好公司投资法</h5></li>\n<li>巴菲特：喜欢买好公司，偏爱食品行业</li>\n<li>投资核心：找到好公司，低价买入</li>\n<li>好公司的价值最终一定会显现在股价上</li>\n<li>天时：看准入场时机，在股票市场便宜的时候进场买买买</li>\n<li>一家公司的价值=现在公司的价值+未来公司能赚取的价值</li>\n<li>市盈率(PE)=市值/净利润=买下公司需要的钱/每年能赚到的钱<br>PE越小，回本年限越短，越有投资价值</li>\n<li>市净率（PB)=市值/净资产=买下公司需要的钱/属于公司自己的资产</li>\n<li>PB越小，价格越低，越有投资价值</li>\n<li>A股3000=沪深300+中证500+其他各类股票</li>\n<li>找准入场时机：用沪深300和中证500估值处于低估，此时可入场<br>当沪深300和中证500中任一个PE，PB同时满足：</li>\n</ul>\n<p>1.PE处于近十年数值的0-50%<br>2.PB处于近十年数值的0-20%</p>\n<ul>\n<li>可入场投资的三种情况：<br>沪深300PE，PB同时满足条件，中证500没有满足<br>中证500PE，PB同时满足条件，沪深300没有满足<br>沪深300和中证500的PE，PB都同时满足条件</li>\n<li>实操<br>理杏仁官网-搜索框输入“沪深300”查询该指数的数据<br>选“PE-TTM，加权平均值，十年”，可以看到PE图<br>PE－TTM：就是PE，TTM是一种更为精确计算PE的方式<br>加权平均值：把沪深３００的所有公司的市值相加除以净利润之和，相当于把这３００家公司“合并”成一家大公司计算PE<br>１０年：通常７－１０年，中国股市会经过一个完整的涨跌大周期，选择十年，能较客观地判断当前估值相对于过去１０年是高还是低<br>PE分位点：把过去１０年PE从小到大排序，当前PE所处位置<br>１００％表示当前PE是最大值，５０％表示当前PE处于中间位置<br>点击PB，可以查看PB图<br>搜索中证５００，查看PE，PB<br>判断某天是否适合入场，满足其中一个即可<br>沪深３００当天PE分位点＜５０％且PB分位点＜２０％，十年加权平均值<br>中证５００当天PE分位点＜５０％且PB分位点＜２０％，十年，加权平均值<br>地利：合理布局资金，建立自己的投资组合，规避风险<br>股市风险<br>系统性风险:整个股票市场存在的下跌风险，我们需先估值再入市<br>政策风险:政策改变导致企业生存条件变化<br>购买力风险:通货膨胀的风险<br>利率风险:市场利率会不断波动<br>非系统性风险:单只股票本身的风险<br>经营风险:公司经营的错误决策可能导致公司业绩大幅下滑<br>信用风险:公司违背信用所产生的风险<br>道德风险:违背道德事件，如三鹿的“毒奶粉事件”<br>规避风险<br>规避系统风险:先估值再入市<br>规避非系统风险:构建组合投资，资金分散到多个行业的多个股票上，鸡蛋不要放在同一个篮子里<br>回避风险时，并不是买的股票越多越科学，持有4-8只股票是比较经济，有效的做法<br>分散行业：同行业资金占比不要超过30%<br>人和：学会建设过硬的心理素质<br>白马组合<br>“好公司”投资法：赚业绩提升的钱<br>初筛白马股<br>买股票的条件<br>资金：投资的必要条件<br>心态：优秀投资者必备的素质<br>选股：开始买股票最重要的事情，一个好的股票，上涨的时候更多的回报，下跌的时候更大的耐心<br>头脑清晰，理性看待价格上涨<br>可能跟随价值上涨<br>可能只是围绕价值波动<br>白马股票：信息相对可靠，长期业绩优秀，投资回报率高<br>投资回报率：投资多少和能赚多少的比例<br>股票投资回报率就是投资收益率=[（卖出价格/买入价格）-1]<em>100%<br>年化复合收益率=【（卖出价格/买入价格）^（1/n）-1】</em>100%，n是投资年限<br>净资产收益率（ROE）=净利润/净资产，代表了企业赚钱能力<br>ROE越高，股票的年化收益率就越高<br>初筛条件<br>ROE连续7年&gt;=15%<br>上市时间&gt;5年，因为上市时间太短的话，业绩不够稳定<br>初筛方法</li>\n</ul>\n<p>1.打开同花顺旗下“i问财”网站（<a href=\"https://www.iwencai.com）\" target=\"_blank\" rel=\"noopener\">https://www.iwencai.com）</a><br>2.文本框输入查询条件：2012年到2018年ROE大于等于15%，2019年06月30日ROE大于等于7.5%，上市时间大于5年，点击按钮“问一下财”，系统自动识别条件，并把输入的条件用“且”的关系关联起来，查出股票数据<br>3.初步筛选出了43个白马股了，可以导出数据<br>注意：财报披露是有延迟的（速记：1214）<br>第一季度结束后一个月内公布<br>第二个季度结束后两个月内公布<br>第三季度结束后一个月内公布<br>第四季度即年报是结束后4个月内公布<br>剔除周期股<br>经济周期：国民经济呈现扩张与紧缩交替波动变化<br>必然发生<br>循环往复：复苏，繁荣，衰退，萧条，类似四季循环<br>周期性行业：业绩紧跟经济周期起起伏伏，比如：汽车行业<br>非周期性行业：受经济周期影响较小，经营业绩更稳定，比如：医药行业，食品行业<br>周期股：受经济周期影响大，所处行业属于周期性行业<br>四类要避开的行业（周期性行业）<br>作为工业基础原材料的大宗商品相关行业（主要用于经济发展）<br>比如：采掘服务，钢铁，化工合成材料，化工新材料，石油矿业开采，化学制品等<br>航运业（运输货物）<br>比如：远洋运输，港口航运，机场航运，交通设备服务等<br>非生活必需品行业，及与之相关的行业（非必需）<br>如：国防军工，汽车零件，汽车，建筑材料，建筑装饰，房地产等<br>非银行的金融行业<br>如：证券，保险及其他<br>方法<br>1.“i问财”中初筛白马股，输入查询条件：2012年到2018年ROE大于等于15%，2019年06月30日ROE大于等于7.5%，上市时间大于5年，行业。点击按钮“问一下财”，查询数据并导出<br>2.剔除周期股，打开表格，把所属行业是周期性行业的数据剔除<br>剔除基本面转坏的股票<br>评估业绩下滑，四个指标有一个为负数就剔除该股<br>最近年度营收增长率 = （本年营业收入 - 去年营业收入） / 去年营业收入<br>最近年度净利润增长率 = （本年净利润 - 去年净利润） / 去年净利润<br>最近季度营收增长率 = （本季度营业收入 - 去年同季度营业收入） / 去年同季度营业收入<br>最近季度净利润增长率 = （本季度净利润 - 去年同季度净利润） / 去年同季度净利润<br>方法<br>1.“i问财”输入查询条件：2012年到2018年ROE大于等于15%，2019年6月30日ROE大于等于7.5%，营收增长率和净利润增长率，上市时间大于5年，行业，2018年营收增长率和净利润增长率<br>2.去掉不必要的列，导出数据<br>3.导出的表格筛选行业，去掉周期性行业<br>4.筛选出最近季度和最近年度的营收增长率和净利润增长率大于0，排除掉小于0的即业绩下滑的股<br>财报三表分析<br>财报：记录公司所有经营事务的报表，分为季度报表，半年报表，年度报表<br>利润表（损益表）：体现公司在一段时间内是赚钱还是亏钱<br>营业利润=营业收入 - 营业成本 - 三费<br>营业收入：卖东西的收入，只要卖出东西，无论是否收到钱都计入<br>营业成本：购买生产货物的原材料等所付出的钱<br>三费：管理费用，销售费用，财务费用<br>净利润 = 营业利润 - 所得税<br>资产负债表<br>记录某时公司有多少钱，财，物以及欠别人多少钱<br>现金流量表<br>公司现金流入流出情况，开支流水账，记录花出去多少钱，收到多少钱<br>经营活动现金流量<br>利润表<br>投资现金流量<br>资产<br>筹资活动现金流量<br>负债<br>识别信息相对可靠<br>如何识别收入美化，识别真货假卖<br>小熊定理1：识别真货假卖，是否存在连续两年应收账款增长幅度大于营收增长幅度，存在则不通过检验<br>实操方法<br>理杏仁-输入查询的某股票<br>利润表-我们需要了解最近3年增长情况，所以查询最近4年数据<br>找到营业收入，把数据复制进表格中,计算每年营业收入增长金额<br>资产负债表-应收账款-数据复制进表格，计算每年应收账款增长金额<br>每年应收账款增长金额-营业收入增长金额算出结果，如果连续两年结果大于0，表示连续两年应收账款增长幅度大于营业收入增长幅度，则不通过小熊定理1，要当心<br>如何识别资产美化<br>资产负债表：记录公司某时有多少钱财物，欠多少钱<br>资产<br>货币资金（现金）：顾客找零，临时补货等<br>应收账款：白条，别人欠你的钱<br>存货：原材料和耗材等<br>预付款项：预先支出房租等<br>固定资产：设备，厂房，土地等<br>负债<br>应付款项：欠供应商的贷款<br>短期借款：如借朋友的钱，一年内还<br>长期借款：如借银行的钱，为期5年<br>所有者权益（净资产）：属于公司自己的<br>资本公积金<br>未分配利润<br>核心：资产=负债+所有者权益<br>问题主要在存货上，存货不仅指生产出的货物，还包括生产用的原材料，生产过程中的半成品，财报的存货只能看到资金总额，这就给了别有用心的公司一个机会<br>识别存货造假<br>小熊定理2：连续两年存货增长大于营业收入增长，这家公司存货可能有问题<br>实操方法<br>1.理杏仁网站查询某股票信息，在利润表中找到连续4年的营业收入数据，并计算出营业收入增长金额<br>2.在资产负债表中找到连续4年的存货数据，并计算存货增长金额<br>3.验证小熊定理2，比较每年营业收入增长金额和存货增长的差异，用当年存货增长减去营业收入增长金额<br>结果大于0，说明存货涨幅更大，小于0则说明营业收入丈夫更大<br>当出现连续2年结果都大于0，说明公司连续两年存货增长金额大于营业收入增长金额，不通过小熊定理2，要当心了<br>识别资产安全（鉴别公司是否有破产的风险）<br>小熊定理3：如果一家公司的流动负债远大于流动资产的话，说明这家公司已经非常接近破产了<br>流动资产：一年内可以变现的资产，如货币资金，存货，预付款项<br>流动负债：一年内必须要还的钱，如应付账款，短期借款<br>流动比率 = 流动资产 / 流动负债<br>如果流动比率小于1，说明流动资产小于流动负债，危险的信号<br>实操方法<br>理杏仁-查询股票资产负债表中最近3年的流动比率，最近3年有2年都小于1就要当心了<br>i问财也可以查询<br>除银行股外，所选公司只要有一个定理不能通过检验，就要剔除<br>小熊定理1能看出公司是否有美化收入嫌疑<br>小熊定理2能看出公司是否有美化资产的嫌疑<br>小熊定理3能轻松鉴别公司是否有破产风险<br>自由现金流如此重要，加分项<br>小熊定理4：当一家公司经营活动现金流量净额远大于净利润，说明这家公司可能有隐藏的盈利能力，有可能是座金矿<br>理杏仁-查询公司-现金流量表-近三年经营活动产生的现金流量净额-和净利润对比<br>小熊定理5：自由现金流是衡量公司现金流情况的指标，代表公司真正能自由运用的资金，比净利润更真实，更难作假<br>自由现金流=经营活动产生的现金流量净额-资本开支<br>资本开支是现金流量表中的购建固定资产，无形资产和其他长期资产支付的现金<br>理杏仁-查询公司-财务指标-现金流量里面的自由现金流大于0就加分了<br>实操：构建白马组合<br>筛选步骤<br>投资回报率高<br>ROE连续7年大于等于15%，上市时间大于5年<br>长期业绩优秀<br>剔除周期股，看行业<br>剔除当下业绩显现下滑迹象的公司<br>信息相对可靠<br>小熊三大定理检验经过筛选的股票，财报信息是否可靠<br>判断股票价格<br>股票的贵与便宜相对价值而言的，估值体现价格和价值的关系<br>PE分位点和PB分位点小于50%<br>理杏仁-查询公司-价值分析-PE分位点和PB分位点（10年数据）历史看前复权，现在看股价<br>怎么买<br>PE分位点升序排列，优先买PE分位点低的，平均分配资金<br>PE升序，整理筛选出来的公司<br>找出它们当时的股价，计算购买一手的价格<br>根据资金量分配选择股票数量，同行业不能超过30%，行业看二级行业<br>同行业股票数量不超过30%，即公司数量不超过30%<br>同行业资金占比也不超过30%<br>卖出<br>股票价格高于价值了，你贵了<br>基本面转坏了，你变了，每年一次筛选对比<br>发现更好更便宜的，别人比你更好了<br>稳住心态，长期持有<br>短期可能下跌，长期价格回归价值<br>总结<br>PE分位点升序排列，优先买PE分位点低的，平均分配资金<br>每年筛选一次对比调仓，贵了，变了就剔除<br>干货补充<br>容易出白马股的行业，一般来说，有护城河的公司都会有较高的投资回报率，也有不错的业绩。<br>护城河<br>无形资产护城河：看不见摸不到的资产<br>品牌护城河：大家耳熟能详的各种品牌，就是公司想要打造的品牌护城河<br>品牌溢价护城河：可以卖得比同类产品贵的能力，就是品牌溢价能力，这种公司就有品牌 溢价护城河。<br>有这种护城河的公司产品，即使价格卖得高卖得贵，消费者为了这个牌子也 会买，比如说贵州茅台，比如说苹果手机。<br>品牌搜索护城河：有这种护城河的公司产品，在我们想买什么的时候，会出现在我们脑子里。<br>比如说我们想买牛奶，第一反应可能是伊利，可能是蒙牛<br>专利护城河：专利就是只有我有的权利<br>有专利护城河的公司，就是那种可以持续性研发出产品，并且申请出专利的 公司，比如说大型药厂<br>政府授权护城河:政府授权的是你能不能进入这个行业<br>比较典型的有这个护城河的公司是赌场，在内地，赌场就禁止经营，而澳门现在也不会批准建新的赌场，所以，澳门那几家赌场的竞争对手并不会增加！<br>转换成本护城河<br>如果一个产品的用户，更换这个产品时需要付出很多代价或成本，我们就说 这个产品具有转换成本，这家公司具有转换成本护城河。<br>如果一家医院要换信息系统，它会面临怎样的麻 烦？<br>数据转移<br>医生，护士学习新系统<br>核对旧病例，导入是否完整<br>网络效应护城河<br>严格来说是转换成本的一种。 因为互联网的日益发达，受到了越来越多的重视，很典型的公司就是腾讯控股。<br>像微信这种，随着使用人数的增多，产品价值越高的公司，就是有网络效应 护城河的公司。<br>规模效应护城河<br>规模带来的效应，生产数量越多固定资产成本越低<br>固定成本（厂房设备等固定资产）的总额不会随着成品数量变化，但是 随着生产数量的增多，每个产品中固定成本的量会变小。<br>易出护城河的行业（速记：白衣小软妹），可以优先选择好行业里的公司<br>白酒行业、医药行业、软件行业、媒体行业、消费行业<br>通过估值四象限快速判断一家公司的状态<br>PE 是从企业盈利的角度考察现在的股价是不是合理，而 PB 是从企业的净资产角度考察现在的股价是不是合理。粗略来分，我们可以把大于 50%的分位点称为高，把小于 50%的分位点称 为低。<br>估值四象限<br>第一象限：高 PB，高 PE<br>泡沫象限，远离<br>pe、pb 越高，说明整个 市场越贵，下跌的可能越大。<br>被疯狂炒作的个股，比方说 2015 年妖股第一名暴风集团。<br>第二象限：低 PB，高 PE，分析公司业绩未来是否有变好的可能<br>企业自身运营不善，避开<br>周期性行业低估期，买入持有至行业回暖，也有可观的收益<br>第三象限：低 PB，低 PE，大概率是比较合适的投资机会，辨别PE是真低还是价低（盈利能力下降，财报是否体现）<br>市场处于熊市的末期，此时由于熊市长期的下跌导致大家的投 资情绪都过于悲观，会使得很多股票的价格跌到实际价值以下，出现大量的低 PB、低 PE 股票，这时候意味着，投资的机会来了。<br>企业遭遇经营困境、或行业政策、竞争态势等外部环境发生 不利变化。由于市场有时会提前并且迅速做出反应，导致公司股价下降，市 值变得很低，自然的 PB 就会很低。<br>PE“真低”<br>财报中的数据已经显示出公司盈利能力的下降，投资者们 看到公司盈利下降了，纷纷卖出，公司市值必然下降，市值与净利润同时下降导 致的低 PE，就是 PE“真低”。只要公司未来盈利能力可以恢复，就是好的入场 时机。<br>PE“假低”<br>公司业绩的披露有滞后性，而 PE 的计算又是基于最近披露的净利润， 所以当最近一期公司财报并没有显示出业绩下滑，也就是说净利润仍然是高的， pe=市值/净利润，公司的 PE 依然很低。<br>一旦未来公司财报显示出公司的盈利能力快速下滑，那很可能会出现股价越 跌，PE 越高的情况。<br>因为虽然股价在下跌，但盈利下跌速度更快，可能直接跌成负的了。 这就是我们必须尽力避免的低价值陷阱，也就是 PE“假低”。<br>第四象限：高 PB，低 PE<br>英雄象限，避开<br>PB 高，意味着投资者们特别看好公司的发展，对公司的盈利能力有着很高的期待，毕竟市场给予了比净资产高很多倍的溢价嘛！<br>一旦公司盈利不达预期，曾经追捧的那些投资者们就会纷纷弃他而去， 导致股价下跌。<br>PB高，不用管PE低不低，直接避开<br>分红过后需要除权除息，所以股价必然下降<br>分红<br>一种是上市公司直接给股东送股票，这种称为“股票股利”<br>公司的股价=总市值/总股数，总股数增加了，每股的价格当然也会减少，这种行为就叫做除权。<br>另外一种是现金分红，就是公司直接给股东发现金，这种称为“现金股利”<br>发现金股利的时候，会从股价中将这一部分股利扣除，这就叫做除息<br>填权<br>公司的价值短期内变动幅度有限，只要大家看好公司的价值，股 价降低了公司价值没有变，当然会有人去买，因此，除权除息后，股价都会涨回 和原来差不多，这个过程称之为填权。<br>红利税<br>红利税并不是在分红派息那天扣除的，而是在卖出股票的时候 扣除，只要持股超过一年，就不需要缴纳，可见，咱们股市的监管方，也是希望 大家做长期的价值投资者，而非炒作的投机者。<br>什么公司不能碰<br>第一种，大品牌更可靠<br>首先，知名企业有着很大的曝光率，更容易被发现财务造假。<br>其次，他们财务造假的成本太高。<br>第二种，不要 ST。股票名称前带有“ST”、“<em>ST”、“SST”、“S</em>ST”、“NST”标识的， 一定不要投！<br>有上述标识的股票意味着，该公司至少连续两年亏损，将被证监会处理，面 临整改或者退市。<br>ST 代表的就是亏损股<br>第三种，曾经出现过违反道德规范、财报作假等重大丑闻的，被证监会立案调查 还未有结果的公司不要买。<br>只要在百度中用“公司名+证监会”， 这一组关键词搜索，就能看到相关的信息。<br>便宜组合<br>“捡烟蒂”投资法<br>便宜组合：赚股价回升的钱，不太挑剔股票质量，主要看折扣<br>筛选指标<br>双低组合，低PE低PB<br>0&lt;PE&lt;10<br>0&lt;PB&lt;1.5<br>大方分钱<br>股息率&gt;3%<br>股息率=公司过去一年的累计现金分红/公司市值，A股公司平均股息率约为3%<br>实操筛选<br>理杏仁-选股-基本面选股<br>选择范围-A股市场-沪深两市<br>条件设置-基本指标-点击筛选便宜组合的三个指标<br>市盈率选PE-TTM（扣非）<br>扣非：扣除非经常性损益（利润表中一部分和公司正经运营业务无关）<br>不含商誉的PB<br>公司收购其他公司时超过净资产的部分，是资产的一部分，但本质不是真正的资产<br>股息率<br>两个选股条件<br>PB（不含商誉）分位点（10年），股价<br>时间选择最近时间<br>按照筛选条件，选好最大值最小值，开始选股，最后导出文件<br>排序筛选法<br>PE，PB升序排列，股息率降序排列，三个指标排名加总，算出总排名<br>实操<br>分别在PE，PB，股息率右边增加列PE排名，PB排名，股息率排名。再加一列综合排名<br>用RANK.EQ函数计算PE排名，PB排名，股息率排名<br>数值-想要排序的那个数值<br>引用-数值所在的数据集合<br>排序方式<br>1：升序<br>0：降序<br>计算综合排名：把PE排名，PB排名，股息率排名三个排名相加<br>综合排名升序排列<br>具体筛选<br>8-10只构建便宜组合<br>根据综合排名从低到高依次挑选，行业要分散：同一行业公司不要超过30%<br>用PB分位点进一步挑选低估股票，PB分位点&lt;20%加入组合<br>PB（不含商誉）分位点（10年）：把过去10年的PB从小到大排列，现在PB所在的位置<br>PB分位点&lt;20%，现在是低估，适合买入<br>PB分位点&gt;50%，现在是高估，不适合买入<br>资金分配<br>根据资金量确定便宜组合的股票数量<br>同一行业股票数量和资金不超过30%<br>资金均分<br>确定价格最高的买一手，其余股票金额往这个金额上靠就可以了<br>筛选数量不够时<br>放宽筛选条件<br>寻找别的投资机会<br>持币观望，等待入场时机<br>被动投资<br>每隔半年调仓一次，将组合整体估值降低<br>每隔半年重新筛一次便宜组合<br>将最新筛出的便宜组合和原来组合对比<br>新旧组合重合部分保留<br>卖掉旧组合里有，但新组合里没有的股票<br>补入就组合里没有，但新组合里有的股票<br>清楚投资原理，投资方法<br>了解攀升强度，明白回撤幅度<br>具备耐心和坚持才配得上优厚的回报<br>轻松实践<br>买股票常识<br>A股交易时间：周一到周五每天4小时交易时间（法定休假日除外），上午9:30-11:30，下午13:00-15:00<br>K线图（蜡炬图）<br>蜡炬图<br>阳线：红色的，代表股价上涨，当天收盘价大于开盘价即收盘价在上开盘价在下<br>阴线：绿色的，代表股价下跌，当天收盘价小于开盘价即开盘价在上收盘价在下<br>阳线和阴线都有上影线和下影线分部表示最高价和最低价<br>计算周期<br>日K线：最常用，以当天开盘价，收盘价，最高价，最低价来画的Ｋ线图<br>周K线：以周一开盘价，周五收盘价，全周最高价和最低价来画的K线图<br>月K线：以一个月第一个交易日的开盘价，最后一个交易日收盘价，全月最高价和最低价来画的K线图<br>季K线<br>年K线<br>每根Ｋ线下面对应有一条红色或绿色的条形图，代表交易量（一段时间内成交的股票数量，受供求关系影响）<br>交易单位<br>以“手”为单位，１手＝100股, 1-99股称为零股<br>买入最低单位为手<br>分红送股可能有零股，卖出可以有零股，但是零股必须一次性卖出<br>A股交易费用（沪市和深市）<br>无论是基金开的还是咱们股初扫码开的华泰优惠开户，都是调整成股票万分之1.8，起点5元， 基金万分之1，起点0.1元<br>印花税<br>国家税务局<br>卖出收，成交金额的千分之一<br>过户费<br>中登公司<br>买入和卖出都收，成交金额的千分之0.02<br>佣金<br>证交所证券公司<br>买入和卖出都收，最高千分之3，最低5元<br>报价方式<br>限价委托（常用）<br>用户限定价格，价格可控，交易时间不可控<br>好处：价格可控，当股价到达了设置的价格成交<br>坏处：如果股价始终高于限定的价格，就需要耐心等待，也可能当天成交不了<br>市价委托（不常用）<br>只指定交易数量，价格不可控，交易时间可控<br>好处：即时成交<br>坏处：成交价格可能偏贵<br>特色<br>涨跌停板制度<br>股票上涨幅度和下跌幅度只能是上一个交易日收盘价的10%<br>ST开头的股票，每日涨跌停幅度限制只有5%<br>新股首日上市股价涨幅不受10%限制，但是最高幅度不能超过发行价的44%<br>交易制度：T+1交易，忌频繁交易<br>当天买入的证券不能当天卖出，第二天才可以卖出<br>当天卖出股票收回的资金只能用来买新的股票，不能提取。第二天才可提取<br>人和：股海沉浮，锦囊妙计<br>1.贪多嚼不烂<br>入门简单，严格执行投资计划，会获得合理收益的。精通难，想要超额收益，需要付出超额努力<br>2.笑看涨跌，波澜不惊<br>面对股价大幅度下跌，要相信组合的力量，不要每天看盘，一个月一次就够了<br>3.保持耐心，长期持有<br>时间是财富自由的基本条件#</p>\n"},{"_content":"go的内存管理\n\n\n\ngo和php的区别\n\n\n\ngo项目的调用过程\n\n\n\n\n\nes的日志量\n\n\n\n每一行一个单词\n\n\n\n1：cookie与session的区别\n2：mysql性能优化（慢日志，explain，索引，内存碎片化）\n3：聚簇索引与非聚簇索引（B+树与B树，覆盖索引，普通索引，主键索引）\n4：redis主从同步（日志&&rdb）\n5：redis实现延时队列\n6：令牌桶&&漏斗限流\n7：进程间通信的几种方式与限制条件\n8：项目\n9：三道LeetCode的esay难度题目\n\n\n\n\n\nMySQL的存储引擎的区别\nB树与B+树的区别\nJoin与In的查询效率\n有没有使用分布式或者微服务\n为什么使用SpringBoot而不使用SSM，区别是啥？\nRedis里面使用的Hash算法是什么？\nRedis不设置过期时间，他的过期时间是多久？\n你在系统开发中上从宏观角度有没有一些设计？\nJDK8里面的一些新东西是？\n两个List怎么去重？\nLimit 分页会有什么效率问题？\n\n","source":"_posts/面试/复盘/4.27其他面试.md","raw":"go的内存管理\n\n\n\ngo和php的区别\n\n\n\ngo项目的调用过程\n\n\n\n\n\nes的日志量\n\n\n\n每一行一个单词\n\n\n\n1：cookie与session的区别\n2：mysql性能优化（慢日志，explain，索引，内存碎片化）\n3：聚簇索引与非聚簇索引（B+树与B树，覆盖索引，普通索引，主键索引）\n4：redis主从同步（日志&&rdb）\n5：redis实现延时队列\n6：令牌桶&&漏斗限流\n7：进程间通信的几种方式与限制条件\n8：项目\n9：三道LeetCode的esay难度题目\n\n\n\n\n\nMySQL的存储引擎的区别\nB树与B+树的区别\nJoin与In的查询效率\n有没有使用分布式或者微服务\n为什么使用SpringBoot而不使用SSM，区别是啥？\nRedis里面使用的Hash算法是什么？\nRedis不设置过期时间，他的过期时间是多久？\n你在系统开发中上从宏观角度有没有一些设计？\nJDK8里面的一些新东西是？\n两个List怎么去重？\nLimit 分页会有什么效率问题？\n\n","slug":"面试/复盘/4.27其他面试","published":1,"date":"2020-04-24T09:33:27.593Z","updated":"2020-04-24T09:49:13.576Z","title":"面试/复盘/4.27其他面试","comments":1,"layout":"post","photos":[],"link":"","_id":"ckppj72nn0009i1gi5u011fmy","content":"<p>go的内存管理</p>\n<p>go和php的区别</p>\n<p>go项目的调用过程</p>\n<p>es的日志量</p>\n<p>每一行一个单词</p>\n<p>1：cookie与session的区别<br>2：mysql性能优化（慢日志，explain，索引，内存碎片化）<br>3：聚簇索引与非聚簇索引（B+树与B树，覆盖索引，普通索引，主键索引）<br>4：redis主从同步（日志&amp;&amp;rdb）<br>5：redis实现延时队列<br>6：令牌桶&amp;&amp;漏斗限流<br>7：进程间通信的几种方式与限制条件<br>8：项目<br>9：三道LeetCode的esay难度题目</p>\n<p>MySQL的存储引擎的区别<br>B树与B+树的区别<br>Join与In的查询效率<br>有没有使用分布式或者微服务<br>为什么使用SpringBoot而不使用SSM，区别是啥？<br>Redis里面使用的Hash算法是什么？<br>Redis不设置过期时间，他的过期时间是多久？<br>你在系统开发中上从宏观角度有没有一些设计？<br>JDK8里面的一些新东西是？<br>两个List怎么去重？<br>Limit 分页会有什么效率问题？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>go的内存管理</p>\n<p>go和php的区别</p>\n<p>go项目的调用过程</p>\n<p>es的日志量</p>\n<p>每一行一个单词</p>\n<p>1：cookie与session的区别<br>2：mysql性能优化（慢日志，explain，索引，内存碎片化）<br>3：聚簇索引与非聚簇索引（B+树与B树，覆盖索引，普通索引，主键索引）<br>4：redis主从同步（日志&amp;&amp;rdb）<br>5：redis实现延时队列<br>6：令牌桶&amp;&amp;漏斗限流<br>7：进程间通信的几种方式与限制条件<br>8：项目<br>9：三道LeetCode的esay难度题目</p>\n<p>MySQL的存储引擎的区别<br>B树与B+树的区别<br>Join与In的查询效率<br>有没有使用分布式或者微服务<br>为什么使用SpringBoot而不使用SSM，区别是啥？<br>Redis里面使用的Hash算法是什么？<br>Redis不设置过期时间，他的过期时间是多久？<br>你在系统开发中上从宏观角度有没有一些设计？<br>JDK8里面的一些新东西是？<br>两个List怎么去重？<br>Limit 分页会有什么效率问题？</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck5novm9l00006d8n7mli58r2","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5novm9q00046d8neexfgri9"},{"post_id":"ck5novm9o00016d8nb3vafdn9","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5novm9r00066d8nbl6dbdcj"},{"post_id":"ck5qn1b7h00003v8n3gbo3kdj","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b7p00043v8n0tmbhmxj"},{"post_id":"ck5qn1b7k00013v8n7maydkok","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b7q00063v8nc9z27hju"},{"post_id":"ck5qn1b7o00033v8ng2vrcszt","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b7q00083v8n4kfrct1w"},{"post_id":"ck5qn1b7s000e3v8n5q6g9lny","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b7t000g3v8n7ddh972o"},{"post_id":"ck5qn1b7w000h3v8n2tqr4ykg","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b7z000m3v8nb2ln2pa8"},{"post_id":"ck5qn1b7x000i3v8napp29d7n","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b80000o3v8nh9i10mp2"},{"post_id":"ck5qn1b7y000k3v8n3ekzdyh1","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b81000s3v8na558debt"},{"post_id":"ck5qn1b7y000l3v8n3rui7k3o","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b82000v3v8n3uus67at"},{"post_id":"ck5qn1b7z000n3v8ncp3de2gn","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b83000z3v8n91p7bkjr"},{"post_id":"ck5qn1b81000r3v8ndvfzenfu","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b8400123v8ngxc9bwe7"},{"post_id":"ck5qn1b82000u3v8nhpi5hwkr","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b8500163v8n2qc5b6yj"},{"post_id":"ck5qn1b83000y3v8nb9th7c7r","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b8700193v8na5ro2odq"},{"post_id":"ck5qn1b8400113v8n58eqbqey","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b88001d3v8n8q563a6p"},{"post_id":"ck5qn1b88001c3v8nb52p6t2x","category_id":"ck5nh0lh9000alm8n07qi8iik","_id":"ck5qn1b8b001n3v8n8zr3eerl"},{"post_id":"ck68nkriu0000ou8ngc0b3gu4","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck68nkrj50004ou8n80k9bras"},{"post_id":"ck68nkrj80007ou8n07j5enpf","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck68nkrjb000cou8n0ni28he6"},{"post_id":"ck68nkrj80008ou8n65gq9e8s","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck68nkrjb000eou8ndlzvcbv4"},{"post_id":"ck68nkrj9000aou8n6193021y","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck68nkrjd000hou8nenx295wx"},{"post_id":"ck68nkrja000bou8ncn08f32i","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck68nkrjd000jou8n7d1oao9q"},{"post_id":"ck68nkrjb000dou8nbm9ma4ko","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck68nkrje000mou8n7dg3f1o8"},{"post_id":"ck71t2ttf0004mn8n0lsw1z9l","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2ttq0009mn8ngl4g1xwb"},{"post_id":"ck71t2ttf0005mn8ng1pke3lf","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2ttr000bmn8n8qk3eicg"},{"post_id":"ck71t2ttp0007mn8ndfhh73b6","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2ttt000fmn8n4rmvggwz"},{"post_id":"ck71t2ttq0008mn8nahzycueq","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2ttv000imn8n9ockg2bx"},{"post_id":"ck71t2ttq000amn8nelo246dm","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2ttx000mmn8nd0wt6ne7"},{"post_id":"ck71t2tts000emn8nc759hbmx","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tty000pmn8n14qd7jpg"},{"post_id":"ck71t2ttv000hmn8n8y1329u9","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2ttz000tmn8n1h7m6b50"},{"post_id":"ck71t2ttw000lmn8naakdgtfc","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2ttz000wmn8n9sxraodq"},{"post_id":"ck71t2ttx000omn8ngdalhe78","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tu00010mn8n31ds8pzq"},{"post_id":"ck71t2tty000smn8ncdd5d11g","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tu10013mn8n8a0u64eq"},{"post_id":"ck71t2ttz000vmn8nhbz79ydz","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tu30017mn8nd9r9dzft"},{"post_id":"ck71t2tu0000zmn8n4gxyg6z1","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tu4001amn8ngod92wn2"},{"post_id":"ck71t2tu10012mn8n62k3bnj7","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tu5001dmn8nc4di7x3r"},{"post_id":"ck71t2tu30016mn8n7vyx6jou","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tu6001hmn8n6bfk53nh"},{"post_id":"ck71t2tu30019mn8na5r03513","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tu7001kmn8nfn016ht7"},{"post_id":"ck71t2tu4001cmn8ngntd57hf","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tu8001omn8ndc562b3m"},{"post_id":"ck71t2tu5001gmn8nejeeeeqm","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tua001rmn8nhdpuhs2n"},{"post_id":"ck71t2tu6001jmn8n1no525io","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tuc001vmn8n5jidgkc6"},{"post_id":"ck71t2tu7001nmn8n2il985wx","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tud001ymn8n22g3g1dq"},{"post_id":"ck71t2tu8001qmn8nc37x7v67","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck71t2tue0022mn8ncw2o05lu"},{"post_id":"ck71t2tub001umn8ncxzjh4o8","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck71t2tuf0025mn8n560ygm2b"},{"post_id":"ck71t2tuc001xmn8ndpwccoxe","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck71t2tuf0029mn8n2t7u5f1c"},{"post_id":"ck71t2tue0021mn8nedsd9una","category_id":"ck68nkriy0001ou8ne42pe2sm","_id":"ck71t2tug002cmn8ncdp1awwc"},{"post_id":"ck71t2tue0024mn8n5q26ao7w","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck71t2tuh002gmn8n4yczelcl"},{"post_id":"ck71t2tuf0028mn8nhtn96d40","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck71t2tuh002imn8ncc2g9rau"},{"post_id":"ck71t2tug002bmn8ncslh8u3d","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck71t2tui002kmn8n7zt2fz1k"},{"post_id":"ck7cxr5db00005x8n9872dt3v","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dj00065x8n92cq8tmt"},{"post_id":"ck7cxr5de00015x8nfjw3ds7g","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dk00095x8ne3dk94gj"},{"post_id":"ck7cxr5dg00035x8nej0hbp1d","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dl000c5x8nh4vjd5rl"},{"post_id":"ck7cxr5di00055x8n1ehw8jio","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dm000f5x8n94vq5c5g"},{"post_id":"ck7cxr5dj00085x8ncd0n4p58","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dn000i5x8n0dly8gpd"},{"post_id":"ck7cxr5dk000b5x8n8yt0hqgt","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dn000l5x8n8kua3eiz"},{"post_id":"ck7cxr5dl000e5x8ncwnj3jvy","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5do000o5x8nbq0mf5wk"},{"post_id":"ck7cxr5dm000h5x8n7iccfr9g","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dp000r5x8n9habbf2a"},{"post_id":"ck7cxr5dn000k5x8n1yt2famn","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dt000u5x8n6yv84l0s"},{"post_id":"ck7cxr5do000n5x8nbcuu5wck","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5du000x5x8n3btge1nx"},{"post_id":"ck7cxr5dp000q5x8n2v5v2gb4","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dv00105x8n6lqj5jmd"},{"post_id":"ck7cxr5dq000t5x8ng8u5axpm","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dx00135x8nfjktdf1q"},{"post_id":"ck7cxr5dt000w5x8n3co43bj1","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dy00165x8n6khd5mph"},{"post_id":"ck7cxr5du000z5x8nexym5n3z","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5dz00195x8n5tffe6z9"},{"post_id":"ck7cxr5dw00125x8nhnrmfp0j","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5e0001c5x8nel6eb56m"},{"post_id":"ck7cxr5dy00185x8nhdd93fie","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5e1001g5x8n8ggef4tp"},{"post_id":"ck7cxr5dz001b5x8ne3sp17hz","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck7cxr5e1001i5x8ndv3c8r0p"},{"post_id":"ck845eiwz0000ny8nan4edl6j","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eix70006ny8nc54id1zz"},{"post_id":"ck845eix30001ny8na01y8cxy","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eix80009ny8nchoi05jo"},{"post_id":"ck845eix50003ny8nals8fozq","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eixh000cny8nhhxje1oc"},{"post_id":"ck845eix60005ny8n87fngdrc","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eixi000fny8n3x9sfidj"},{"post_id":"ck845eix70008ny8n3lgyh8rv","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eixj000iny8n0yb99bth"},{"post_id":"ck845eixg000bny8n5v49ek2h","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eixk000lny8n26sxfqql"},{"post_id":"ck845eixh000eny8negvbei6t","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eixl000ony8n5iy788ic"},{"post_id":"ck845eixi000hny8ng4gv4z8f","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eixl000rny8nfiwff4d0"},{"post_id":"ck845eixj000kny8nawyp8ch6","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eixm000uny8naqwk8dd0"},{"post_id":"ck845eixk000nny8nh6nu6gwb","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eixn000wny8nh5uf5yb4"},{"post_id":"ck845eixl000qny8n0d6ld6j7","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eixn000yny8nfyus5vfc"},{"post_id":"ck845eixm000tny8n4iwde5k5","category_id":"ck5nll6p60002yr8nfnh3c7i5","_id":"ck845eixn0010ny8n6p2s6yij"},{"post_id":"ckppj72nc0001i1gie66rhi8w","category_id":"ck5nh0lh30001lm8n9249aid1","_id":"ckppj72ni0006i1giafz0fxgs"},{"post_id":"ckppj72nf0002i1gi5ba448v9","category_id":"ck5nh0lh80007lm8nbr7s579v","_id":"ckppj72ni0008i1gi8x747ybl"}],"PostTag":[{"post_id":"ck5novm9l00006d8n7mli58r2","tag_id":"ck5nh0lh80009lm8n98pe5nu9","_id":"ck5novm9q00026d8n5qxm46e8"},{"post_id":"ck5novm9l00006d8n7mli58r2","tag_id":"ck5nh0lh9000blm8ng6su9wxe","_id":"ck5novm9q00036d8ngg189d5n"},{"post_id":"ck5novm9o00016d8nb3vafdn9","tag_id":"ck5nh0lh80009lm8n98pe5nu9","_id":"ck5novm9r00056d8nb921c62t"},{"post_id":"ck5novm9o00016d8nb3vafdn9","tag_id":"ck5nh0lh9000blm8ng6su9wxe","_id":"ck5novm9r00076d8n14rmgf5g"},{"post_id":"ck5qn1b7o00033v8ng2vrcszt","tag_id":"ck5naw6gd0000f08ncb8ygep1","_id":"ck5qn1b7q00053v8n1mk8bb2s"},{"post_id":"ck5qn1b7h00003v8n3gbo3kdj","tag_id":"ck5qn1b7m00023v8n8fzog2yt","_id":"ck5qn1b7r000a3v8ncjft489w"},{"post_id":"ck5qn1b7h00003v8n3gbo3kdj","tag_id":"ck5qn1b7q00073v8n1aiw2hdv","_id":"ck5qn1b7r000b3v8nc1o4dmaj"},{"post_id":"ck5qn1b7k00013v8n7maydkok","tag_id":"ck5qn1b7q00093v8ndl8tfbtb","_id":"ck5qn1b7r000c3v8nezjxc9e1"},{"post_id":"ck5qn1b7k00013v8n7maydkok","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck5qn1b7r000d3v8n3ki549av"},{"post_id":"ck5qn1b7s000e3v8n5q6g9lny","tag_id":"ck5qn1b7q00073v8n1aiw2hdv","_id":"ck5qn1b7t000f3v8n3jic5hml"},{"post_id":"ck5qn1b7w000h3v8n2tqr4ykg","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck5qn1b81000q3v8nhq0ke4z6"},{"post_id":"ck5qn1b7w000h3v8n2tqr4ykg","tag_id":"ck5qn1b7x000j3v8ne6cjg4yk","_id":"ck5qn1b82000t3v8n4v9sacpx"},{"post_id":"ck5qn1b7z000n3v8ncp3de2gn","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck5qn1b83000x3v8ndqs25ny6"},{"post_id":"ck5qn1b7z000n3v8ncp3de2gn","tag_id":"ck5qn1b7x000j3v8ne6cjg4yk","_id":"ck5qn1b8400103v8n9sog4dqp"},{"post_id":"ck5qn1b7x000i3v8napp29d7n","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck5qn1b8500143v8n9bdvfhuj"},{"post_id":"ck5qn1b7x000i3v8napp29d7n","tag_id":"ck5qn1b7x000j3v8ne6cjg4yk","_id":"ck5qn1b8600173v8n7s3n5muz"},{"post_id":"ck5qn1b82000u3v8nhpi5hwkr","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck5qn1b88001b3v8n4mko9qa4"},{"post_id":"ck5qn1b82000u3v8nhpi5hwkr","tag_id":"ck5qn1b7m00023v8n8fzog2yt","_id":"ck5qn1b89001e3v8nbxtwhtl8"},{"post_id":"ck5qn1b82000u3v8nhpi5hwkr","tag_id":"ck5qn1b7x000j3v8ne6cjg4yk","_id":"ck5qn1b8a001i3v8ncx5x7n7j"},{"post_id":"ck5qn1b8400113v8n58eqbqey","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck5qn1b8b001l3v8n2wf3c4cy"},{"post_id":"ck5qn1b8400113v8n58eqbqey","tag_id":"ck5qn1b7x000j3v8ne6cjg4yk","_id":"ck5qn1b8c001p3v8nc20w5hqr"},{"post_id":"ck5qn1b8400113v8n58eqbqey","tag_id":"ck5qn1b7m00023v8n8fzog2yt","_id":"ck5qn1b8d001r3v8n2nyl6rj0"},{"post_id":"ck5qn1b7y000k3v8n3ekzdyh1","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck5qn1b8d001w3v8ndjejgqt9"},{"post_id":"ck5qn1b7y000k3v8n3ekzdyh1","tag_id":"ck5qn1b82000w3v8nf2z1dexk","_id":"ck5qn1b8e001x3v8nguwscx2t"},{"post_id":"ck5qn1b7y000k3v8n3ekzdyh1","tag_id":"ck5qn1b7x000j3v8ne6cjg4yk","_id":"ck5qn1b8e001z3v8n2q4ddawi"},{"post_id":"ck5qn1b88001c3v8nb52p6t2x","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck5qn1b8e00213v8ncy5rhvbn"},{"post_id":"ck5qn1b88001c3v8nb52p6t2x","tag_id":"ck5qn1b82000w3v8nf2z1dexk","_id":"ck5qn1b8f00223v8naj898jrg"},{"post_id":"ck5qn1b88001c3v8nb52p6t2x","tag_id":"ck5qn1b7x000j3v8ne6cjg4yk","_id":"ck5qn1b8f00233v8n742k4oxo"},{"post_id":"ck5qn1b7y000l3v8n3rui7k3o","tag_id":"ck5qn1b87001a3v8nays8afea","_id":"ck5qn1b8g00243v8nhcj1f44t"},{"post_id":"ck5qn1b7y000l3v8n3rui7k3o","tag_id":"ck5qn1b7x000j3v8ne6cjg4yk","_id":"ck5qn1b8g00253v8nhe1472qi"},{"post_id":"ck5qn1b81000r3v8ndvfzenfu","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck5qn1b8g00273v8n3jnoci9s"},{"post_id":"ck5qn1b81000r3v8ndvfzenfu","tag_id":"ck5qn1b8a001h3v8n8rfp06ko","_id":"ck5qn1b8g00283v8n91b6b69y"},{"post_id":"ck5qn1b81000r3v8ndvfzenfu","tag_id":"ck5qn1b7x000j3v8ne6cjg4yk","_id":"ck5qn1b8g00293v8ne8r85xaf"},{"post_id":"ck5qn1b83000y3v8nb9th7c7r","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck5qn1b8g002b3v8n35ul2bbu"},{"post_id":"ck5qn1b83000y3v8nb9th7c7r","tag_id":"ck5qn1b8a001h3v8n8rfp06ko","_id":"ck5qn1b8g002c3v8nca1092r0"},{"post_id":"ck5qn1b83000y3v8nb9th7c7r","tag_id":"ck5nh0lh80009lm8n98pe5nu9","_id":"ck5qn1b8g002d3v8n4hlc5t37"},{"post_id":"ck5qn1b83000y3v8nb9th7c7r","tag_id":"ck5qn1b7x000j3v8ne6cjg4yk","_id":"ck5qn1b8h002e3v8n6z6maqoo"},{"post_id":"ck68nkriu0000ou8ngc0b3gu4","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck68nkrj50005ou8nbbgs7vvp"},{"post_id":"ck68nkriu0000ou8ngc0b3gu4","tag_id":"ck68nkrj50003ou8n2wpq20f4","_id":"ck68nkrj60006ou8n5wvc7juk"},{"post_id":"ck68nkrja000bou8ncn08f32i","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck68nkrjd000gou8ng3uy7bfz"},{"post_id":"ck68nkrja000bou8ncn08f32i","tag_id":"ck68nkrj90009ou8n5haa9gq3","_id":"ck68nkrjd000iou8n79hh0blq"},{"post_id":"ck68nkrj80007ou8n07j5enpf","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck68nkrje000lou8n2p3ud8zn"},{"post_id":"ck68nkrj80007ou8n07j5enpf","tag_id":"ck68nkrj90009ou8n5haa9gq3","_id":"ck68nkrje000nou8n155h6txo"},{"post_id":"ck68nkrjb000dou8nbm9ma4ko","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck68nkrje000oou8ndt7m26h5"},{"post_id":"ck68nkrjb000dou8nbm9ma4ko","tag_id":"ck68nkrj90009ou8n5haa9gq3","_id":"ck68nkrjf000pou8ngcvubv7h"},{"post_id":"ck68nkrj80008ou8n65gq9e8s","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck68nkrjf000qou8n2iva9gvi"},{"post_id":"ck68nkrj80008ou8n65gq9e8s","tag_id":"ck68nkrj90009ou8n5haa9gq3","_id":"ck68nkrjf000rou8ndnsrgwyo"},{"post_id":"ck68nkrj9000aou8n6193021y","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck68nkrjf000sou8n4dzp4s2t"},{"post_id":"ck68nkrj9000aou8n6193021y","tag_id":"ck68nkrj90009ou8n5haa9gq3","_id":"ck68nkrjf000tou8nc6cba5y0"},{"post_id":"ck71t2ttf0004mn8n0lsw1z9l","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tts000dmn8ncc4iexrg"},{"post_id":"ck71t2ttf0004mn8n0lsw1z9l","tag_id":"ck71t2ttg0006mn8n5nlc0k5c","_id":"ck71t2ttv000gmn8n0e2xa1jk"},{"post_id":"ck71t2tts000emn8nc759hbmx","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2ttw000kmn8ngl6459i6"},{"post_id":"ck71t2tts000emn8nc759hbmx","tag_id":"ck71t2ttg0006mn8n5nlc0k5c","_id":"ck71t2ttx000nmn8n85z7ar8z"},{"post_id":"ck71t2ttf0005mn8ng1pke3lf","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tty000rmn8n87kr2gsw"},{"post_id":"ck71t2ttf0005mn8ng1pke3lf","tag_id":"ck71t2ttg0006mn8n5nlc0k5c","_id":"ck71t2ttz000umn8n6ghzhfp5"},{"post_id":"ck71t2ttv000hmn8n8y1329u9","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tu0000ymn8nczou6uim"},{"post_id":"ck71t2ttv000hmn8n8y1329u9","tag_id":"ck68nkrj50003ou8n2wpq20f4","_id":"ck71t2tu10011mn8nc757braj"},{"post_id":"ck71t2ttp0007mn8ndfhh73b6","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tu30015mn8nb06c6l2j"},{"post_id":"ck71t2ttp0007mn8ndfhh73b6","tag_id":"ck71t2ttv000jmn8n6tvz4aid","_id":"ck71t2tu30018mn8ngshn4vjn"},{"post_id":"ck71t2tty000smn8ncdd5d11g","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tu4001bmn8n9gcfa0ly"},{"post_id":"ck71t2tty000smn8ncdd5d11g","tag_id":"ck71t2ttv000jmn8n6tvz4aid","_id":"ck71t2tu5001fmn8nge8s3zjz"},{"post_id":"ck71t2ttq0008mn8nahzycueq","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tu6001imn8n73mnc8uv"},{"post_id":"ck71t2ttq0008mn8nahzycueq","tag_id":"ck71t2tty000qmn8n0tk411xz","_id":"ck71t2tu7001mmn8neag0a7pv"},{"post_id":"ck71t2tu0000zmn8n4gxyg6z1","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tu8001pmn8ngbykh6qq"},{"post_id":"ck71t2tu0000zmn8n4gxyg6z1","tag_id":"ck68nkrj50003ou8n2wpq20f4","_id":"ck71t2tub001tmn8nhssc3j86"},{"post_id":"ck71t2ttq000amn8nelo246dm","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tuc001wmn8n7gn17vdy"},{"post_id":"ck71t2ttq000amn8nelo246dm","tag_id":"ck71t2tu0000xmn8n3ya768i9","_id":"ck71t2tud0020mn8nf5dn26pz"},{"post_id":"ck71t2tu30019mn8na5r03513","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tue0023mn8n52rl2f0a"},{"post_id":"ck71t2tu30019mn8na5r03513","tag_id":"ck71t2tu20014mn8nggsp5msr","_id":"ck71t2tuf0027mn8nfriq923t"},{"post_id":"ck71t2ttw000lmn8naakdgtfc","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tug002amn8n5z4u0ox5"},{"post_id":"ck71t2ttw000lmn8naakdgtfc","tag_id":"ck71t2tu20014mn8nggsp5msr","_id":"ck71t2tuh002emn8n0jl69dq5"},{"post_id":"ck71t2tu5001gmn8nejeeeeqm","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tuh002hmn8nhxk27zsz"},{"post_id":"ck71t2tu5001gmn8nejeeeeqm","tag_id":"ck71t2tu20014mn8nggsp5msr","_id":"ck71t2tui002jmn8n8h51976b"},{"post_id":"ck71t2ttx000omn8ngdalhe78","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tui002mmn8n4d5dgi46"},{"post_id":"ck71t2ttx000omn8ngdalhe78","tag_id":"ck71t2tu5001emn8n2ebab5cw","_id":"ck71t2tui002omn8naokp46y4"},{"post_id":"ck71t2ttz000vmn8nhbz79ydz","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tui002qmn8nhbvi3nim"},{"post_id":"ck71t2ttz000vmn8nhbz79ydz","tag_id":"ck71t2tu20014mn8nggsp5msr","_id":"ck71t2tui002rmn8nhiicflv7"},{"post_id":"ck71t2tu10012mn8n62k3bnj7","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tuj002tmn8n12o1gx66"},{"post_id":"ck71t2tu10012mn8n62k3bnj7","tag_id":"ck71t2tu20014mn8nggsp5msr","_id":"ck71t2tuj002umn8ngjza35gf"},{"post_id":"ck71t2tu30016mn8n7vyx6jou","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tuj002wmn8nan2oamsv"},{"post_id":"ck71t2tu30016mn8n7vyx6jou","tag_id":"ck71t2tud001zmn8nd0tj9yh7","_id":"ck71t2tuj002xmn8nfu9gh55e"},{"post_id":"ck71t2tu4001cmn8ngntd57hf","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tuk002zmn8n2re4a18v"},{"post_id":"ck71t2tu4001cmn8ngntd57hf","tag_id":"ck71t2tuf0026mn8n0f2z0pke","_id":"ck71t2tuk0030mn8n5cm464v6"},{"post_id":"ck71t2tu6001jmn8n1no525io","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tul0036mn8na417fcj0"},{"post_id":"ck71t2tu6001jmn8n1no525io","tag_id":"ck71t2tug002dmn8ne7j98cns","_id":"ck71t2tum0038mn8n81lsg7jx"},{"post_id":"ck71t2tu7001nmn8n2il985wx","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tum0039mn8n80ui8idu"},{"post_id":"ck71t2tu7001nmn8n2il985wx","tag_id":"ck71t2tui002lmn8nax7va0fs","_id":"ck71t2tum003amn8n5n0gfdat"},{"post_id":"ck71t2tu8001qmn8nc37x7v67","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck71t2tum003bmn8n471dc3lj"},{"post_id":"ck71t2tub001umn8ncxzjh4o8","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck71t2tum003cmn8n5ocmb0hj"},{"post_id":"ck71t2tuc001xmn8ndpwccoxe","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck71t2tum003dmn8n5zjk4f7r"},{"post_id":"ck71t2tue0021mn8nedsd9una","tag_id":"ck68nkrj40002ou8n5j2rbu7p","_id":"ck71t2tum003emn8n8ipv0gbj"},{"post_id":"ck71t2tue0021mn8nedsd9una","tag_id":"ck71t2tui002lmn8nax7va0fs","_id":"ck71t2tum003fmn8n3z447ls6"},{"post_id":"ck71t2tue0024mn8n5q26ao7w","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck71t2tum003gmn8nam880c9p"},{"post_id":"ck71t2tuf0028mn8nhtn96d40","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck71t2tum003hmn8nc7y9fn0k"},{"post_id":"ck71t2tug002bmn8ncslh8u3d","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck71t2tum003imn8n3e8bfjac"},{"post_id":"ck7cxr5db00005x8n9872dt3v","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck7cxr5dg00025x8ne3es3vfa"},{"post_id":"ck7cxr5de00015x8nfjw3ds7g","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck7cxr5di00045x8nh3cabgjr"},{"post_id":"ck7cxr5dg00035x8nej0hbp1d","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck7cxr5dj00075x8nagvibo64"},{"post_id":"ck7cxr5di00055x8n1ehw8jio","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck7cxr5dk000a5x8n6mzkdh2c"},{"post_id":"ck7cxr5dj00085x8ncd0n4p58","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck7cxr5dl000d5x8nb2g7c5f3"},{"post_id":"ck7cxr5dk000b5x8n8yt0hqgt","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck7cxr5dm000g5x8n7ov7asel"},{"post_id":"ck7cxr5dl000e5x8ncwnj3jvy","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck7cxr5dn000j5x8ngcav7abb"},{"post_id":"ck7cxr5dm000h5x8n7iccfr9g","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck7cxr5do000m5x8n8fgj31tq"},{"post_id":"ck7cxr5dn000k5x8n1yt2famn","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck7cxr5dp000p5x8n3vufgxio"},{"post_id":"ck7cxr5do000n5x8nbcuu5wck","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck7cxr5dq000s5x8ncthz68sr"},{"post_id":"ck7cxr5dp000q5x8n2v5v2gb4","tag_id":"ck5nll6pa0007yr8nb5ot0ak6","_id":"ck7cxr5dt000v5x8n5x0b80oi"},{"post_id":"ck7cxr5dp000q5x8n2v5v2gb4","tag_id":"ck5qn1b8d001t3v8nfeud0bpm","_id":"ck7cxr5du000y5x8n12z3er87"},{"post_id":"ck7cxr5dp000q5x8n2v5v2gb4","tag_id":"ck5qn1b8e001y3v8ndy3kdnrd","_id":"ck7cxr5dw00115x8n6j7b2egg"},{"post_id":"ck7cxr5dq000t5x8ng8u5axpm","tag_id":"ck5nnaxjy000e2n8n7fksde7s","_id":"ck7cxr5dx00145x8n456vbj9l"},{"post_id":"ck7cxr5dq000t5x8ng8u5axpm","tag_id":"ck5nnaxk0000l2n8n0g1q7p8b","_id":"ck7cxr5dy00175x8n09hy8bzv"},{"post_id":"ck7cxr5dt000w5x8n3co43bj1","tag_id":"ck5nll6pd000gyr8n5pse4f4l","_id":"ck7cxr5dz001a5x8ncyfm9w5r"},{"post_id":"ck7cxr5dt000w5x8n3co43bj1","tag_id":"ck5nll6pd000iyr8n0xbd2vvz","_id":"ck7cxr5e0001d5x8n3nl14ae4"},{"post_id":"ck7cxr5dt000w5x8n3co43bj1","tag_id":"ck5nll6pe000jyr8nfukieyp2","_id":"ck7cxr5e1001f5x8ndqku2ssj"},{"post_id":"ck7cxr5du000z5x8nexym5n3z","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck7cxr5e1001h5x8nhc08h0bm"},{"post_id":"ck7cxr5dw00125x8nhnrmfp0j","tag_id":"ck5nnaxk0000q2n8ngzi4erb8","_id":"ck7cxr5e1001j5x8naebtad35"},{"post_id":"ck7cxr5dy00185x8nhdd93fie","tag_id":"ck5nll6pa0007yr8nb5ot0ak6","_id":"ck7cxr5e1001n5x8n3jf4aeqa"},{"post_id":"ck7cxr5dy00185x8nhdd93fie","tag_id":"ck5nll6pb000byr8navgldqhp","_id":"ck7cxr5e1001o5x8nbsy5hccr"},{"post_id":"ck7cxr5dz001b5x8ne3sp17hz","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck7cxr5e1001p5x8n3w9x0e1q"},{"post_id":"ck845eiwz0000ny8nan4edl6j","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck845eix50002ny8nh9jf5t28"},{"post_id":"ck845eix30001ny8na01y8cxy","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck845eix60004ny8n7f804jik"},{"post_id":"ck845eix50003ny8nals8fozq","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck845eix70007ny8n5mbq5yvy"},{"post_id":"ck845eix70008ny8n3lgyh8rv","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck845eixh000dny8n83j19jh1"},{"post_id":"ck845eixg000bny8n5v49ek2h","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck845eixi000gny8n71lu2qgn"},{"post_id":"ck845eixh000eny8negvbei6t","tag_id":"ck845eix8000any8ngjzs9og3","_id":"ck845eixj000jny8nb14u88ma"},{"post_id":"ck845eix60005ny8n87fngdrc","tag_id":"ck845eix8000any8ngjzs9og3","_id":"ck845eixk000mny8nhcfc5pyj"},{"post_id":"ck845eixi000hny8ng4gv4z8f","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck845eixl000pny8nch544jgl"},{"post_id":"ck845eixj000kny8nawyp8ch6","tag_id":"ck5nnaxjq00012n8n3xil8iin","_id":"ck845eixm000sny8n0k3t8m7e"},{"post_id":"ck845eixk000nny8nh6nu6gwb","tag_id":"ck71t2tui002pmn8nhjswhhce","_id":"ck845eixm000vny8n8arhevkt"},{"post_id":"ck845eixl000qny8n0d6ld6j7","tag_id":"ck5nnaxjy000e2n8n7fksde7s","_id":"ck845eixn000xny8n52op8zyb"},{"post_id":"ck845eixl000qny8n0d6ld6j7","tag_id":"ck5nnaxk0000l2n8n0g1q7p8b","_id":"ck845eixn000zny8n74gw45bq"},{"post_id":"ck845eixm000tny8n4iwde5k5","tag_id":"ck5nll6p90005yr8n2d1nhnxn","_id":"ck845eixn0011ny8ncztecucy"},{"post_id":"ckppj72nc0001i1gie66rhi8w","tag_id":"ck5mj61zh0001k3gicidh914f","_id":"ckppj72ng0003i1gibivfh5hu"},{"post_id":"ckppj72nc0001i1gie66rhi8w","tag_id":"ck5naw6gd0000f08ncb8ygep1","_id":"ckppj72ni0005i1gi5v14crm3"},{"post_id":"ckppj72nf0002i1gi5ba448v9","tag_id":"ck5naxyeu0002fn8n6et30e1v","_id":"ckppj72ni0007i1gi882695gr"}],"Tag":[{"name":"node","_id":"ck5mj61zh0001k3gicidh914f"},{"name":"hero","_id":"ck5mj61zi0002k3gicv61bent"},{"name":"hexo","_id":"ck5naw6gd0000f08ncb8ygep1"},{"name":"python","_id":"ck5naxyeu0002fn8n6et30e1v"},{"name":"php","_id":"ck5nh0lh80009lm8n98pe5nu9"},{"name":"服务器","_id":"ck5nh0lh9000blm8ng6su9wxe"},{"name":"高并发","_id":"ck5nll6p80003yr8n0jiegdk1"},{"name":"go","_id":"ck5nll6p90005yr8n2d1nhnxn"},{"name":"http","_id":"ck5nll6pa0007yr8nb5ot0ak6"},{"name":"网络","_id":"ck5nll6pb000byr8navgldqhp"},{"name":"redis","_id":"ck5nll6pd000gyr8n5pse4f4l"},{"name":"memcache","_id":"ck5nll6pd000iyr8n0xbd2vvz"},{"name":"缓存","_id":"ck5nll6pe000jyr8nfukieyp2"},{"name":"linux","_id":"ck5nnaxjq00012n8n3xil8iin"},{"name":"数据库","_id":"ck5nnaxjy000e2n8n7fksde7s"},{"name":"MYSQL","_id":"ck5nnaxk0000l2n8n0g1q7p8b"},{"name":"设计模式","_id":"ck5nnaxk0000q2n8ngzi4erb8"},{"name":"mysql","_id":"ck5qn1b7m00023v8n8fzog2yt"},{"name":"应用安装","_id":"ck5qn1b7q00073v8n1aiw2hdv"},{"name":"wine","_id":"ck5qn1b7q00093v8ndl8tfbtb"},{"name":"云服务器","_id":"ck5qn1b7x000j3v8ne6cjg4yk"},{"name":"快捷键","_id":"ck5qn1b82000w3v8nf2z1dexk"},{"name":"git","_id":"ck5qn1b87001a3v8nays8afea"},{"name":"nginx","_id":"ck5qn1b8a001h3v8n8rfp06ko"},{"name":"rpc","_id":"ck5qn1b8d001t3v8nfeud0bpm"},{"name":"thrift","_id":"ck5qn1b8e001y3v8ndy3kdnrd"},{"name":"算法","_id":"ck68nkrj40002ou8n5j2rbu7p"},{"name":"栈","_id":"ck68nkrj50003ou8n2wpq20f4"},{"name":"链表","_id":"ck68nkrj90009ou8n5haa9gq3"},{"name":"位运算","_id":"ck71t2ttg0006mn8n5nlc0k5c"},{"name":"剪枝","_id":"ck71t2ttv000jmn8n6tvz4aid"},{"name":"哈希表","_id":"ck71t2tty000qmn8n0tk411xz"},{"name":"二分法","_id":"ck71t2tu0000xmn8n3ya768i9"},{"name":"树","_id":"ck71t2tu20014mn8nggsp5msr"},{"name":"队列","_id":"ck71t2tu5001emn8n2ebab5cw"},{"name":"贪心","_id":"ck71t2tud001zmn8nd0tj9yh7"},{"name":"字符串","_id":"ck71t2tuf0026mn8n0f2z0pke"},{"name":"递归","_id":"ck71t2tug002dmn8ne7j98cns"},{"name":"分治","_id":"ck71t2tui002lmn8nax7va0fs"},{"name":"复盘","_id":"ck71t2tui002pmn8nhjswhhce"},{"name":"golang","_id":"ck845eix8000any8ngjzs9og3"}]}}